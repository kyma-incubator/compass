scalar AdditionalProperties

enum KymaModule {
    Backup
    BackupInit
    Jaeger
    Logging
    Monitoring
    PrometheusOperator
    Kiali
    KnativeBuild
}

# Configuration of Runtime. We can consider returning kubeconfig as a part of this type.
type RuntimeConfig {
    clusterConfig: ClusterConfig
    kymaConfig: KymaConfig
}

type ClusterConfig {
    name: String
    nodeCount: Int
    diskSize: String
    machineType: String
    computeZone: String
    version: String
    providerConfig: ProviderConfig
}

union ProviderConfig = GardenerProviderConfig | GCPProviderConfig | AKSProviderConfig

type GardenerProviderConfig {
    targetProvider: String
    targetSecret: String
    autoScalerMin: Int
    autoScalerMax: Int
    maxSurge: Int
    maxUnavailable: Int
    additionalProperties: AdditionalProperties
}

type GCPProviderConfig {
    additionalProperties: AdditionalProperties
}

type AKSProviderConfig {
    additionalProperties: AdditionalProperties
}

type KymaConfig {
    version: String
    modules: [KymaModule]
}

type OperationStatus {
    operation: OperationType!
    state: OperationState!
    message: String!
    runtimeID: String!
}

enum OperationType {
    Provision
    Upgrade
    Deprovision
    ReconnectRuntime
}

type Error {
    message: String
}

type RuntimeConnectionStatus {
    status: RuntimeAgentConnectionStatus!
    errors: [Error!]
}

# We should consider renamig this type, as it contains more than just status.
type RuntimeStatus {
    lastOperationStatus: OperationStatus
    runtimeConnectionStatus: RuntimeConnectionStatus
    runtimeConnectionConfig: RuntimeConnectionConfig
    runtimeConfiguration: RuntimeConfig
}

enum OperationState {
    Pending
    InProgress
    Succeeded
    Failed
}

enum RuntimeAgentConnectionStatus {
    Pending
    Connected
    Disconnected
}

type RuntimeConnectionConfig {
    kubeconfig: String!
}

# Inputs

input ProvisionRuntimeInput {
    clusterConfig: ClusterConfigInput!
    kymaConfig: KymaConfigInput!
}

# Defines the desired cluster to provision, specifying its size, memory, Kubernetes version, etc.
input ClusterConfigInput {
    name: String!
    nodeCount: Int
    diskSize: String
    machineType: String
    computeZone: String!
    version: String
    credentials: CredentialsInput!
    providerConfig: ProviderConfigInput!
}

input CredentialsInput {
    secretName: String!
}

input ProviderConfigInput {
    gardenerProviderConfig: GardenerProviderConfigInput
    gcpProviderConfig: GCPProviderConfigInput
    aksProviderConfig: AKSProviderConfigInput
}

input GardenerProviderConfigInput {
    targetProvider: String!
    targetSecret: String!
    autoScalerMin: Int
    autoScalerMax: Int
    maxSurge: Int
    maxUnavailable: Int
    additionalProperties: AdditionalProperties
}

input GCPProviderConfigInput {
    additionalProperties: AdditionalProperties
}

input AKSProviderConfigInput {
    additionalProperties: AdditionalProperties
}

input KymaConfigInput {
    version: String!
    modules: [KymaModule!]
}

input UpgradeRuntimeInput {
    clusterConfig: UpgradeClusterInput
    kymaConfig: KymaConfigInput
}

input UpgradeClusterInput {
    version: String!
}

type Mutation {
    # Runtime Management; only one asynchronous operation per RuntimeID can run at any given point in time
    provisionRuntime(id: String!, config: ProvisionRuntimeInput): String!
    upgradeRuntime(id: String!, config: UpgradeRuntimeInput): String!
    deprovisionRuntime(id: String!): String!

    # Compass Runtime Agent Connection Management
    reconnectRuntimeAgent(id: String!): String!
}

type Query {
    # Provides current status of specified Runtime
    runtimeStatus(id: String!): RuntimeStatus

    # Provides status of specified operation
    runtimeOperationStatus(id: String!): OperationStatus
}
