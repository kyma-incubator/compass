// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"io"
	"strconv"
)

type CredentialData interface {
	IsCredentialData()
}

type FormationParticipant interface {
	IsFormationParticipant()
}

type OneTimeToken interface {
	IsOneTimeToken()
}

// Every query that implements pagination returns object that implements Pageable interface.
// To specify page details, query specify two parameters: `first` and `after`.
// `first` specify page size, `after` is a cursor for the next page. When requesting first page, set `after` to empty value.
// For requesting next page, set `after` to `pageInfo.endCursor` returned from previous query.
type Pageable interface {
	IsPageable()
}

type SystemAuth interface {
	IsSystemAuth()
}

type APIDefinitionInput struct {
	// **Validation:** ASCII printable characters, max=100
	Name string `json:"name"`
	// **Validation:** max=2000
	Description *string `json:"description,omitempty"`
	// **Validation:** valid URL, max=256
	TargetURL string `json:"targetURL"`
	// **Validation:** max=100
	Group   *string       `json:"group,omitempty"`
	Spec    *APISpecInput `json:"spec,omitempty"`
	Version *VersionInput `json:"version,omitempty"`
}

type APIDefinitionPage struct {
	Data       []*APIDefinition `json:"data"`
	PageInfo   *PageInfo        `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (APIDefinitionPage) IsPageable() {}

// **Validation:**
// - for ODATA type, accepted formats are XML and JSON, for OPEN_API accepted formats are YAML and JSON
// - data or fetchRequest required
type APISpecInput struct {
	Data         *CLOB              `json:"data,omitempty"`
	Type         APISpecType        `json:"type"`
	Format       SpecFormat         `json:"format"`
	FetchRequest *FetchRequestInput `json:"fetchRequest,omitempty"`
}

type AppSystemAuth struct {
	ID                string                   `json:"id"`
	Auth              *Auth                    `json:"auth,omitempty"`
	Type              *SystemAuthReferenceType `json:"type,omitempty"`
	TenantID          *string                  `json:"tenantId,omitempty"`
	ReferenceObjectID *string                  `json:"referenceObjectId,omitempty"`
}

func (AppSystemAuth) IsSystemAuth() {}

type ApplicationEventingConfiguration struct {
	DefaultURL string `json:"defaultURL"`
}

// **Validation:** provided placeholders' names are unique
type ApplicationFromTemplateInput struct {
	ID *string `json:"id,omitempty"`
	// **Validation:** ASCII printable characters, max=100
	TemplateName string `json:"templateName"`
	// **Validation:** if provided, placeholdersPayload not required
	Values []*TemplateValueInput `json:"values,omitempty"`
	// **Validation:** if provided, values not required
	PlaceholdersPayload *string `json:"placeholdersPayload,omitempty"`
	Labels              Labels  `json:"labels,omitempty"`
}

type ApplicationJSONInput struct {
	// **Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	Name string `json:"name"`
	// **Validation:** max=256
	ProviderName *string `json:"providerName,omitempty"`
	// **Validation:** max=2000
	Description *string `json:"description,omitempty"`
	// **Validation:** label key is alphanumeric with underscore
	Labels   Labels          `json:"labels,omitempty"`
	Webhooks []*WebhookInput `json:"webhooks,omitempty"`
	// **Validation:** valid URL, max=256
	HealthCheckURL *string `json:"healthCheckURL,omitempty"`
	// **Validation:** valid URL, max=256
	BaseURL              *string                     `json:"baseUrl,omitempty"`
	ApplicationNamespace *string                     `json:"applicationNamespace,omitempty"`
	IntegrationSystemID  *string                     `json:"integrationSystemID,omitempty"`
	StatusCondition      *ApplicationStatusCondition `json:"statusCondition,omitempty"`
	LocalTenantID        *string                     `json:"localTenantID,omitempty"`
	Bundles              []*BundleCreateInput        `json:"bundles,omitempty"`
}

type ApplicationPage struct {
	Data       []*Application `json:"data"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (ApplicationPage) IsPageable() {}

type ApplicationRegisterInput struct {
	// **Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	Name string `json:"name"`
	// **Validation:** max=256
	ProviderName *string `json:"providerName,omitempty"`
	// **Validation:** max=2000
	Description *string `json:"description,omitempty"`
	// **Validation:** label key is alphanumeric with underscore
	Labels   Labels          `json:"labels,omitempty"`
	Webhooks []*WebhookInput `json:"webhooks,omitempty"`
	// **Validation:** valid URL, max=256
	HealthCheckURL *string `json:"healthCheckURL,omitempty"`
	// **Validation:** valid URL, max=256
	BaseURL              *string                     `json:"baseUrl,omitempty"`
	ApplicationNamespace *string                     `json:"applicationNamespace,omitempty"`
	IntegrationSystemID  *string                     `json:"integrationSystemID,omitempty"`
	StatusCondition      *ApplicationStatusCondition `json:"statusCondition,omitempty"`
	LocalTenantID        *string                     `json:"localTenantID,omitempty"`
	Bundles              []*BundleCreateInput        `json:"bundles,omitempty"`
}

type ApplicationStatus struct {
	Condition ApplicationStatusCondition `json:"condition"`
	Timestamp Timestamp                  `json:"timestamp"`
}

// **Validation:** provided placeholders' names are unique and used in applicationInput
type ApplicationTemplateInput struct {
	// **Validation:** ASCII printable characters, max=100
	Name string `json:"name"`
	// **Validation:** max=2000
	Webhooks    []*WebhookInput `json:"webhooks,omitempty"`
	Description *string         `json:"description,omitempty"`
	// **Validation:** label key is alphanumeric with underscore
	Labels               Labels                         `json:"labels,omitempty"`
	ApplicationInput     *ApplicationJSONInput          `json:"applicationInput"`
	Placeholders         []*PlaceholderDefinitionInput  `json:"placeholders,omitempty"`
	AccessLevel          ApplicationTemplateAccessLevel `json:"accessLevel"`
	ApplicationNamespace *string                        `json:"applicationNamespace,omitempty"`
}

type ApplicationTemplatePage struct {
	Data       []*ApplicationTemplate `json:"data"`
	PageInfo   *PageInfo              `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (ApplicationTemplatePage) IsPageable() {}

type ApplicationTemplateUpdateInput struct {
	// **Validation:** ASCII printable characters, max=100
	Name string `json:"name"`
	// **Validation:** max=2000
	Webhooks             []*WebhookInput                `json:"webhooks,omitempty"`
	Description          *string                        `json:"description,omitempty"`
	ApplicationInput     *ApplicationJSONInput          `json:"applicationInput"`
	Placeholders         []*PlaceholderDefinitionInput  `json:"placeholders,omitempty"`
	Labels               Labels                         `json:"labels,omitempty"`
	AccessLevel          ApplicationTemplateAccessLevel `json:"accessLevel"`
	ApplicationNamespace *string                        `json:"applicationNamespace,omitempty"`
}

type ApplicationUpdateInput struct {
	// **Validation:** max=256
	ProviderName *string `json:"providerName,omitempty"`
	// **Validation:** max=2000
	Description *string `json:"description,omitempty"`
	// **Validation:** valid URL, max=256
	HealthCheckURL       *string                     `json:"healthCheckURL,omitempty"`
	BaseURL              *string                     `json:"baseUrl,omitempty"`
	ApplicationNamespace *string                     `json:"applicationNamespace,omitempty"`
	IntegrationSystemID  *string                     `json:"integrationSystemID,omitempty"`
	StatusCondition      *ApplicationStatusCondition `json:"statusCondition,omitempty"`
	LocalTenantID        *string                     `json:"localTenantID,omitempty"`
}

type ApplicationWithTenants struct {
	Application *Application `json:"application,omitempty"`
	Tenants     []*Tenant    `json:"tenants,omitempty"`
}

type ApplicationWithTenantsPage struct {
	Data       []*ApplicationWithTenants `json:"data"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (ApplicationWithTenantsPage) IsPageable() {}

type AspectAPIDefinitionInput struct {
	OrdID string `json:"ordId"`
}

type AspectEventDefinitionInput struct {
	OrdID  string                              `json:"ordId"`
	Subset []*AspectEventDefinitionSubsetInput `json:"subset,omitempty"`
}

type AspectEventDefinitionSubsetInput struct {
	EventType *string `json:"eventType,omitempty"`
}

type AspectInput struct {
	Name           string                        `json:"name"`
	Description    *string                       `json:"description,omitempty"`
	Mandatory      *bool                         `json:"mandatory,omitempty"`
	APIResources   []*AspectAPIDefinitionInput   `json:"apiResources,omitempty"`
	EventResources []*AspectEventDefinitionInput `json:"eventResources,omitempty"`
}

type Auth struct {
	Credential                      CredentialData         `json:"credential,omitempty"`
	AccessStrategy                  *string                `json:"accessStrategy,omitempty"`
	AdditionalHeaders               HTTPHeaders            `json:"additionalHeaders,omitempty"`
	AdditionalHeadersSerialized     *HTTPHeadersSerialized `json:"additionalHeadersSerialized,omitempty"`
	AdditionalQueryParams           QueryParams            `json:"additionalQueryParams,omitempty"`
	AdditionalQueryParamsSerialized *QueryParamsSerialized `json:"additionalQueryParamsSerialized,omitempty"`
	RequestAuth                     *CredentialRequestAuth `json:"requestAuth,omitempty"`
	OneTimeToken                    OneTimeToken           `json:"oneTimeToken,omitempty"`
	CertCommonName                  *string                `json:"certCommonName,omitempty"`
}

type AuthInput struct {
	Credential     *CredentialDataInput `json:"credential,omitempty"`
	AccessStrategy *string              `json:"accessStrategy,omitempty"`
	// **Validation:** if provided, headers name and value required
	AdditionalHeaders           HTTPHeaders            `json:"additionalHeaders,omitempty"`
	AdditionalHeadersSerialized *HTTPHeadersSerialized `json:"additionalHeadersSerialized,omitempty"`
	// **Validation:** if provided, query parameters name and value required
	AdditionalQueryParams           QueryParams                 `json:"additionalQueryParams,omitempty"`
	AdditionalQueryParamsSerialized *QueryParamsSerialized      `json:"additionalQueryParamsSerialized,omitempty"`
	RequestAuth                     *CredentialRequestAuthInput `json:"requestAuth,omitempty"`
	CertCommonName                  *string                     `json:"certCommonName,omitempty"`
	OneTimeToken                    *OneTimeTokenInput          `json:"oneTimeToken,omitempty"`
}

type AutomaticScenarioAssignment struct {
	ScenarioName string `json:"scenarioName"`
	Selector     *Label `json:"selector"`
}

type AutomaticScenarioAssignmentPage struct {
	Data       []*AutomaticScenarioAssignment `json:"data"`
	PageInfo   *PageInfo                      `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (AutomaticScenarioAssignmentPage) IsPageable() {}

type BasicCredentialData struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (BasicCredentialData) IsCredentialData() {}

type BasicCredentialDataInput struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type BundleCreateInput struct {
	// **Validation:** ASCII printable characters, max=100
	Name string `json:"name"`
	// **Validation:** max=2000
	Description                    *string                 `json:"description,omitempty"`
	InstanceAuthRequestInputSchema *JSONSchema             `json:"instanceAuthRequestInputSchema,omitempty"`
	DefaultInstanceAuth            *AuthInput              `json:"defaultInstanceAuth,omitempty"`
	APIDefinitions                 []*APIDefinitionInput   `json:"apiDefinitions,omitempty"`
	EventDefinitions               []*EventDefinitionInput `json:"eventDefinitions,omitempty"`
	Documents                      []*DocumentInput        `json:"documents,omitempty"`
	CorrelationIDs                 []string                `json:"correlationIDs,omitempty"`
}

type BundleInstanceAuth struct {
	ID string `json:"id"`
	// Context of BundleInstanceAuth - such as Runtime ID, namespace
	Context *JSON `json:"context,omitempty"`
	// User input while requesting Bundle Instance Auth
	InputParams *JSON `json:"inputParams,omitempty"`
	// It may be empty if status is PENDING.
	// Populated with `bundle.defaultAuth` value if `bundle.defaultAuth` is defined. If not, Compass notifies Application/Integration System about the Auth request.
	Auth             *Auth                     `json:"auth,omitempty"`
	Status           *BundleInstanceAuthStatus `json:"status"`
	RuntimeID        *string                   `json:"runtimeID,omitempty"`
	RuntimeContextID *string                   `json:"runtimeContextID,omitempty"`
}

type BundleInstanceAuthCreateInput struct {
	Context          *JSON      `json:"context,omitempty"`
	InputParams      *JSON      `json:"inputParams,omitempty"`
	Auth             *AuthInput `json:"auth"`
	RuntimeID        *string    `json:"runtimeID,omitempty"`
	RuntimeContextID *string    `json:"runtimeContextID,omitempty"`
}

type BundleInstanceAuthRequestInput struct {
	ID *string `json:"id,omitempty"`
	// Context of BundleInstanceAuth - such as Runtime ID, namespace, etc.
	Context *JSON `json:"context,omitempty"`
	// **Validation:** JSON validated against bundle.instanceAuthRequestInputSchema
	InputParams *JSON `json:"inputParams,omitempty"`
}

type BundleInstanceAuthSetInput struct {
	// **Validation:** If not provided, the status has to be set. If provided, the status condition  must be "SUCCEEDED".
	Auth *AuthInput `json:"auth,omitempty"`
	// **Validation:** Optional if the auth is provided.
	// If the status condition is "FAILED", auth must be empty.
	Status *BundleInstanceAuthStatusInput `json:"status,omitempty"`
}

type BundleInstanceAuthStatus struct {
	Condition BundleInstanceAuthStatusCondition `json:"condition"`
	Timestamp Timestamp                         `json:"timestamp"`
	Message   string                            `json:"message"`
	// Possible reasons:
	// - PendingNotification
	// - NotificationSent
	// - CredentialsProvided
	// - CredentialsNotProvided
	// - PendingDeletion
	Reason string `json:"reason"`
}

type BundleInstanceAuthStatusInput struct {
	Condition BundleInstanceAuthSetStatusConditionInput `json:"condition"`
	// **Validation:** required, if condition is FAILED
	Message string `json:"message"`
	// Example reasons:
	// - PendingNotification
	// - NotificationSent
	// - CredentialsProvided
	// - CredentialsNotProvided
	// - PendingDeletion
	//
	// **Validation**: required, if condition is FAILED
	Reason string `json:"reason"`
}

type BundleInstanceAuthUpdateInput struct {
	Context     *JSON      `json:"context,omitempty"`
	InputParams *JSON      `json:"inputParams,omitempty"`
	Auth        *AuthInput `json:"auth,omitempty"`
}

type BundlePage struct {
	Data       []*Bundle `json:"data"`
	PageInfo   *PageInfo `json:"pageInfo"`
	TotalCount int       `json:"totalCount"`
}

func (BundlePage) IsPageable() {}

type BundleUpdateInput struct {
	// **Validation:** ASCII printable characters, max=100
	Name string `json:"name"`
	// **Validation:** max=2000
	Description                    *string     `json:"description,omitempty"`
	InstanceAuthRequestInputSchema *JSONSchema `json:"instanceAuthRequestInputSchema,omitempty"`
	// While updating defaultInstanceAuth, existing BundleInstanceAuths are NOT updated.
	DefaultInstanceAuth *AuthInput `json:"defaultInstanceAuth,omitempty"`
}

type BusinessTenantMappingInput struct {
	Name           string    `json:"name"`
	ExternalTenant string    `json:"externalTenant"`
	Parents        []*string `json:"parents,omitempty"`
	Subdomain      *string   `json:"subdomain,omitempty"`
	Region         *string   `json:"region,omitempty"`
	Type           string    `json:"type"`
	Provider       string    `json:"provider"`
	LicenseType    *string   `json:"licenseType,omitempty"`
	CustomerID     *string   `json:"customerId,omitempty"`
	CostObjectID   *string   `json:"costObjectId,omitempty"`
	CostObjectType *string   `json:"costObjectType,omitempty"`
}

type CSRFTokenCredentialRequestAuth struct {
	TokenEndpointURL                string                 `json:"tokenEndpointURL"`
	Credential                      CredentialData         `json:"credential,omitempty"`
	AdditionalHeaders               HTTPHeaders            `json:"additionalHeaders,omitempty"`
	AdditionalHeadersSerialized     *HTTPHeadersSerialized `json:"additionalHeadersSerialized,omitempty"`
	AdditionalQueryParams           QueryParams            `json:"additionalQueryParams,omitempty"`
	AdditionalQueryParamsSerialized *QueryParamsSerialized `json:"additionalQueryParamsSerialized,omitempty"`
}

type CSRFTokenCredentialRequestAuthInput struct {
	// **Validation:** valid URL
	TokenEndpointURL string               `json:"tokenEndpointURL"`
	Credential       *CredentialDataInput `json:"credential,omitempty"`
	// **Validation:** if provided, headers name and value required
	AdditionalHeaders           HTTPHeaders            `json:"additionalHeaders,omitempty"`
	AdditionalHeadersSerialized *HTTPHeadersSerialized `json:"additionalHeadersSerialized,omitempty"`
	// **Validation:** if provided, query parameters name and value required
	AdditionalQueryParams           QueryParams            `json:"additionalQueryParams,omitempty"`
	AdditionalQueryParamsSerialized *QueryParamsSerialized `json:"additionalQueryParamsSerialized,omitempty"`
}

type CertificateOAuthCredentialData struct {
	ClientID    string `json:"clientId"`
	Certificate string `json:"certificate"`
	URL         string `json:"url"`
}

func (CertificateOAuthCredentialData) IsCredentialData() {}

type CertificateOAuthCredentialDataInput struct {
	ClientID    string `json:"clientId"`
	Certificate string `json:"certificate"`
	// **Validation:** valid URL
	URL string `json:"url"`
}

type CertificateSubjectMapping struct {
	ID                 string   `json:"id"`
	Subject            string   `json:"subject"`
	ConsumerType       string   `json:"consumerType"`
	InternalConsumerID *string  `json:"internalConsumerID,omitempty"`
	TenantAccessLevels []string `json:"tenantAccessLevels"`
}

type CertificateSubjectMappingInput struct {
	Subject            string   `json:"subject"`
	ConsumerType       string   `json:"consumerType"`
	InternalConsumerID *string  `json:"internalConsumerID,omitempty"`
	TenantAccessLevels []string `json:"tenantAccessLevels"`
}

type CertificateSubjectMappingPage struct {
	Data       []*CertificateSubjectMapping `json:"data"`
	PageInfo   *PageInfo                    `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (CertificateSubjectMappingPage) IsPageable() {}

type ConstraintReference struct {
	ConstraintID        string `json:"constraintID"`
	FormationTemplateID string `json:"formationTemplateID"`
}

// **Validation:** basic or oauth or certificateOAuth field required
type CredentialDataInput struct {
	Basic            *BasicCredentialDataInput            `json:"basic,omitempty"`
	Oauth            *OAuthCredentialDataInput            `json:"oauth,omitempty"`
	CertificateOAuth *CertificateOAuthCredentialDataInput `json:"certificateOAuth,omitempty"`
}

type CredentialRequestAuth struct {
	Csrf *CSRFTokenCredentialRequestAuth `json:"csrf,omitempty"`
}

type CredentialRequestAuthInput struct {
	// **Validation:** required
	Csrf *CSRFTokenCredentialRequestAuthInput `json:"csrf,omitempty"`
}

type DocumentInput struct {
	// **Validation:** max=128
	Title string `json:"title"`
	// **Validation:** max=128
	DisplayName string `json:"displayName"`
	// **Validation:** max=2000
	Description string         `json:"description"`
	Format      DocumentFormat `json:"format"`
	// **Validation:** max=256
	Kind         *string            `json:"kind,omitempty"`
	Data         *CLOB              `json:"data,omitempty"`
	FetchRequest *FetchRequestInput `json:"fetchRequest,omitempty"`
}

type DocumentPage struct {
	Data       []*Document `json:"data"`
	PageInfo   *PageInfo   `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (DocumentPage) IsPageable() {}

type EventDefinitionInput struct {
	// **Validation:** ASCII printable characters, max=100
	Name string `json:"name"`
	// **Validation:** max=2000
	Description *string         `json:"description,omitempty"`
	Spec        *EventSpecInput `json:"spec,omitempty"`
	// **Validation:** max=36
	Group   *string       `json:"group,omitempty"`
	Version *VersionInput `json:"version,omitempty"`
}

type EventDefinitionPage struct {
	Data       []*EventDefinition `json:"data"`
	PageInfo   *PageInfo          `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (EventDefinitionPage) IsPageable() {}

// **Validation:**
// - data or fetchRequest required
// - for ASYNC_API type, accepted formats are YAML and JSON
type EventSpecInput struct {
	Data         *CLOB              `json:"data,omitempty"`
	Type         EventSpecType      `json:"type"`
	Format       SpecFormat         `json:"format"`
	FetchRequest *FetchRequestInput `json:"fetchRequest,omitempty"`
}

// Compass performs fetch to validate if request is correct and stores a copy
type FetchRequest struct {
	URL    string              `json:"url"`
	Auth   *Auth               `json:"auth,omitempty"`
	Mode   FetchMode           `json:"mode"`
	Filter *string             `json:"filter,omitempty"`
	Status *FetchRequestStatus `json:"status"`
}

type FetchRequestInput struct {
	// **Validation:** valid URL, max=256
	URL string `json:"url"`
	// Currently unsupported, providing it will result in a failure
	Auth *AuthInput `json:"auth,omitempty"`
	// Currently unsupported, providing it will result in a failure
	Mode *FetchMode `json:"mode,omitempty"`
	// **Validation:** max=256
	// Currently unsupported, providing it will result in a failure
	Filter *string `json:"filter,omitempty"`
}

type FetchRequestStatus struct {
	Condition FetchRequestStatusCondition `json:"condition"`
	Message   *string                     `json:"message,omitempty"`
	Timestamp Timestamp                   `json:"timestamp"`
}

type FormationAssignmentPage struct {
	Data       []*FormationAssignment `json:"data"`
	PageInfo   *PageInfo              `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (FormationAssignmentPage) IsPageable() {}

type FormationConstraint struct {
	ID              string    `json:"id"`
	Name            string    `json:"name"`
	Description     string    `json:"description"`
	ConstraintType  string    `json:"constraintType"`
	TargetOperation string    `json:"targetOperation"`
	Operator        string    `json:"operator"`
	ResourceType    string    `json:"resourceType"`
	ResourceSubtype string    `json:"resourceSubtype"`
	InputTemplate   string    `json:"inputTemplate"`
	ConstraintScope string    `json:"constraintScope"`
	Priority        int       `json:"priority"`
	CreatedAt       Timestamp `json:"createdAt"`
}

type FormationConstraintInput struct {
	Name            string          `json:"name"`
	Description     *string         `json:"description,omitempty"`
	ConstraintType  ConstraintType  `json:"constraintType"`
	TargetOperation TargetOperation `json:"targetOperation"`
	Operator        string          `json:"operator"`
	ResourceType    ResourceType    `json:"resourceType"`
	ResourceSubtype string          `json:"resourceSubtype"`
	InputTemplate   string          `json:"inputTemplate"`
	ConstraintScope ConstraintScope `json:"constraintScope"`
	Priority        *int            `json:"priority,omitempty"`
}

type FormationConstraintUpdateInput struct {
	InputTemplate string  `json:"inputTemplate"`
	Priority      *int    `json:"priority,omitempty"`
	Description   *string `json:"description,omitempty"`
}

type FormationError struct {
	Message   string `json:"message"`
	ErrorCode int    `json:"errorCode"`
}

type FormationInput struct {
	Name         string  `json:"name"`
	TemplateName *string `json:"templateName,omitempty"`
	// The initial state of the newly created formation.
	// It is used in specific use-cases by internal components that need to manipulate the formation notification engine's logic and hold the tenant mapping notifications until a certain external event happens.
	State *string `json:"state,omitempty"`
}

type FormationPage struct {
	Data       []*Formation `json:"data"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (FormationPage) IsPageable() {}

type FormationStatus struct {
	Condition FormationStatusCondition `json:"condition"`
	Errors    []*FormationStatusError  `json:"errors,omitempty"`
}

type FormationStatusError struct {
	AssignmentID *string `json:"assignmentID,omitempty"`
	Message      string  `json:"message"`
	ErrorCode    int     `json:"errorCode"`
}

type FormationTemplatePage struct {
	Data       []*FormationTemplate `json:"data"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (FormationTemplatePage) IsPageable() {}

type FormationTemplateRegisterInput struct {
	Name                   string          `json:"name"`
	ApplicationTypes       []string        `json:"applicationTypes"`
	RuntimeTypes           []string        `json:"runtimeTypes,omitempty"`
	RuntimeTypeDisplayName *string         `json:"runtimeTypeDisplayName,omitempty"`
	RuntimeArtifactKind    *ArtifactType   `json:"runtimeArtifactKind,omitempty"`
	Webhooks               []*WebhookInput `json:"webhooks,omitempty"`
	LeadingProductIDs      []string        `json:"leadingProductIDs,omitempty"`
	SupportsReset          *bool           `json:"supportsReset,omitempty"`
	DiscoveryConsumers     []string        `json:"discoveryConsumers,omitempty"`
	Labels                 Labels          `json:"labels,omitempty"`
}

type FormationTemplateUpdateInput struct {
	Name                   string        `json:"name"`
	ApplicationTypes       []string      `json:"applicationTypes"`
	RuntimeTypes           []string      `json:"runtimeTypes,omitempty"`
	RuntimeTypeDisplayName *string       `json:"runtimeTypeDisplayName,omitempty"`
	RuntimeArtifactKind    *ArtifactType `json:"runtimeArtifactKind,omitempty"`
	LeadingProductIDs      []string      `json:"leadingProductIDs,omitempty"`
	SupportsReset          *bool         `json:"supportsReset,omitempty"`
	DiscoveryConsumers     []string      `json:"discoveryConsumers,omitempty"`
}

type HealthCheck struct {
	Type      HealthCheckType            `json:"type"`
	Condition HealthCheckStatusCondition `json:"condition"`
	Origin    *string                    `json:"origin,omitempty"`
	Message   *string                    `json:"message,omitempty"`
	Timestamp Timestamp                  `json:"timestamp"`
}

type HealthCheckPage struct {
	Data       []*HealthCheck `json:"data"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (HealthCheckPage) IsPageable() {}

type IntSysSystemAuth struct {
	ID                string                   `json:"id"`
	Auth              *Auth                    `json:"auth,omitempty"`
	Type              *SystemAuthReferenceType `json:"type,omitempty"`
	TenantID          *string                  `json:"tenantId,omitempty"`
	ReferenceObjectID *string                  `json:"referenceObjectId,omitempty"`
}

func (IntSysSystemAuth) IsSystemAuth() {}

type IntegrationDependencyInput struct {
	Name          string         `json:"name"`
	Description   *string        `json:"description,omitempty"`
	OrdID         string         `json:"ordID"`
	PartOfPackage *string        `json:"partOfPackage,omitempty"`
	Visibility    *string        `json:"visibility,omitempty"`
	ReleaseStatus *string        `json:"releaseStatus,omitempty"`
	Mandatory     *bool          `json:"mandatory,omitempty"`
	Aspects       []*AspectInput `json:"aspects,omitempty"`
	Version       *VersionInput  `json:"version,omitempty"`
	Labels        Labels         `json:"labels,omitempty"`
}

type IntegrationDependencyPage struct {
	Data       []*IntegrationDependency `json:"data"`
	PageInfo   *PageInfo                `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (IntegrationDependencyPage) IsPageable() {}

type IntegrationSystemInput struct {
	// **Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	Name string `json:"name"`
	// **Validation:** max=2000
	Description *string `json:"description,omitempty"`
}

type IntegrationSystemPage struct {
	Data       []*IntegrationSystem `json:"data"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (IntegrationSystemPage) IsPageable() {}

type Label struct {
	Key   string      `json:"key"`
	Value interface{} `json:"value"`
}

type LabelDefinition struct {
	Key    string      `json:"key"`
	Schema *JSONSchema `json:"schema,omitempty"`
}

type LabelDefinitionInput struct {
	// **Validation:** max=256, alphanumeric chartacters and underscore
	Key    string      `json:"key"`
	Schema *JSONSchema `json:"schema,omitempty"`
}

type LabelFilter struct {
	// Label key. If query for the filter is not provided, returns every object with given label key regardless of its value.
	Key string `json:"key"`
	// Optional SQL/JSON Path expression. If query is not provided, returns every object with given label key regardless of its value.
	// Currently only a limited subset of expressions is supported.
	Query *string `json:"query,omitempty"`
}

type LabelInput struct {
	// **Validation:** max=256, alphanumeric chartacters and underscore
	Key   string      `json:"key"`
	Value interface{} `json:"value"`
}

type LabelSelectorInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type Mutation struct {
}

type OAuthCredentialData struct {
	ClientID     string `json:"clientId"`
	ClientSecret string `json:"clientSecret"`
	// URL for getting access token
	URL string `json:"url"`
}

func (OAuthCredentialData) IsCredentialData() {}

type OAuthCredentialDataInput struct {
	ClientID     string `json:"clientId"`
	ClientSecret string `json:"clientSecret"`
	// **Validation:** valid URL
	URL string `json:"url"`
}

type OneTimeTokenInput struct {
	Token        string            `json:"token"`
	ConnectorURL *string           `json:"connectorURL,omitempty"`
	Used         bool              `json:"used"`
	ExpiresAt    Timestamp         `json:"expiresAt"`
	CreatedAt    Timestamp         `json:"createdAt"`
	UsedAt       Timestamp         `json:"usedAt"`
	Raw          *string           `json:"raw,omitempty"`
	RawEncoded   *string           `json:"rawEncoded,omitempty"`
	Type         *OneTimeTokenType `json:"type,omitempty"`
}

type Operation struct {
	ID            string                 `json:"id"`
	OperationType ScheduledOperationType `json:"operationType"`
	Status        OperationStatus        `json:"status"`
	Error         *string                `json:"error,omitempty"`
	CreatedAt     *Timestamp             `json:"createdAt,omitempty"`
	UpdatedAt     *Timestamp             `json:"updatedAt,omitempty"`
}

type PageInfo struct {
	StartCursor PageCursor `json:"startCursor"`
	EndCursor   PageCursor `json:"endCursor"`
	HasNextPage bool       `json:"hasNextPage"`
}

type PlaceholderDefinition struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	JSONPath    *string `json:"jsonPath,omitempty"`
	Optional    *bool   `json:"optional,omitempty"`
}

type PlaceholderDefinitionInput struct {
	// **Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	Name string `json:"name"`
	// **Validation:**  max=2000
	Description *string `json:"description,omitempty"`
	// **Validation:**  max=2000
	JSONPath *string `json:"jsonPath,omitempty"`
	Optional *bool   `json:"optional,omitempty"`
}

type Query struct {
}

type RuntimeContextInput struct {
	// **Validation:** required max=512, alphanumeric chartacters and underscore
	Key   string `json:"key"`
	Value string `json:"value"`
}

type RuntimeContextPage struct {
	Data       []*RuntimeContext `json:"data"`
	PageInfo   *PageInfo         `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (RuntimeContextPage) IsPageable() {}

type RuntimeEventingConfiguration struct {
	DefaultURL string `json:"defaultURL"`
}

type RuntimeMetadata struct {
	CreationTimestamp Timestamp `json:"creationTimestamp"`
}

type RuntimePage struct {
	Data       []*Runtime `json:"data"`
	PageInfo   *PageInfo  `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (RuntimePage) IsPageable() {}

type RuntimeRegisterInput struct {
	// **Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	Name string `json:"name"`
	// **Validation:**  max=2000
	Description *string `json:"description,omitempty"`
	// **Validation:** key: required, alphanumeric with underscore
	Labels               Labels                  `json:"labels,omitempty"`
	Webhooks             []*WebhookInput         `json:"webhooks,omitempty"`
	StatusCondition      *RuntimeStatusCondition `json:"statusCondition,omitempty"`
	ApplicationNamespace *string                 `json:"applicationNamespace,omitempty"`
}

type RuntimeStatus struct {
	Condition RuntimeStatusCondition `json:"condition"`
	Timestamp Timestamp              `json:"timestamp"`
}

type RuntimeSystemAuth struct {
	ID                string                   `json:"id"`
	Auth              *Auth                    `json:"auth,omitempty"`
	Type              *SystemAuthReferenceType `json:"type,omitempty"`
	TenantID          *string                  `json:"tenantId,omitempty"`
	ReferenceObjectID *string                  `json:"referenceObjectId,omitempty"`
}

func (RuntimeSystemAuth) IsSystemAuth() {}

type RuntimeUpdateInput struct {
	// **Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	Name string `json:"name"`
	// **Validation:**  max=2000
	Description *string `json:"description,omitempty"`
	// **Validation:** key: required, alphanumeric with underscore
	Labels               Labels                  `json:"labels,omitempty"`
	StatusCondition      *RuntimeStatusCondition `json:"statusCondition,omitempty"`
	ApplicationNamespace *string                 `json:"applicationNamespace,omitempty"`
}

type SystemAuthUpdateInput struct {
	Auth *AuthInput `json:"auth,omitempty"`
}

type TemplateValueInput struct {
	// **Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	Placeholder string `json:"placeholder"`
	Value       string `json:"value"`
}

type TenantAccess struct {
	TenantID     string                 `json:"tenantID"`
	ResourceType TenantAccessObjectType `json:"resourceType"`
	ResourceID   string                 `json:"resourceID"`
	Owner        bool                   `json:"owner"`
}

type TenantAccessInput struct {
	TenantID     string                 `json:"tenantID"`
	ResourceType TenantAccessObjectType `json:"resourceType"`
	ResourceID   string                 `json:"resourceID"`
	Owner        bool                   `json:"owner"`
}

type TenantPage struct {
	Data       []*Tenant `json:"data"`
	PageInfo   *PageInfo `json:"pageInfo"`
	TotalCount int       `json:"totalCount"`
}

func (TenantPage) IsPageable() {}

type Version struct {
	// for example 4.6
	Value      string `json:"value"`
	Deprecated *bool  `json:"deprecated,omitempty"`
	// for example 4.5
	DeprecatedSince *string `json:"deprecatedSince,omitempty"`
	// if true, will be removed in the next version
	ForRemoval *bool `json:"forRemoval,omitempty"`
}

type VersionInput struct {
	// **Validation:** max=256
	Value      string `json:"value"`
	Deprecated *bool  `json:"deprecated,omitempty"`
	// **Validation:** max=256
	DeprecatedSince *string `json:"deprecatedSince,omitempty"`
	ForRemoval      *bool   `json:"forRemoval,omitempty"`
}

type Viewer struct {
	ID   string     `json:"id"`
	Type ViewerType `json:"type"`
}

type Webhook struct {
	ID                    string       `json:"id"`
	ApplicationID         *string      `json:"applicationID,omitempty"`
	ApplicationTemplateID *string      `json:"applicationTemplateID,omitempty"`
	RuntimeID             *string      `json:"runtimeID,omitempty"`
	IntegrationSystemID   *string      `json:"integrationSystemID,omitempty"`
	FormationTemplateID   *string      `json:"formationTemplateID,omitempty"`
	Type                  WebhookType  `json:"type"`
	Mode                  *WebhookMode `json:"mode,omitempty"`
	CorrelationIDKey      *string      `json:"correlationIdKey,omitempty"`
	RetryInterval         *int         `json:"retryInterval,omitempty"`
	Timeout               *int         `json:"timeout,omitempty"`
	URL                   *string      `json:"url,omitempty"`
	Auth                  *Auth        `json:"auth,omitempty"`
	URLTemplate           *string      `json:"urlTemplate,omitempty"`
	InputTemplate         *string      `json:"inputTemplate,omitempty"`
	HeaderTemplate        *string      `json:"headerTemplate,omitempty"`
	OutputTemplate        *string      `json:"outputTemplate,omitempty"`
	StatusTemplate        *string      `json:"statusTemplate,omitempty"`
	CreatedAt             *Timestamp   `json:"createdAt,omitempty"`
}

type WebhookInput struct {
	Type WebhookType `json:"type"`
	// **Validation:** valid URL, max=256
	URL              *string      `json:"url,omitempty"`
	Auth             *AuthInput   `json:"auth,omitempty"`
	Mode             *WebhookMode `json:"mode,omitempty"`
	Version          *string      `json:"version,omitempty"`
	CorrelationIDKey *string      `json:"correlationIdKey,omitempty"`
	RetryInterval    *int         `json:"retryInterval,omitempty"`
	Timeout          *int         `json:"timeout,omitempty"`
	URLTemplate      *string      `json:"urlTemplate,omitempty"`
	InputTemplate    *string      `json:"inputTemplate,omitempty"`
	HeaderTemplate   *string      `json:"headerTemplate,omitempty"`
	OutputTemplate   *string      `json:"outputTemplate,omitempty"`
	StatusTemplate   *string      `json:"statusTemplate,omitempty"`
}

type APISpecType string

const (
	APISpecTypeOdata   APISpecType = "ODATA"
	APISpecTypeOpenAPI APISpecType = "OPEN_API"
)

var AllAPISpecType = []APISpecType{
	APISpecTypeOdata,
	APISpecTypeOpenAPI,
}

func (e APISpecType) IsValid() bool {
	switch e {
	case APISpecTypeOdata, APISpecTypeOpenAPI:
		return true
	}
	return false
}

func (e APISpecType) String() string {
	return string(e)
}

func (e *APISpecType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APISpecType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid APISpecType", str)
	}
	return nil
}

func (e APISpecType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ApplicationStatusCondition string

const (
	ApplicationStatusConditionInitial         ApplicationStatusCondition = "INITIAL"
	ApplicationStatusConditionConnected       ApplicationStatusCondition = "CONNECTED"
	ApplicationStatusConditionFailed          ApplicationStatusCondition = "FAILED"
	ApplicationStatusConditionCreating        ApplicationStatusCondition = "CREATING"
	ApplicationStatusConditionCreateFailed    ApplicationStatusCondition = "CREATE_FAILED"
	ApplicationStatusConditionCreateSucceeded ApplicationStatusCondition = "CREATE_SUCCEEDED"
	ApplicationStatusConditionUpdating        ApplicationStatusCondition = "UPDATING"
	ApplicationStatusConditionUpdateFailed    ApplicationStatusCondition = "UPDATE_FAILED"
	ApplicationStatusConditionUpdateSucceeded ApplicationStatusCondition = "UPDATE_SUCCEEDED"
	ApplicationStatusConditionDeleting        ApplicationStatusCondition = "DELETING"
	ApplicationStatusConditionDeleteFailed    ApplicationStatusCondition = "DELETE_FAILED"
	ApplicationStatusConditionDeleteSucceeded ApplicationStatusCondition = "DELETE_SUCCEEDED"
	ApplicationStatusConditionUnpairing       ApplicationStatusCondition = "UNPAIRING"
	ApplicationStatusConditionUnpairFailed    ApplicationStatusCondition = "UNPAIR_FAILED"
)

var AllApplicationStatusCondition = []ApplicationStatusCondition{
	ApplicationStatusConditionInitial,
	ApplicationStatusConditionConnected,
	ApplicationStatusConditionFailed,
	ApplicationStatusConditionCreating,
	ApplicationStatusConditionCreateFailed,
	ApplicationStatusConditionCreateSucceeded,
	ApplicationStatusConditionUpdating,
	ApplicationStatusConditionUpdateFailed,
	ApplicationStatusConditionUpdateSucceeded,
	ApplicationStatusConditionDeleting,
	ApplicationStatusConditionDeleteFailed,
	ApplicationStatusConditionDeleteSucceeded,
	ApplicationStatusConditionUnpairing,
	ApplicationStatusConditionUnpairFailed,
}

func (e ApplicationStatusCondition) IsValid() bool {
	switch e {
	case ApplicationStatusConditionInitial, ApplicationStatusConditionConnected, ApplicationStatusConditionFailed, ApplicationStatusConditionCreating, ApplicationStatusConditionCreateFailed, ApplicationStatusConditionCreateSucceeded, ApplicationStatusConditionUpdating, ApplicationStatusConditionUpdateFailed, ApplicationStatusConditionUpdateSucceeded, ApplicationStatusConditionDeleting, ApplicationStatusConditionDeleteFailed, ApplicationStatusConditionDeleteSucceeded, ApplicationStatusConditionUnpairing, ApplicationStatusConditionUnpairFailed:
		return true
	}
	return false
}

func (e ApplicationStatusCondition) String() string {
	return string(e)
}

func (e *ApplicationStatusCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationStatusCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationStatusCondition", str)
	}
	return nil
}

func (e ApplicationStatusCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ApplicationTemplateAccessLevel string

const (
	ApplicationTemplateAccessLevelGlobal ApplicationTemplateAccessLevel = "GLOBAL"
)

var AllApplicationTemplateAccessLevel = []ApplicationTemplateAccessLevel{
	ApplicationTemplateAccessLevelGlobal,
}

func (e ApplicationTemplateAccessLevel) IsValid() bool {
	switch e {
	case ApplicationTemplateAccessLevelGlobal:
		return true
	}
	return false
}

func (e ApplicationTemplateAccessLevel) String() string {
	return string(e)
}

func (e *ApplicationTemplateAccessLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationTemplateAccessLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationTemplateAccessLevel", str)
	}
	return nil
}

func (e ApplicationTemplateAccessLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ArtifactType string

const (
	ArtifactTypeSubscription        ArtifactType = "SUBSCRIPTION"
	ArtifactTypeServiceInstance     ArtifactType = "SERVICE_INSTANCE"
	ArtifactTypeEnvironmentInstance ArtifactType = "ENVIRONMENT_INSTANCE"
)

var AllArtifactType = []ArtifactType{
	ArtifactTypeSubscription,
	ArtifactTypeServiceInstance,
	ArtifactTypeEnvironmentInstance,
}

func (e ArtifactType) IsValid() bool {
	switch e {
	case ArtifactTypeSubscription, ArtifactTypeServiceInstance, ArtifactTypeEnvironmentInstance:
		return true
	}
	return false
}

func (e ArtifactType) String() string {
	return string(e)
}

func (e *ArtifactType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArtifactType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArtifactType", str)
	}
	return nil
}

func (e ArtifactType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BundleInstanceAuthSetStatusConditionInput string

const (
	BundleInstanceAuthSetStatusConditionInputSucceeded BundleInstanceAuthSetStatusConditionInput = "SUCCEEDED"
	BundleInstanceAuthSetStatusConditionInputFailed    BundleInstanceAuthSetStatusConditionInput = "FAILED"
)

var AllBundleInstanceAuthSetStatusConditionInput = []BundleInstanceAuthSetStatusConditionInput{
	BundleInstanceAuthSetStatusConditionInputSucceeded,
	BundleInstanceAuthSetStatusConditionInputFailed,
}

func (e BundleInstanceAuthSetStatusConditionInput) IsValid() bool {
	switch e {
	case BundleInstanceAuthSetStatusConditionInputSucceeded, BundleInstanceAuthSetStatusConditionInputFailed:
		return true
	}
	return false
}

func (e BundleInstanceAuthSetStatusConditionInput) String() string {
	return string(e)
}

func (e *BundleInstanceAuthSetStatusConditionInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BundleInstanceAuthSetStatusConditionInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BundleInstanceAuthSetStatusConditionInput", str)
	}
	return nil
}

func (e BundleInstanceAuthSetStatusConditionInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BundleInstanceAuthStatusCondition string

const (
	// When creating, before Application sets the credentials
	BundleInstanceAuthStatusConditionPending   BundleInstanceAuthStatusCondition = "PENDING"
	BundleInstanceAuthStatusConditionSucceeded BundleInstanceAuthStatusCondition = "SUCCEEDED"
	BundleInstanceAuthStatusConditionFailed    BundleInstanceAuthStatusCondition = "FAILED"
	// When Runtime requests deletion and Application has to revoke the credentials
	BundleInstanceAuthStatusConditionUnused BundleInstanceAuthStatusCondition = "UNUSED"
)

var AllBundleInstanceAuthStatusCondition = []BundleInstanceAuthStatusCondition{
	BundleInstanceAuthStatusConditionPending,
	BundleInstanceAuthStatusConditionSucceeded,
	BundleInstanceAuthStatusConditionFailed,
	BundleInstanceAuthStatusConditionUnused,
}

func (e BundleInstanceAuthStatusCondition) IsValid() bool {
	switch e {
	case BundleInstanceAuthStatusConditionPending, BundleInstanceAuthStatusConditionSucceeded, BundleInstanceAuthStatusConditionFailed, BundleInstanceAuthStatusConditionUnused:
		return true
	}
	return false
}

func (e BundleInstanceAuthStatusCondition) String() string {
	return string(e)
}

func (e *BundleInstanceAuthStatusCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BundleInstanceAuthStatusCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BundleInstanceAuthStatusCondition", str)
	}
	return nil
}

func (e BundleInstanceAuthStatusCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConstraintScope string

const (
	ConstraintScopeGlobal        ConstraintScope = "GLOBAL"
	ConstraintScopeFormationType ConstraintScope = "FORMATION_TYPE"
)

var AllConstraintScope = []ConstraintScope{
	ConstraintScopeGlobal,
	ConstraintScopeFormationType,
}

func (e ConstraintScope) IsValid() bool {
	switch e {
	case ConstraintScopeGlobal, ConstraintScopeFormationType:
		return true
	}
	return false
}

func (e ConstraintScope) String() string {
	return string(e)
}

func (e *ConstraintScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConstraintScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConstraintScope", str)
	}
	return nil
}

func (e ConstraintScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConstraintType string

const (
	ConstraintTypePre  ConstraintType = "PRE"
	ConstraintTypePost ConstraintType = "POST"
	ConstraintTypeUI   ConstraintType = "UI"
)

var AllConstraintType = []ConstraintType{
	ConstraintTypePre,
	ConstraintTypePost,
	ConstraintTypeUI,
}

func (e ConstraintType) IsValid() bool {
	switch e {
	case ConstraintTypePre, ConstraintTypePost, ConstraintTypeUI:
		return true
	}
	return false
}

func (e ConstraintType) String() string {
	return string(e)
}

func (e *ConstraintType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConstraintType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConstraintType", str)
	}
	return nil
}

func (e ConstraintType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DocumentFormat string

const (
	DocumentFormatMarkdown DocumentFormat = "MARKDOWN"
)

var AllDocumentFormat = []DocumentFormat{
	DocumentFormatMarkdown,
}

func (e DocumentFormat) IsValid() bool {
	switch e {
	case DocumentFormatMarkdown:
		return true
	}
	return false
}

func (e DocumentFormat) String() string {
	return string(e)
}

func (e *DocumentFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DocumentFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DocumentFormat", str)
	}
	return nil
}

func (e DocumentFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventSpecType string

const (
	EventSpecTypeAsyncAPI EventSpecType = "ASYNC_API"
)

var AllEventSpecType = []EventSpecType{
	EventSpecTypeAsyncAPI,
}

func (e EventSpecType) IsValid() bool {
	switch e {
	case EventSpecTypeAsyncAPI:
		return true
	}
	return false
}

func (e EventSpecType) String() string {
	return string(e)
}

func (e *EventSpecType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventSpecType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventSpecType", str)
	}
	return nil
}

func (e EventSpecType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventType string

const (
	EventTypeNewApplication     EventType = "NEW_APPLICATION"
	EventTypeNewSingleTenant    EventType = "NEW_SINGLE_TENANT"
	EventTypeNewMultipleTenants EventType = "NEW_MULTIPLE_TENANTS"
)

var AllEventType = []EventType{
	EventTypeNewApplication,
	EventTypeNewSingleTenant,
	EventTypeNewMultipleTenants,
}

func (e EventType) IsValid() bool {
	switch e {
	case EventTypeNewApplication, EventTypeNewSingleTenant, EventTypeNewMultipleTenants:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

func (e *EventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventType", str)
	}
	return nil
}

func (e EventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FetchMode string

const (
	FetchModeSingle FetchMode = "SINGLE"
	FetchModeBundle FetchMode = "BUNDLE"
	FetchModeIndex  FetchMode = "INDEX"
)

var AllFetchMode = []FetchMode{
	FetchModeSingle,
	FetchModeBundle,
	FetchModeIndex,
}

func (e FetchMode) IsValid() bool {
	switch e {
	case FetchModeSingle, FetchModeBundle, FetchModeIndex:
		return true
	}
	return false
}

func (e FetchMode) String() string {
	return string(e)
}

func (e *FetchMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FetchMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FetchMode", str)
	}
	return nil
}

func (e FetchMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FetchRequestStatusCondition string

const (
	FetchRequestStatusConditionInitial   FetchRequestStatusCondition = "INITIAL"
	FetchRequestStatusConditionSucceeded FetchRequestStatusCondition = "SUCCEEDED"
	FetchRequestStatusConditionFailed    FetchRequestStatusCondition = "FAILED"
)

var AllFetchRequestStatusCondition = []FetchRequestStatusCondition{
	FetchRequestStatusConditionInitial,
	FetchRequestStatusConditionSucceeded,
	FetchRequestStatusConditionFailed,
}

func (e FetchRequestStatusCondition) IsValid() bool {
	switch e {
	case FetchRequestStatusConditionInitial, FetchRequestStatusConditionSucceeded, FetchRequestStatusConditionFailed:
		return true
	}
	return false
}

func (e FetchRequestStatusCondition) String() string {
	return string(e)
}

func (e *FetchRequestStatusCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FetchRequestStatusCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FetchRequestStatusCondition", str)
	}
	return nil
}

func (e FetchRequestStatusCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FormationAssignmentType string

const (
	FormationAssignmentTypeApplication    FormationAssignmentType = "APPLICATION"
	FormationAssignmentTypeRuntime        FormationAssignmentType = "RUNTIME"
	FormationAssignmentTypeRuntimeContext FormationAssignmentType = "RUNTIME_CONTEXT"
)

var AllFormationAssignmentType = []FormationAssignmentType{
	FormationAssignmentTypeApplication,
	FormationAssignmentTypeRuntime,
	FormationAssignmentTypeRuntimeContext,
}

func (e FormationAssignmentType) IsValid() bool {
	switch e {
	case FormationAssignmentTypeApplication, FormationAssignmentTypeRuntime, FormationAssignmentTypeRuntimeContext:
		return true
	}
	return false
}

func (e FormationAssignmentType) String() string {
	return string(e)
}

func (e *FormationAssignmentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FormationAssignmentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FormationAssignmentType", str)
	}
	return nil
}

func (e FormationAssignmentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FormationObjectType string

const (
	FormationObjectTypeApplication    FormationObjectType = "APPLICATION"
	FormationObjectTypeTenant         FormationObjectType = "TENANT"
	FormationObjectTypeRuntime        FormationObjectType = "RUNTIME"
	FormationObjectTypeRuntimeContext FormationObjectType = "RUNTIME_CONTEXT"
)

var AllFormationObjectType = []FormationObjectType{
	FormationObjectTypeApplication,
	FormationObjectTypeTenant,
	FormationObjectTypeRuntime,
	FormationObjectTypeRuntimeContext,
}

func (e FormationObjectType) IsValid() bool {
	switch e {
	case FormationObjectTypeApplication, FormationObjectTypeTenant, FormationObjectTypeRuntime, FormationObjectTypeRuntimeContext:
		return true
	}
	return false
}

func (e FormationObjectType) String() string {
	return string(e)
}

func (e *FormationObjectType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FormationObjectType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FormationObjectType", str)
	}
	return nil
}

func (e FormationObjectType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FormationStatusCondition string

const (
	FormationStatusConditionInProgress FormationStatusCondition = "IN_PROGRESS"
	FormationStatusConditionError      FormationStatusCondition = "ERROR"
	FormationStatusConditionReady      FormationStatusCondition = "READY"
	FormationStatusConditionDraft      FormationStatusCondition = "DRAFT"
)

var AllFormationStatusCondition = []FormationStatusCondition{
	FormationStatusConditionInProgress,
	FormationStatusConditionError,
	FormationStatusConditionReady,
	FormationStatusConditionDraft,
}

func (e FormationStatusCondition) IsValid() bool {
	switch e {
	case FormationStatusConditionInProgress, FormationStatusConditionError, FormationStatusConditionReady, FormationStatusConditionDraft:
		return true
	}
	return false
}

func (e FormationStatusCondition) String() string {
	return string(e)
}

func (e *FormationStatusCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FormationStatusCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FormationStatusCondition", str)
	}
	return nil
}

func (e FormationStatusCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HealthCheckStatusCondition string

const (
	HealthCheckStatusConditionSucceeded HealthCheckStatusCondition = "SUCCEEDED"
	HealthCheckStatusConditionFailed    HealthCheckStatusCondition = "FAILED"
)

var AllHealthCheckStatusCondition = []HealthCheckStatusCondition{
	HealthCheckStatusConditionSucceeded,
	HealthCheckStatusConditionFailed,
}

func (e HealthCheckStatusCondition) IsValid() bool {
	switch e {
	case HealthCheckStatusConditionSucceeded, HealthCheckStatusConditionFailed:
		return true
	}
	return false
}

func (e HealthCheckStatusCondition) String() string {
	return string(e)
}

func (e *HealthCheckStatusCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthCheckStatusCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthCheckStatusCondition", str)
	}
	return nil
}

func (e HealthCheckStatusCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HealthCheckType string

const (
	HealthCheckTypeManagementPlaneApplicationHealthcheck HealthCheckType = "MANAGEMENT_PLANE_APPLICATION_HEALTHCHECK"
)

var AllHealthCheckType = []HealthCheckType{
	HealthCheckTypeManagementPlaneApplicationHealthcheck,
}

func (e HealthCheckType) IsValid() bool {
	switch e {
	case HealthCheckTypeManagementPlaneApplicationHealthcheck:
		return true
	}
	return false
}

func (e HealthCheckType) String() string {
	return string(e)
}

func (e *HealthCheckType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthCheckType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthCheckType", str)
	}
	return nil
}

func (e HealthCheckType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OneTimeTokenType string

const (
	OneTimeTokenTypeRuntime     OneTimeTokenType = "Runtime"
	OneTimeTokenTypeApplication OneTimeTokenType = "Application"
)

var AllOneTimeTokenType = []OneTimeTokenType{
	OneTimeTokenTypeRuntime,
	OneTimeTokenTypeApplication,
}

func (e OneTimeTokenType) IsValid() bool {
	switch e {
	case OneTimeTokenTypeRuntime, OneTimeTokenTypeApplication:
		return true
	}
	return false
}

func (e OneTimeTokenType) String() string {
	return string(e)
}

func (e *OneTimeTokenType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OneTimeTokenType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OneTimeTokenType", str)
	}
	return nil
}

func (e OneTimeTokenType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationMode string

const (
	OperationModeSync  OperationMode = "SYNC"
	OperationModeAsync OperationMode = "ASYNC"
)

var AllOperationMode = []OperationMode{
	OperationModeSync,
	OperationModeAsync,
}

func (e OperationMode) IsValid() bool {
	switch e {
	case OperationModeSync, OperationModeAsync:
		return true
	}
	return false
}

func (e OperationMode) String() string {
	return string(e)
}

func (e *OperationMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationMode", str)
	}
	return nil
}

func (e OperationMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationStatus string

const (
	OperationStatusScheduled  OperationStatus = "SCHEDULED"
	OperationStatusInProgress OperationStatus = "IN_PROGRESS"
	OperationStatusCompleted  OperationStatus = "COMPLETED"
	OperationStatusFailed     OperationStatus = "FAILED"
)

var AllOperationStatus = []OperationStatus{
	OperationStatusScheduled,
	OperationStatusInProgress,
	OperationStatusCompleted,
	OperationStatusFailed,
}

func (e OperationStatus) IsValid() bool {
	switch e {
	case OperationStatusScheduled, OperationStatusInProgress, OperationStatusCompleted, OperationStatusFailed:
		return true
	}
	return false
}

func (e OperationStatus) String() string {
	return string(e)
}

func (e *OperationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationStatus", str)
	}
	return nil
}

func (e OperationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationType string

const (
	OperationTypeCreate OperationType = "CREATE"
	OperationTypeUpdate OperationType = "UPDATE"
	OperationTypeDelete OperationType = "DELETE"
)

var AllOperationType = []OperationType{
	OperationTypeCreate,
	OperationTypeUpdate,
	OperationTypeDelete,
}

func (e OperationType) IsValid() bool {
	switch e {
	case OperationTypeCreate, OperationTypeUpdate, OperationTypeDelete:
		return true
	}
	return false
}

func (e OperationType) String() string {
	return string(e)
}

func (e *OperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationType", str)
	}
	return nil
}

func (e OperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ResourceType string

const (
	ResourceTypeApplication    ResourceType = "APPLICATION"
	ResourceTypeRuntime        ResourceType = "RUNTIME"
	ResourceTypeRuntimeContext ResourceType = "RUNTIME_CONTEXT"
	ResourceTypeTenant         ResourceType = "TENANT"
	ResourceTypeFormation      ResourceType = "FORMATION"
)

var AllResourceType = []ResourceType{
	ResourceTypeApplication,
	ResourceTypeRuntime,
	ResourceTypeRuntimeContext,
	ResourceTypeTenant,
	ResourceTypeFormation,
}

func (e ResourceType) IsValid() bool {
	switch e {
	case ResourceTypeApplication, ResourceTypeRuntime, ResourceTypeRuntimeContext, ResourceTypeTenant, ResourceTypeFormation:
		return true
	}
	return false
}

func (e ResourceType) String() string {
	return string(e)
}

func (e *ResourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceType", str)
	}
	return nil
}

func (e ResourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RuntimeStatusCondition string

const (
	RuntimeStatusConditionInitial      RuntimeStatusCondition = "INITIAL"
	RuntimeStatusConditionProvisioning RuntimeStatusCondition = "PROVISIONING"
	RuntimeStatusConditionConnected    RuntimeStatusCondition = "CONNECTED"
	RuntimeStatusConditionFailed       RuntimeStatusCondition = "FAILED"
)

var AllRuntimeStatusCondition = []RuntimeStatusCondition{
	RuntimeStatusConditionInitial,
	RuntimeStatusConditionProvisioning,
	RuntimeStatusConditionConnected,
	RuntimeStatusConditionFailed,
}

func (e RuntimeStatusCondition) IsValid() bool {
	switch e {
	case RuntimeStatusConditionInitial, RuntimeStatusConditionProvisioning, RuntimeStatusConditionConnected, RuntimeStatusConditionFailed:
		return true
	}
	return false
}

func (e RuntimeStatusCondition) String() string {
	return string(e)
}

func (e *RuntimeStatusCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeStatusCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeStatusCondition", str)
	}
	return nil
}

func (e RuntimeStatusCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScheduledOperationType string

const (
	ScheduledOperationTypeOrdAggregation ScheduledOperationType = "ORD_AGGREGATION"
	ScheduledOperationTypeSystemFetching ScheduledOperationType = "SYSTEM_FETCHING"
)

var AllScheduledOperationType = []ScheduledOperationType{
	ScheduledOperationTypeOrdAggregation,
	ScheduledOperationTypeSystemFetching,
}

func (e ScheduledOperationType) IsValid() bool {
	switch e {
	case ScheduledOperationTypeOrdAggregation, ScheduledOperationTypeSystemFetching:
		return true
	}
	return false
}

func (e ScheduledOperationType) String() string {
	return string(e)
}

func (e *ScheduledOperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduledOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduledOperationType", str)
	}
	return nil
}

func (e ScheduledOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SpecFormat string

const (
	SpecFormatYaml SpecFormat = "YAML"
	SpecFormatJSON SpecFormat = "JSON"
	SpecFormatXML  SpecFormat = "XML"
)

var AllSpecFormat = []SpecFormat{
	SpecFormatYaml,
	SpecFormatJSON,
	SpecFormatXML,
}

func (e SpecFormat) IsValid() bool {
	switch e {
	case SpecFormatYaml, SpecFormatJSON, SpecFormatXML:
		return true
	}
	return false
}

func (e SpecFormat) String() string {
	return string(e)
}

func (e *SpecFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SpecFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SpecFormat", str)
	}
	return nil
}

func (e SpecFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SystemAuthReferenceType string

const (
	SystemAuthReferenceTypeApplication       SystemAuthReferenceType = "APPLICATION"
	SystemAuthReferenceTypeRuntime           SystemAuthReferenceType = "RUNTIME"
	SystemAuthReferenceTypeIntegrationSystem SystemAuthReferenceType = "INTEGRATION_SYSTEM"
)

var AllSystemAuthReferenceType = []SystemAuthReferenceType{
	SystemAuthReferenceTypeApplication,
	SystemAuthReferenceTypeRuntime,
	SystemAuthReferenceTypeIntegrationSystem,
}

func (e SystemAuthReferenceType) IsValid() bool {
	switch e {
	case SystemAuthReferenceTypeApplication, SystemAuthReferenceTypeRuntime, SystemAuthReferenceTypeIntegrationSystem:
		return true
	}
	return false
}

func (e SystemAuthReferenceType) String() string {
	return string(e)
}

func (e *SystemAuthReferenceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemAuthReferenceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemAuthReferenceType", str)
	}
	return nil
}

func (e SystemAuthReferenceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetOperation string

const (
	TargetOperationAssignFormation                         TargetOperation = "ASSIGN_FORMATION"
	TargetOperationUnassignFormation                       TargetOperation = "UNASSIGN_FORMATION"
	TargetOperationCreateFormation                         TargetOperation = "CREATE_FORMATION"
	TargetOperationDeleteFormation                         TargetOperation = "DELETE_FORMATION"
	TargetOperationGenerateFormationAssignmentNotification TargetOperation = "GENERATE_FORMATION_ASSIGNMENT_NOTIFICATION"
	TargetOperationGenerateFormationNotification           TargetOperation = "GENERATE_FORMATION_NOTIFICATION"
	TargetOperationLoadFormations                          TargetOperation = "LOAD_FORMATIONS"
	TargetOperationSelectSystemsForFormation               TargetOperation = "SELECT_SYSTEMS_FOR_FORMATION"
	TargetOperationSendNotification                        TargetOperation = "SEND_NOTIFICATION"
	TargetOperationNotificationStatusReturned              TargetOperation = "NOTIFICATION_STATUS_RETURNED"
)

var AllTargetOperation = []TargetOperation{
	TargetOperationAssignFormation,
	TargetOperationUnassignFormation,
	TargetOperationCreateFormation,
	TargetOperationDeleteFormation,
	TargetOperationGenerateFormationAssignmentNotification,
	TargetOperationGenerateFormationNotification,
	TargetOperationLoadFormations,
	TargetOperationSelectSystemsForFormation,
	TargetOperationSendNotification,
	TargetOperationNotificationStatusReturned,
}

func (e TargetOperation) IsValid() bool {
	switch e {
	case TargetOperationAssignFormation, TargetOperationUnassignFormation, TargetOperationCreateFormation, TargetOperationDeleteFormation, TargetOperationGenerateFormationAssignmentNotification, TargetOperationGenerateFormationNotification, TargetOperationLoadFormations, TargetOperationSelectSystemsForFormation, TargetOperationSendNotification, TargetOperationNotificationStatusReturned:
		return true
	}
	return false
}

func (e TargetOperation) String() string {
	return string(e)
}

func (e *TargetOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetOperation", str)
	}
	return nil
}

func (e TargetOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TenantAccessObjectType string

const (
	TenantAccessObjectTypeApplication    TenantAccessObjectType = "APPLICATION"
	TenantAccessObjectTypeRuntime        TenantAccessObjectType = "RUNTIME"
	TenantAccessObjectTypeRuntimeContext TenantAccessObjectType = "RUNTIME_CONTEXT"
)

var AllTenantAccessObjectType = []TenantAccessObjectType{
	TenantAccessObjectTypeApplication,
	TenantAccessObjectTypeRuntime,
	TenantAccessObjectTypeRuntimeContext,
}

func (e TenantAccessObjectType) IsValid() bool {
	switch e {
	case TenantAccessObjectTypeApplication, TenantAccessObjectTypeRuntime, TenantAccessObjectTypeRuntimeContext:
		return true
	}
	return false
}

func (e TenantAccessObjectType) String() string {
	return string(e)
}

func (e *TenantAccessObjectType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TenantAccessObjectType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TenantAccessObjectType", str)
	}
	return nil
}

func (e TenantAccessObjectType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ViewerType string

const (
	ViewerTypeRuntime           ViewerType = "RUNTIME"
	ViewerTypeApplication       ViewerType = "APPLICATION"
	ViewerTypeIntegrationSystem ViewerType = "INTEGRATION_SYSTEM"
	ViewerTypeUser              ViewerType = "USER"
)

var AllViewerType = []ViewerType{
	ViewerTypeRuntime,
	ViewerTypeApplication,
	ViewerTypeIntegrationSystem,
	ViewerTypeUser,
}

func (e ViewerType) IsValid() bool {
	switch e {
	case ViewerTypeRuntime, ViewerTypeApplication, ViewerTypeIntegrationSystem, ViewerTypeUser:
		return true
	}
	return false
}

func (e ViewerType) String() string {
	return string(e)
}

func (e *ViewerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ViewerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ViewerType", str)
	}
	return nil
}

func (e ViewerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookMode string

const (
	WebhookModeSync          WebhookMode = "SYNC"
	WebhookModeAsync         WebhookMode = "ASYNC"
	WebhookModeAsyncCallback WebhookMode = "ASYNC_CALLBACK"
)

var AllWebhookMode = []WebhookMode{
	WebhookModeSync,
	WebhookModeAsync,
	WebhookModeAsyncCallback,
}

func (e WebhookMode) IsValid() bool {
	switch e {
	case WebhookModeSync, WebhookModeAsync, WebhookModeAsyncCallback:
		return true
	}
	return false
}

func (e WebhookMode) String() string {
	return string(e)
}

func (e *WebhookMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookMode", str)
	}
	return nil
}

func (e WebhookMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookType string

const (
	WebhookTypeConfigurationChanged        WebhookType = "CONFIGURATION_CHANGED"
	WebhookTypeApplicationTenantMapping    WebhookType = "APPLICATION_TENANT_MAPPING"
	WebhookTypeRegisterApplication         WebhookType = "REGISTER_APPLICATION"
	WebhookTypeUnregisterApplication       WebhookType = "UNREGISTER_APPLICATION"
	WebhookTypeOpenResourceDiscovery       WebhookType = "OPEN_RESOURCE_DISCOVERY"
	WebhookTypeOpenResourceDiscoveryStatic WebhookType = "OPEN_RESOURCE_DISCOVERY_STATIC"
	WebhookTypeFormationLifecycle          WebhookType = "FORMATION_LIFECYCLE"
	WebhookTypeSystemFieldDiscovery        WebhookType = "SYSTEM_FIELD_DISCOVERY"
)

var AllWebhookType = []WebhookType{
	WebhookTypeConfigurationChanged,
	WebhookTypeApplicationTenantMapping,
	WebhookTypeRegisterApplication,
	WebhookTypeUnregisterApplication,
	WebhookTypeOpenResourceDiscovery,
	WebhookTypeOpenResourceDiscoveryStatic,
	WebhookTypeFormationLifecycle,
	WebhookTypeSystemFieldDiscovery,
}

func (e WebhookType) IsValid() bool {
	switch e {
	case WebhookTypeConfigurationChanged, WebhookTypeApplicationTenantMapping, WebhookTypeRegisterApplication, WebhookTypeUnregisterApplication, WebhookTypeOpenResourceDiscovery, WebhookTypeOpenResourceDiscoveryStatic, WebhookTypeFormationLifecycle, WebhookTypeSystemFieldDiscovery:
		return true
	}
	return false
}

func (e WebhookType) String() string {
	return string(e)
}

func (e *WebhookType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookType", str)
	}
	return nil
}

func (e WebhookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
