"""
Async directive is added to mutations which are capable of being executed in asynchronious matter
"""
directive @async(operationType: OperationType!, webhookType: WebhookType, idField: String) on FIELD_DEFINITION
"""
HasScenario directive is added to queries and mutations to ensure that runtimes can only access resources which are in the same scenario as them
"""
directive @hasScenario(applicationProvider: String!, idField: String!) on FIELD_DEFINITION
"""
HasScopes directive is added automatically to every query and mutation by scopesdecorator plugin that is triggerred by gqlgen.sh script.
"""
directive @hasScopes(path: String!) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
"""
Sanitize directive marks mutation arguments that will be validated.
"""
directive @sanitize(path: String!) on FIELD_DEFINITION
"""
SynchronizeApplications directive is added to mutations that create applications or tenants in other to synchronise the tenant access.
"""
directive @synchronizeApplicationTenancy(eventType: EventType!) on FIELD_DEFINITION
"""
Validate directive marks mutation arguments that will be validated.
"""
directive @validate on ARGUMENT_DEFINITION
scalar Any

scalar CLOB

scalar HttpHeaders

scalar HttpHeadersSerialized

"""
Stringified JSON
"""
scalar JSON

"""
Stringified JSON
"""
scalar JSONSchema

scalar Labels

scalar PageCursor

scalar QueryParams

scalar QueryParamsSerialized

scalar Timestamp

enum APISpecType {
	ODATA
	OPEN_API
}

enum ApplicationStatusCondition {
	INITIAL
	CONNECTED
	FAILED
	CREATING
	CREATE_FAILED
	CREATE_SUCCEEDED
	UPDATING
	UPDATE_FAILED
	UPDATE_SUCCEEDED
	DELETING
	DELETE_FAILED
	DELETE_SUCCEEDED
	UNPAIRING
	UNPAIR_FAILED
}

enum ApplicationTemplateAccessLevel {
	GLOBAL
}

enum ArtifactType {
	SUBSCRIPTION
	SERVICE_INSTANCE
	ENVIRONMENT_INSTANCE
}

enum BundleInstanceAuthSetStatusConditionInput {
	SUCCEEDED
	FAILED
}

enum BundleInstanceAuthStatusCondition {
	"""
	When creating, before Application sets the credentials
	"""
	PENDING
	SUCCEEDED
	FAILED
	"""
	When Runtime requests deletion and Application has to revoke the credentials
	"""
	UNUSED
}

enum ConstraintScope {
	GLOBAL
	FORMATION_TYPE
}

enum ConstraintType {
	PRE
	POST
	UI
}

enum DocumentFormat {
	MARKDOWN
}

enum EventSpecType {
	ASYNC_API
}

enum EventType {
	NEW_APPLICATION
	NEW_SINGLE_TENANT
	NEW_MULTIPLE_TENANTS
}

enum FetchMode {
	SINGLE
	BUNDLE
	INDEX
}

enum FetchRequestStatusCondition {
	INITIAL
	SUCCEEDED
	FAILED
}

enum FormationAssignmentType {
	APPLICATION
	RUNTIME
	RUNTIME_CONTEXT
}

enum FormationObjectType {
	APPLICATION
	TENANT
	RUNTIME
	RUNTIME_CONTEXT
}

enum FormationStatusCondition {
	IN_PROGRESS
	ERROR
	READY
}

enum HealthCheckStatusCondition {
	SUCCEEDED
	FAILED
}

enum HealthCheckType {
	MANAGEMENT_PLANE_APPLICATION_HEALTHCHECK
}

enum OneTimeTokenType {
	Runtime
	Application
}

enum OperationMode {
	SYNC
	ASYNC
}

enum OperationType {
	CREATE
	UPDATE
	DELETE
}

enum ResourceType {
	APPLICATION
	RUNTIME
	RUNTIME_CONTEXT
	TENANT
	FORMATION
}

enum RuntimeStatusCondition {
	INITIAL
	PROVISIONING
	CONNECTED
	FAILED
}

enum SpecFormat {
	YAML
	JSON
	XML
}

enum SystemAuthReferenceType {
	APPLICATION
	RUNTIME
	INTEGRATION_SYSTEM
}

enum TargetOperation {
	ASSIGN_FORMATION
	UNASSIGN_FORMATION
	CREATE_FORMATION
	DELETE_FORMATION
	GENERATE_FORMATION_ASSIGNMENT_NOTIFICATION
	GENERATE_FORMATION_NOTIFICATION
	LOAD_FORMATIONS
	SELECT_SYSTEMS_FOR_FORMATION
	SEND_NOTIFICATION
	NOTIFICATION_STATUS_RETURNED
}

enum TenantAccessObjectType {
	APPLICATION
	RUNTIME
	RUNTIME_CONTEXT
}

enum ViewerType {
	RUNTIME
	APPLICATION
	INTEGRATION_SYSTEM
	USER
}

enum WebhookMode {
	SYNC
	ASYNC
	ASYNC_CALLBACK
}

enum WebhookType {
	CONFIGURATION_CHANGED
	APPLICATION_TENANT_MAPPING
	REGISTER_APPLICATION
	UNREGISTER_APPLICATION
	OPEN_RESOURCE_DISCOVERY
	FORMATION_LIFECYCLE
}

interface OneTimeToken {
	token: String!
	connectorURL: String!
	used: Boolean!
	expiresAt: Timestamp!
	createdAt: Timestamp
	usedAt: Timestamp
	raw: String
	rawEncoded: String
	type: OneTimeTokenType
}

"""
Every query that implements pagination returns object that implements Pageable interface.
To specify page details, query specify two parameters: `first` and `after`.
`first` specify page size, `after` is a cursor for the next page. When requesting first page, set `after` to empty value.
For requesting next page, set `after` to `pageInfo.endCursor` returned from previous query.
"""
interface Pageable {
	pageInfo: PageInfo!
	totalCount: Int!
}

interface SystemAuth {
	id: ID!
	auth: Auth
	type: SystemAuthReferenceType
	tenantId: String
	referenceObjectId: ID
}

union CredentialData = BasicCredentialData | OAuthCredentialData | CertificateOAuthCredentialData

input APIDefinitionInput {
	"""
	**Validation:** ASCII printable characters, max=100
	"""
	name: String!
	"""
	**Validation:** max=2000
	"""
	description: String
	"""
	**Validation:** valid URL, max=256
	"""
	targetURL: String!
	"""
	**Validation:** max=100
	"""
	group: String
	spec: APISpecInput
	version: VersionInput
}

"""
**Validation:**
- for ODATA type, accepted formats are XML and JSON, for OPEN_API accepted formats are YAML and JSON
- data or fetchRequest required
"""
input APISpecInput {
	data: CLOB
	type: APISpecType!
	format: SpecFormat!
	fetchRequest: FetchRequestInput
}

"""
**Validation:** provided placeholders' names are unique
"""
input ApplicationFromTemplateInput {
	id: ID
	"""
	**Validation:** ASCII printable characters, max=100
	"""
	templateName: String!
	"""
	**Validation:** if provided, placeholdersPayload not required
	"""
	values: [TemplateValueInput]
	"""
	**Validation:** if provided, values not required
	"""
	placeholdersPayload: String
	labels: Labels
}

input ApplicationJSONInput {
	"""
	**Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	"""
	name: String!
	"""
	**Validation:** max=256
	"""
	providerName: String
	"""
	**Validation:** max=2000
	"""
	description: String
	"""
	**Validation:** label key is alphanumeric with underscore
	"""
	labels: Labels
	webhooks: [WebhookInput!]
	"""
	**Validation:** valid URL, max=256
	"""
	healthCheckURL: String
	"""
	**Validation:** valid URL, max=256
	"""
	baseUrl: String
	applicationNamespace: String
	integrationSystemID: ID
	statusCondition: ApplicationStatusCondition
	localTenantID: String
	bundles: [BundleCreateInput!]
}

input ApplicationRegisterInput {
	"""
	**Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	"""
	name: String!
	"""
	**Validation:** max=256
	"""
	providerName: String
	"""
	**Validation:** max=2000
	"""
	description: String
	"""
	**Validation:** label key is alphanumeric with underscore
	"""
	labels: Labels
	webhooks: [WebhookInput!]
	"""
	**Validation:** valid URL, max=256
	"""
	healthCheckURL: String
	"""
	**Validation:** valid URL, max=256
	"""
	baseUrl: String
	applicationNamespace: String
	integrationSystemID: ID
	statusCondition: ApplicationStatusCondition
	localTenantID: String @hasScopes(path: "graphql.input.application.localTenantID")
	bundles: [BundleCreateInput!]
}

"""
**Validation:** provided placeholders' names are unique and used in applicationInput
"""
input ApplicationTemplateInput {
	"""
	**Validation:** ASCII printable characters, max=100
	"""
	name: String!
	"""
	**Validation:** max=2000
	"""
	webhooks: [WebhookInput!]
	description: String
	"""
	**Validation:** label key is alphanumeric with underscore
	"""
	labels: Labels
	applicationInput: ApplicationJSONInput!
	placeholders: [PlaceholderDefinitionInput!]
	accessLevel: ApplicationTemplateAccessLevel!
	applicationNamespace: String
}

input ApplicationTemplateUpdateInput {
	"""
	**Validation:** ASCII printable characters, max=100
	"""
	name: String!
	"""
	**Validation:** max=2000
	"""
	webhooks: [WebhookInput!]
	description: String
	applicationInput: ApplicationJSONInput!
	placeholders: [PlaceholderDefinitionInput!]
	labels: Labels @hasScopes(path: "graphql.input.application_template.labels")
	accessLevel: ApplicationTemplateAccessLevel!
	applicationNamespace: String
}

input ApplicationUpdateInput {
	"""
	**Validation:** max=256
	"""
	providerName: String
	"""
	**Validation:** max=2000
	"""
	description: String
	"""
	**Validation:** valid URL, max=256
	"""
	healthCheckURL: String
	baseUrl: String
	applicationNamespace: String
	integrationSystemID: ID
	statusCondition: ApplicationStatusCondition
	localTenantID: String @hasScopes(path: "graphql.input.application.localTenantID")
}

input AuthInput {
	credential: CredentialDataInput
	accessStrategy: String
	"""
	**Validation:** if provided, headers name and value required
	"""
	additionalHeaders: HttpHeaders @deprecated(reason: "Use `additionalHeadersSerialized`.")
	additionalHeadersSerialized: HttpHeadersSerialized
	"""
	**Validation:** if provided, query parameters name and value required
	"""
	additionalQueryParams: QueryParams @deprecated(reason: "Use `additionalHeadersSerialized`.")
	additionalQueryParamsSerialized: QueryParamsSerialized
	requestAuth: CredentialRequestAuthInput
	certCommonName: String
	oneTimeToken: OneTimeTokenInput
}

input BasicCredentialDataInput {
	username: String!
	password: String!
}

input BundleCreateInput {
	"""
	**Validation:** ASCII printable characters, max=100
	"""
	name: String!
	"""
	**Validation:** max=2000
	"""
	description: String
	instanceAuthRequestInputSchema: JSONSchema
	defaultInstanceAuth: AuthInput
	apiDefinitions: [APIDefinitionInput!]
	eventDefinitions: [EventDefinitionInput!]
	documents: [DocumentInput!]
	correlationIDs: [String!]
}

input BundleInstanceAuthCreateInput {
	context: JSON
	inputParams: JSON
	auth: AuthInput!
	runtimeID: ID
	runtimeContextID: ID
}

input BundleInstanceAuthRequestInput {
	id: ID
	"""
	Context of BundleInstanceAuth - such as Runtime ID, namespace, etc.
	"""
	context: JSON
	"""
	**Validation:** JSON validated against bundle.instanceAuthRequestInputSchema
	"""
	inputParams: JSON
}

input BundleInstanceAuthSetInput {
	"""
	**Validation:** If not provided, the status has to be set. If provided, the status condition  must be "SUCCEEDED".
	"""
	auth: AuthInput
	"""
	**Validation:** Optional if the auth is provided.
	If the status condition is "FAILED", auth must be empty.
	"""
	status: BundleInstanceAuthStatusInput
}

input BundleInstanceAuthStatusInput {
	condition: BundleInstanceAuthSetStatusConditionInput! = SUCCEEDED
	"""
	**Validation:** required, if condition is FAILED
	"""
	message: String!
	"""
	Example reasons:
	- PendingNotification
	- NotificationSent
	- CredentialsProvided
	- CredentialsNotProvided
	- PendingDeletion
	
	**Validation**: required, if condition is FAILED
	"""
	reason: String!
}

input BundleInstanceAuthUpdateInput {
	context: JSON
	inputParams: JSON
	auth: AuthInput
}

input BundleUpdateInput {
	"""
	**Validation:** ASCII printable characters, max=100
	"""
	name: String!
	"""
	**Validation:** max=2000
	"""
	description: String
	instanceAuthRequestInputSchema: JSONSchema
	"""
	While updating defaultInstanceAuth, existing BundleInstanceAuths are NOT updated.
	"""
	defaultInstanceAuth: AuthInput
}

input BusinessTenantMappingInput {
	name: String!
	externalTenant: String!
	parent: String
	subdomain: String
	region: String
	type: String!
	provider: String!
	licenseType: String
}

input CSRFTokenCredentialRequestAuthInput {
	"""
	**Validation:** valid URL
	"""
	tokenEndpointURL: String!
	credential: CredentialDataInput
	"""
	**Validation:** if provided, headers name and value required
	"""
	additionalHeaders: HttpHeaders @deprecated(reason: "Use `additionalHeadersSerialized`.")
	additionalHeadersSerialized: HttpHeadersSerialized
	"""
	**Validation:** if provided, query parameters name and value required
	"""
	additionalQueryParams: QueryParams @deprecated(reason: "Use `additionalQueryParamsSerialized`.")
	additionalQueryParamsSerialized: QueryParamsSerialized
}

input CertificateOAuthCredentialDataInput {
	clientId: ID!
	certificate: String!
	"""
	**Validation:** valid URL
	"""
	url: String!
}

input CertificateSubjectMappingInput {
	subject: String!
	consumerType: String!
	internalConsumerID: String
	tenantAccessLevels: [String!]!
}

"""
**Validation:** basic or oauth or certificateOAuth field required
"""
input CredentialDataInput {
	basic: BasicCredentialDataInput
	oauth: OAuthCredentialDataInput
	certificateOAuth: CertificateOAuthCredentialDataInput
}

input CredentialRequestAuthInput {
	"""
	**Validation:** required
	"""
	csrf: CSRFTokenCredentialRequestAuthInput
}

input DocumentInput {
	"""
	**Validation:** max=128
	"""
	title: String!
	"""
	**Validation:** max=128
	"""
	displayName: String!
	"""
	**Validation:** max=2000
	"""
	description: String!
	format: DocumentFormat!
	"""
	**Validation:** max=256
	"""
	kind: String
	data: CLOB
	fetchRequest: FetchRequestInput
}

input EventDefinitionInput {
	"""
	**Validation:** ASCII printable characters, max=100
	"""
	name: String!
	"""
	**Validation:** max=2000
	"""
	description: String
	spec: EventSpecInput
	"""
	**Validation:** max=36
	"""
	group: String
	version: VersionInput
}

"""
**Validation:**
- data or fetchRequest required
- for ASYNC_API type, accepted formats are YAML and JSON
"""
input EventSpecInput {
	data: CLOB
	type: EventSpecType!
	format: SpecFormat!
	fetchRequest: FetchRequestInput
}

input FetchRequestInput {
	"""
	**Validation:** valid URL, max=256
	"""
	url: String!
	"""
	Currently unsupported, providing it will result in a failure
	"""
	auth: AuthInput
	"""
	Currently unsupported, providing it will result in a failure
	"""
	mode: FetchMode = SINGLE
	"""
	**Validation:** max=256
	Currently unsupported, providing it will result in a failure
	"""
	filter: String
}

input FormationConstraintInput {
	name: String!
	constraintType: ConstraintType!
	targetOperation: TargetOperation!
	operator: String!
	resourceType: ResourceType!
	resourceSubtype: String!
	inputTemplate: String!
	constraintScope: ConstraintScope!
}

input FormationConstraintUpdateInput {
	inputTemplate: String!
}

input FormationInput {
	name: String!
	templateName: String
	"""
	The initial state of the newly created formation.
	It is used in specific use-cases by internal components that need to manipulate the formation notification engine's logic and hold the tenant mapping notifications until a certain external event happens.
	"""
	state: String @hasScopes(path: "graphql.input.formation.state")
}

input FormationTemplateInput {
	name: String!
	applicationTypes: [String!]!
	runtimeTypes: [String!]
	runtimeTypeDisplayName: String
	runtimeArtifactKind: ArtifactType
	webhooks: [WebhookInput!]
	leadingProductIDs: [String!]
}

input IntegrationSystemInput {
	"""
	**Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	"""
	name: String!
	"""
	**Validation:** max=2000
	"""
	description: String
}

input LabelDefinitionInput {
	"""
	**Validation:** max=256, alphanumeric chartacters and underscore
	"""
	key: String!
	schema: JSONSchema
}

input LabelFilter {
	"""
	Label key. If query for the filter is not provided, returns every object with given label key regardless of its value.
	"""
	key: String!
	"""
	Optional SQL/JSON Path expression. If query is not provided, returns every object with given label key regardless of its value.
	Currently only a limited subset of expressions is supported.
	"""
	query: String
}

input LabelInput {
	"""
	**Validation:** max=256, alphanumeric chartacters and underscore
	"""
	key: String!
	value: Any!
}

input LabelSelectorInput {
	key: String!
	value: String!
}

input OAuthCredentialDataInput {
	clientId: ID!
	clientSecret: String!
	"""
	**Validation:** valid URL
	"""
	url: String!
}

input OneTimeTokenInput {
	token: String!
	connectorURL: String
	used: Boolean!
	expiresAt: Timestamp!
	createdAt: Timestamp!
	usedAt: Timestamp!
	raw: String
	rawEncoded: String
	type: OneTimeTokenType
}

input PlaceholderDefinitionInput {
	"""
	**Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	"""
	name: String!
	"""
	**Validation:**  max=2000
	"""
	description: String
	"""
	**Validation:**  max=2000
	"""
	jsonPath: String
	optional: Boolean = false
}

input RuntimeContextInput {
	"""
	**Validation:** required max=512, alphanumeric chartacters and underscore
	"""
	key: String!
	value: String!
}

input RuntimeRegisterInput {
	"""
	**Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	"""
	name: String!
	"""
	**Validation:**  max=2000
	"""
	description: String
	"""
	**Validation:** key: required, alphanumeric with underscore
	"""
	labels: Labels
	webhooks: [WebhookInput!]
	statusCondition: RuntimeStatusCondition
	applicationNamespace: String
}

input RuntimeUpdateInput {
	"""
	**Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	"""
	name: String!
	"""
	**Validation:**  max=2000
	"""
	description: String
	"""
	**Validation:** key: required, alphanumeric with underscore
	"""
	labels: Labels
	statusCondition: RuntimeStatusCondition
	applicationNamespace: String
}

input SystemAuthUpdateInput {
	auth: AuthInput
}

input TemplateValueInput {
	"""
	**Validation:**  Up to 36 characters long. Cannot start with a digit. The characters allowed in names are: digits (0-9), lower case letters (a-z),-, and .
	"""
	placeholder: String!
	value: String!
}

input TenantAccessInput {
	tenantID: ID!
	resourceType: TenantAccessObjectType!
	resourceID: ID!
	owner: Boolean!
}

input VersionInput {
	"""
	**Validation:** max=256
	"""
	value: String!
	deprecated: Boolean = false
	"""
	**Validation:** max=256
	"""
	deprecatedSince: String
	forRemoval: Boolean = false
}

input WebhookInput {
	type: WebhookType!
	"""
	**Validation:** valid URL, max=256
	"""
	url: String
	auth: AuthInput
	mode: WebhookMode
	version: String
	correlationIdKey: String
	retryInterval: Int
	timeout: Int
	urlTemplate: String
	inputTemplate: String
	headerTemplate: String
	outputTemplate: String
	statusTemplate: String
}

type APIDefinition {
	id: ID!
	name: String!
	description: String
	spec: APISpec
	targetURL: String!
	"""
	group allows you to find the same API but in different version
	"""
	group: String
	version: Version
	created_at: Timestamp
	updated_at: Timestamp
	deleted_at: Timestamp
	error: String
}

type APIDefinitionPage implements Pageable {
	data: [APIDefinition!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type APISpec {
	"""
	when fetch request specified, data will be automatically populated
	"""
	id: ID!
	data: CLOB
	format: SpecFormat!
	type: APISpecType!
	fetchRequest: FetchRequest @sanitize(path: "graphql.field.api_spec.fetch_request")
}

type AppSystemAuth implements SystemAuth {
	id: ID!
	auth: Auth @sanitize(path: "graphql.field.application.auths")
	type: SystemAuthReferenceType
	tenantId: String
	referenceObjectId: ID
}

type Application {
	id: ID!
	name: String!
	systemNumber: String
	localTenantID: String
	baseUrl: String
	providerName: String
	description: String
	integrationSystemID: ID
	applicationTemplateID: ID
	applicationTemplate: ApplicationTemplate @hasScopes(path: "graphql.field.application.application_template")
	tenantBusinessType: TenantBusinessType
	labels(key: String): Labels
	status: ApplicationStatus!
	webhooks: [Webhook!] @sanitize(path: "graphql.field.application.webhooks")
	healthCheckURL: String
	bundles(first: Int = 200, after: PageCursor): BundlePage
	bundle(id: ID!): Bundle
	apiDefinition(id: ID!): APIDefinition
	eventDefinition(id: ID!): EventDefinition
	auths: [AppSystemAuth!]
	eventingConfiguration: ApplicationEventingConfiguration
	applicationNamespace: String
	createdAt: Timestamp
	updatedAt: Timestamp
	deletedAt: Timestamp
	systemStatus: String
	error: String
}

type ApplicationEventingConfiguration {
	defaultURL: String!
}

type ApplicationPage implements Pageable {
	data: [Application!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type ApplicationStatus {
	condition: ApplicationStatusCondition!
	timestamp: Timestamp!
}

type ApplicationTemplate {
	id: ID!
	name: String!
	description: String
	webhooks: [Webhook!] @sanitize(path: "graphql.field.application_template.webhooks")
	applicationInput: String!
	placeholders: [PlaceholderDefinition!]!
	labels(key: String): Labels
	accessLevel: ApplicationTemplateAccessLevel!
	applicationNamespace: String
}

type ApplicationTemplatePage implements Pageable {
	data: [ApplicationTemplate!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type Auth {
	credential: CredentialData
	accessStrategy: String
	additionalHeaders: HttpHeaders
	additionalHeadersSerialized: HttpHeadersSerialized
	additionalQueryParams: QueryParams
	additionalQueryParamsSerialized: QueryParamsSerialized
	requestAuth: CredentialRequestAuth
	oneTimeToken: OneTimeToken
	certCommonName: String
}

type AutomaticScenarioAssignment {
	scenarioName: String!
	selector: Label!
}

type AutomaticScenarioAssignmentPage implements Pageable {
	data: [AutomaticScenarioAssignment!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type BasicCredentialData {
	username: String!
	password: String!
}

type Bundle {
	id: ID!
	name: String!
	description: String
	instanceAuthRequestInputSchema: JSONSchema
	instanceAuth(id: ID!): BundleInstanceAuth @sanitize(path: "graphql.field.bundle.instance_auth")
	instanceAuths: [BundleInstanceAuth!] @sanitize(path: "graphql.field.bundle.instance_auths")
	"""
	When defined, all Auth requests fallback to defaultInstanceAuth.
	"""
	defaultInstanceAuth: Auth @sanitize(path: "graphql.field.bundle.default_instance_auth")
	apiDefinitions(group: String, first: Int = 200, after: PageCursor): APIDefinitionPage
	eventDefinitions(group: String, first: Int = 200, after: PageCursor): EventDefinitionPage
	documents(first: Int = 200, after: PageCursor): DocumentPage
	apiDefinition(id: ID!): APIDefinition
	eventDefinition(id: ID!): EventDefinition
	correlationIDs: [String!]
	document(id: ID!): Document
	createdAt: Timestamp
	updatedAt: Timestamp
	deletedAt: Timestamp
	error: String
}

type BundleInstanceAuth {
	id: ID!
	"""
	Context of BundleInstanceAuth - such as Runtime ID, namespace
	"""
	context: JSON
	"""
	User input while requesting Bundle Instance Auth
	"""
	inputParams: JSON
	"""
	It may be empty if status is PENDING.
	Populated with `bundle.defaultAuth` value if `bundle.defaultAuth` is defined. If not, Compass notifies Application/Integration System about the Auth request.
	"""
	auth: Auth
	status: BundleInstanceAuthStatus!
	runtimeID: ID
	runtimeContextID: ID
}

type BundleInstanceAuthStatus {
	condition: BundleInstanceAuthStatusCondition!
	timestamp: Timestamp!
	message: String!
	"""
	Possible reasons:
	- PendingNotification
	- NotificationSent
	- CredentialsProvided
	- CredentialsNotProvided
	- PendingDeletion
	"""
	reason: String!
}

type BundlePage implements Pageable {
	data: [Bundle!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type CSRFTokenCredentialRequestAuth {
	tokenEndpointURL: String!
	credential: CredentialData
	additionalHeaders: HttpHeaders
	additionalHeadersSerialized: HttpHeadersSerialized
	additionalQueryParams: QueryParams
	additionalQueryParamsSerialized: QueryParamsSerialized
}

type CertificateOAuthCredentialData {
	clientId: ID!
	certificate: String!
	url: String!
}

type CertificateSubjectMapping {
	id: ID!
	subject: String!
	consumerType: String!
	internalConsumerID: String
	tenantAccessLevels: [String!]!
}

type CertificateSubjectMappingPage implements Pageable {
	data: [CertificateSubjectMapping!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type ConstraintReference {
	constraintID: ID!
	formationTemplateID: ID!
}

type CredentialRequestAuth {
	csrf: CSRFTokenCredentialRequestAuth
}

type Document {
	id: ID!
	title: String!
	displayName: String!
	description: String!
	format: DocumentFormat!
	"""
	for example Service Class, API etc
	"""
	kind: String
	data: CLOB
	fetchRequest: FetchRequest @sanitize(path: "graphql.field.document.fetch_request")
	createdAt: Timestamp
	updatedAt: Timestamp
	deletedAt: Timestamp
	error: String
}

type DocumentPage implements Pageable {
	data: [Document!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type EventDefinition {
	id: ID!
	name: String!
	description: String
	"""
	group allows you to find the same API but in different version
	"""
	group: String
	spec: EventSpec
	version: Version
	createdAt: Timestamp
	updatedAt: Timestamp
	deletedAt: Timestamp
	error: String
}

type EventDefinitionPage implements Pageable {
	data: [EventDefinition!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type EventSpec {
	id: ID!
	data: CLOB
	type: EventSpecType!
	format: SpecFormat!
	fetchRequest: FetchRequest @sanitize(path: "graphql.field.event_spec.fetch_request")
}

"""
Compass performs fetch to validate if request is correct and stores a copy
"""
type FetchRequest {
	url: String!
	auth: Auth @sanitize(path: "graphql.field.fetch_request.auth")
	mode: FetchMode!
	filter: String
	status: FetchRequestStatus!
}

type FetchRequestStatus {
	condition: FetchRequestStatusCondition!
	message: String
	timestamp: Timestamp!
}

type Formation {
	id: ID!
	name: String!
	formationTemplateId: ID!
	"""
	Formation lifecycle notifications state
	"""
	state: String!
	"""
	Formation lifecycle notifications error
	"""
	error: FormationError
	formationAssignment(id: ID!): FormationAssignment
	formationAssignments(first: Int = 200, after: PageCursor): FormationAssignmentPage
	"""
	Aggregated formation status
	"""
	status: FormationStatus!
}

type FormationAssignment {
	id: ID!
	source: ID!
	sourceType: FormationAssignmentType!
	target: ID!
	targetType: FormationAssignmentType!
	state: String!
	value: String
}

type FormationAssignmentPage implements Pageable {
	data: [FormationAssignment!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type FormationConstraint {
	id: ID!
	name: String!
	constraintType: String!
	targetOperation: String!
	operator: String!
	resourceType: String!
	resourceSubtype: String!
	inputTemplate: String!
	constraintScope: String!
}

type FormationError {
	message: String!
	errorCode: Int!
}

type FormationPage implements Pageable {
	data: [Formation!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type FormationStatus {
	condition: FormationStatusCondition!
	errors: [FormationStatusError!]
}

type FormationStatusError {
	assignmentID: ID
	message: String!
	errorCode: Int!
}

type FormationTemplate {
	id: ID!
	name: String!
	applicationTypes: [String!]!
	runtimeTypes: [String!]
	runtimeTypeDisplayName: String
	runtimeArtifactKind: ArtifactType
	webhooks: [Webhook!] @sanitize(path: "graphql.field.formation_template.webhooks")
	leadingProductIDs: [String!]
	formationConstraints: [FormationConstraint!]
}

type FormationTemplatePage implements Pageable {
	data: [FormationTemplate!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type HealthCheck {
	type: HealthCheckType!
	condition: HealthCheckStatusCondition!
	origin: ID
	message: String
	timestamp: Timestamp!
}

type HealthCheckPage implements Pageable {
	data: [HealthCheck!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type IntSysSystemAuth implements SystemAuth {
	id: ID!
	auth: Auth @sanitize(path: "graphql.field.integration_system.auths")
	type: SystemAuthReferenceType
	tenantId: String
	referenceObjectId: ID
}

type IntegrationSystem {
	id: ID!
	name: String!
	description: String
	auths: [IntSysSystemAuth!]
}

type IntegrationSystemPage implements Pageable {
	data: [IntegrationSystem!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type Label {
	key: String!
	value: Any!
}

type LabelDefinition {
	key: String!
	schema: JSONSchema
}

type OAuthCredentialData {
	clientId: ID!
	clientSecret: String!
	"""
	URL for getting access token
	"""
	url: String!
}

type OneTimeTokenForApplication implements OneTimeToken {
	token: String!
	connectorURL: String!
	legacyConnectorURL: String!
	used: Boolean!
	expiresAt: Timestamp!
	createdAt: Timestamp
	usedAt: Timestamp
	raw: String
	rawEncoded: String
	type: OneTimeTokenType
	scenarioGroups: [String]
}

type OneTimeTokenForRuntime implements OneTimeToken {
	token: String!
	connectorURL: String!
	used: Boolean!
	expiresAt: Timestamp!
	createdAt: Timestamp
	usedAt: Timestamp
	raw: String
	rawEncoded: String
	type: OneTimeTokenType
}

type PageInfo {
	startCursor: PageCursor!
	endCursor: PageCursor!
	hasNextPage: Boolean!
}

type PlaceholderDefinition {
	name: String!
	description: String
	jsonPath: String
	optional: Boolean
}

type Runtime {
	id: ID!
	metadata: RuntimeMetadata!
	name: String!
	description: String
	labels(key: String): Labels
	webhooks: [Webhook!] @sanitize(path: "graphql.field.runtime.webhooks")
	status: RuntimeStatus!
	"""
	Returns array of authentication details for Runtime. For now at most one element in array will be returned.
	"""
	auths: [RuntimeSystemAuth!]
	eventingConfiguration: RuntimeEventingConfiguration
	runtimeContext(id: ID!): RuntimeContext
	runtimeContexts(first: Int = 200, after: PageCursor): RuntimeContextPage
	applicationNamespace: String
}

type RuntimeContext {
	id: ID!
	key: String!
	value: String!
	labels(key: String): Labels
}

type RuntimeContextPage implements Pageable {
	data: [RuntimeContext!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type RuntimeEventingConfiguration {
	defaultURL: String!
}

type RuntimeMetadata {
	creationTimestamp: Timestamp!
}

type RuntimePage implements Pageable {
	data: [Runtime!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type RuntimeStatus {
	condition: RuntimeStatusCondition!
	timestamp: Timestamp!
}

type RuntimeSystemAuth implements SystemAuth {
	id: ID!
	auth: Auth @sanitize(path: "graphql.field.runtime.auths")
	type: SystemAuthReferenceType
	tenantId: String
	referenceObjectId: ID
}

type Tenant {
	id: ID!
	internalID: ID!
	name: String
	type: String
	parentID: ID
	initialized: Boolean
	labels(key: String): Labels
	provider: String!
}

type TenantAccess {
	tenantID: ID!
	resourceType: TenantAccessObjectType!
	resourceID: ID!
	owner: Boolean!
}

type TenantBusinessType {
	id: ID!
	code: String!
	name: String!
}

type TenantPage implements Pageable {
	data: [Tenant!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type Version {
	"""
	for example 4.6
	"""
	value: String!
	deprecated: Boolean
	"""
	for example 4.5
	"""
	deprecatedSince: String
	"""
	if true, will be removed in the next version
	"""
	forRemoval: Boolean
}

type Viewer {
	id: ID!
	type: ViewerType!
}

type Webhook {
	id: ID!
	applicationID: ID
	applicationTemplateID: ID
	runtimeID: ID
	integrationSystemID: ID
	formationTemplateID: ID
	type: WebhookType!
	mode: WebhookMode
	correlationIdKey: String
	retryInterval: Int
	timeout: Int
	url: String
	auth: Auth @sanitize(path: "graphql.field.webhooks.auth")
	urlTemplate: String
	inputTemplate: String
	headerTemplate: String
	outputTemplate: String
	statusTemplate: String
	createdAt: Timestamp
}

type Query {
	apisForApplication(appID: ID!, first: Int = 200, after: PageCursor): APIDefinitionPage @hasScopes(path: "graphql.query.apisForApplication")
	eventsForApplication(appID: ID!, first: Int = 200, after: PageCursor): EventDefinitionPage @hasScopes(path: "graphql.query.eventsForApplication")
	"""
	Maximum `first` parameter value is 10
	
	**Examples**
	- [query applications with label filter](examples/query-applications/query-applications-with-label-filter.graphql)
	- [query applications](examples/query-applications/query-applications.graphql)
	"""
	applications(filter: [LabelFilter!], first: Int = 200, after: PageCursor): ApplicationPage! @hasScopes(path: "graphql.query.applications")
	"""
	**Examples**
	- [query application](examples/query-application/query-application.graphql)
	"""
	application(id: ID!): Application @hasScenario(applicationProvider: "GetApplicationID", idField: "id") @hasScopes(path: "graphql.query.application")
	applicationBySystemNumber(systemNumber: String!): Application @hasScopes(path: "graphql.query.applicationBySystemNumber")
	"""
	Maximum `first` parameter value is 100
	
	**Examples**
	- [query applications for runtime](examples/query-applications-for-runtime/query-applications-for-runtime.graphql)
	"""
	applicationsForRuntime(runtimeID: ID!, first: Int = 200, after: PageCursor): ApplicationPage! @hasScopes(path: "graphql.query.applicationsForRuntime")
	"""
	Maximum `first` parameter value is 100
	
	**Examples**
	- [query application templates](examples/query-application-templates/query-application-templates.graphql)
	"""
	applicationTemplates(filter: [LabelFilter!], first: Int = 200, after: PageCursor): ApplicationTemplatePage! @hasScopes(path: "graphql.query.applicationTemplates")
	"""
	**Examples**
	- [query application template](examples/query-application-template/query-application-template.graphql)
	"""
	applicationTemplate(id: ID!): ApplicationTemplate @hasScopes(path: "graphql.query.applicationTemplate")
	"""
	Maximum `first` parameter value is 100
	
	**Examples**
	- [query runtimes with label filter](examples/query-runtimes/query-runtimes-with-label-filter.graphql)
	- [query runtimes with pagination](examples/query-runtimes/query-runtimes-with-pagination.graphql)
	- [query runtimes](examples/query-runtimes/query-runtimes.graphql)
	"""
	runtimes(filter: [LabelFilter!], first: Int = 200, after: PageCursor): RuntimePage! @hasScopes(path: "graphql.query.runtimes")
	"""
	**Examples**
	- [query runtime](examples/query-runtime/query-runtime.graphql)
	"""
	runtime(id: ID!): Runtime @hasScopes(path: "graphql.query.runtime")
	runtimeByTokenIssuer(issuer: String!): Runtime
	"""
	**Examples**
	- [query label definitions](examples/query-label-definitions/query-label-definitions.graphql)
	"""
	labelDefinitions: [LabelDefinition!]! @hasScopes(path: "graphql.query.labelDefinitions")
	labelDefinition(key: String!): LabelDefinition @hasScopes(path: "graphql.query.labelDefinition")
	bundleByInstanceAuth(authID: ID!): Bundle @hasScopes(path: "graphql.query.bundleByInstanceAuth")
	bundleInstanceAuth(id: ID!): BundleInstanceAuth @hasScopes(path: "graphql.query.bundleInstanceAuth")
	healthChecks(types: [HealthCheckType!], origin: ID, first: Int = 200, after: PageCursor): HealthCheckPage! @hasScopes(path: "graphql.query.healthChecks")
	"""
	Maximum `first` parameter value is 100
	
	**Examples**
	- [query integration systems](examples/query-integration-systems/query-integration-systems.graphql)
	"""
	integrationSystems(first: Int = 200, after: PageCursor): IntegrationSystemPage! @hasScopes(path: "graphql.query.integrationSystems")
	"""
	**Examples**
	- [query integration system](examples/query-integration-system/query-integration-system.graphql)
	"""
	integrationSystem(id: ID!): IntegrationSystem @hasScopes(path: "graphql.query.integrationSystem")
	viewer: Viewer! @hasScopes(path: "graphql.query.viewer")
	"""
	**Examples**
	- [query tenants](examples/query-tenants/query-tenants.graphql)
	"""
	tenants(first: Int = 500, after: PageCursor, searchTerm: String): TenantPage! @hasScopes(path: "graphql.query.tenants")
	tenantByExternalID(id: ID!): Tenant @hasScopes(path: "graphql.query.tenants")
	tenantByInternalID(id: ID!): Tenant @hasScopes(path: "graphql.query.tenantByInternalID")
	tenantByLowestOwnerForResource(id: ID!, resource: String!): String! @hasScopes(path: "graphql.query.tenantByLowestOwnerForResource")
	"""
	**Examples**
	- [query automatic scenario assignment for scenario](examples/query-automatic-scenario-assignment-for-scenario/query-automatic-scenario-assignment-for-scenario.graphql)
	"""
	automaticScenarioAssignmentForScenario(scenarioName: String!): AutomaticScenarioAssignment @hasScopes(path: "graphql.query.automaticScenarioAssignmentForScenario")
	"""
	**Examples**
	- [query automatic scenario assignments for selector](examples/query-automatic-scenario-assignments-for-selector/query-automatic-scenario-assignments-for-selector.graphql)
	"""
	automaticScenarioAssignmentsForSelector(selector: LabelSelectorInput! @validate): [AutomaticScenarioAssignment!]! @hasScopes(path: "graphql.query.automaticScenarioAssignmentsForSelector")
	"""
	**Examples**
	- [query automatic scenario assignments](examples/query-automatic-scenario-assignments/query-automatic-scenario-assignments.graphql)
	"""
	automaticScenarioAssignments(first: Int = 200, after: PageCursor): AutomaticScenarioAssignmentPage @hasScopes(path: "graphql.query.automaticScenarioAssignments")
	systemAuth(id: ID!): SystemAuth @hasScopes(path: "graphql.query.systemAuth")
	systemAuthByToken(token: String!): SystemAuth @hasScopes(path: "graphql.query.systemAuthByToken")
	"""
	**Examples**
	- [query formation](examples/query-formation/query-formation.graphql)
	"""
	formation(id: ID!): Formation @hasScopes(path: "graphql.query.formation")
	"""
	**Examples**
	- [query formation by name](examples/query-formation-by-name/query-formation-by-name.graphql)
	"""
	formationByName(name: String!): Formation @hasScopes(path: "graphql.query.formationByName")
	"""
	**Examples**
	- [query formations](examples/query-formations/query-formations.graphql)
	"""
	formations(first: Int = 200, after: PageCursor): FormationPage! @hasScopes(path: "graphql.query.formations")
	formationConstraints: [FormationConstraint!]! @hasScopes(path: "graphql.query.formationConstraints")
	"""
	**Examples**
	- [query formation constraint](examples/query-formation-constraint/query-formation-constraint.graphql)
	"""
	formationConstraint(id: ID!): FormationConstraint! @hasScopes(path: "graphql.query.formationConstraint")
	formationConstraintsByFormationType(formationTemplateID: ID!): [FormationConstraint!]! @hasScopes(path: "graphql.query.formationConstraints")
	"""
	**Examples**
	- [query formation template](examples/query-formation-template/query-formation-template.graphql)
	"""
	formationTemplate(id: ID!): FormationTemplate @hasScopes(path: "graphql.query.formationTemplate")
	"""
	**Examples**
	- [query formation templates](examples/query-formation-templates/query-formation-templates.graphql)
	"""
	formationTemplates(first: Int = 200, after: PageCursor): FormationTemplatePage! @hasScopes(path: "graphql.query.formationTemplates")
	"""
	**Examples**
	- [query certificate subject mapping](examples/query-certificate-subject-mapping/query-certificate-subject-mapping.graphql)
	"""
	certificateSubjectMapping(id: ID!): CertificateSubjectMapping! @hasScopes(path: "graphql.query.certificateSubjectMapping")
	"""
	**Examples**
	- [query certificate subject mappings](examples/query-certificate-subject-mappings/query-certificate-subject-mappings.graphql)
	"""
	certificateSubjectMappings(first: Int = 300, after: PageCursor): CertificateSubjectMappingPage! @hasScopes(path: "graphql.query.certificateSubjectMappings")
}

type Mutation {
	"""
	**Examples**
	- [register application with bundles](examples/register-application/register-application-with-bundles.graphql)
	- [register application with status](examples/register-application/register-application-with-status.graphql)
	- [register application with webhooks](examples/register-application/register-application-with-webhooks.graphql)
	- [register application](examples/register-application/register-application.graphql)
	"""
	registerApplication(in: ApplicationRegisterInput! @validate, mode: OperationMode = SYNC): Application! @hasScopes(path: "graphql.mutation.registerApplication") @async(operationType: CREATE, webhookType: REGISTER_APPLICATION) @synchronizeApplicationTenancy(eventType: NEW_APPLICATION)
	"""
	**Examples**
	- [update application](examples/update-application/update-application.graphql)
	"""
	updateApplication(id: ID!, in: ApplicationUpdateInput! @validate): Application! @hasScopes(path: "graphql.mutation.updateApplication") @async(operationType: UPDATE, idField: "id")
	"""
	**Examples**
	- [unregister application](examples/unregister-application/unregister-application.graphql)
	"""
	unregisterApplication(id: ID!, mode: OperationMode = SYNC): Application! @hasScopes(path: "graphql.mutation.unregisterApplication") @async(operationType: DELETE, idField: "id", webhookType: UNREGISTER_APPLICATION)
	"""
	**Examples**
	- [unpair application](examples/unpair-application/unpair-application.graphql)
	"""
	unpairApplication(id: ID!, mode: OperationMode = SYNC): Application! @hasScopes(path: "graphql.mutation.unpairApplication") @async(operationType: UPDATE, idField: "id", webhookType: UNREGISTER_APPLICATION)
	"""
	**Examples**
	- [create application template](examples/create-application-template/create-application-template.graphql)
	"""
	createApplicationTemplate(in: ApplicationTemplateInput! @validate): ApplicationTemplate! @hasScopes(path: "graphql.mutation.createApplicationTemplate")
	"""
	**Examples**
	- [register application from template](examples/register-application-from-template/register-application-from-template.graphql)
	"""
	registerApplicationFromTemplate(in: ApplicationFromTemplateInput! @validate): Application! @hasScopes(path: "graphql.mutation.registerApplicationFromTemplate") @synchronizeApplicationTenancy(eventType: NEW_APPLICATION)
	"""
	**Examples**
	- [update application template](examples/update-application-template/update-application-template.graphql)
	"""
	updateApplicationTemplate(id: ID!, in: ApplicationTemplateUpdateInput! @validate): ApplicationTemplate! @hasScopes(path: "graphql.mutation.updateApplicationTemplate")
	"""
	**Examples**
	- [delete application template](examples/delete-application-template/delete-application-template.graphql)
	"""
	deleteApplicationTemplate(id: ID!): ApplicationTemplate! @hasScopes(path: "graphql.mutation.deleteApplicationTemplate")
	"""
	**Examples**
	- [merge applications](examples/merge-applications/merge-applications.graphql)
	"""
	mergeApplications(destinationID: ID!, sourceID: ID!): Application! @hasScopes(path: "graphql.mutation.mergeApplications")
	"""
	**Examples**
	- [register runtime with webhooks](examples/register-runtime/register-runtime-with-webhooks.graphql)
	- [register runtime](examples/register-runtime/register-runtime.graphql)
	"""
	registerRuntime(in: RuntimeRegisterInput! @validate): Runtime! @hasScopes(path: "graphql.mutation.registerRuntime")
	"""
	**Examples**
	- [update runtime](examples/update-runtime/update-runtime.graphql)
	"""
	updateRuntime(id: ID!, in: RuntimeUpdateInput! @validate): Runtime! @hasScopes(path: "graphql.mutation.updateRuntime")
	"""
	**Examples**
	- [unregister runtime](examples/unregister-runtime/unregister-runtime.graphql)
	"""
	unregisterRuntime(id: ID!): Runtime! @hasScopes(path: "graphql.mutation.unregisterRuntime")
	"""
	**Examples**
	- [register runtime context](examples/register-runtime-context/register-runtime-context.graphql)
	"""
	registerRuntimeContext(runtimeID: ID!, in: RuntimeContextInput! @validate): RuntimeContext! @hasScopes(path: "graphql.mutation.registerRuntimeContext")
	"""
	**Examples**
	- [update runtime context](examples/update-runtime-context/update-runtime-context.graphql)
	"""
	updateRuntimeContext(id: ID!, in: RuntimeContextInput! @validate): RuntimeContext! @hasScopes(path: "graphql.mutation.updateRuntimeContext")
	unregisterRuntimeContext(id: ID!): RuntimeContext! @hasScopes(path: "graphql.mutation.unregisterRuntimeContext")
	"""
	**Examples**
	- [register integration system](examples/register-integration-system/register-integration-system.graphql)
	"""
	registerIntegrationSystem(in: IntegrationSystemInput! @validate): IntegrationSystem! @hasScopes(path: "graphql.mutation.registerIntegrationSystem")
	"""
	**Examples**
	- [update integration system](examples/update-integration-system/update-integration-system.graphql)
	"""
	updateIntegrationSystem(id: ID!, in: IntegrationSystemInput! @validate): IntegrationSystem! @hasScopes(path: "graphql.mutation.updateIntegrationSystem")
	"""
	**Examples**
	- [unregister integration system](examples/unregister-integration-system/unregister-integration-system.graphql)
	"""
	unregisterIntegrationSystem(id: ID!): IntegrationSystem! @hasScopes(path: "graphql.mutation.unregisterIntegrationSystem")
	"""
	**Examples**
	- [add application template webhook](examples/add-webhook/add-application-template-webhook.graphql)
	- [add application webhook](examples/add-webhook/add-application-webhook.graphql)
	- [add formation template webhook](examples/add-webhook/add-formation-template-webhook.graphql)
	- [add runtime webhook](examples/add-webhook/add-runtime-webhook.graphql)
	"""
	addWebhook(applicationID: ID, applicationTemplateID: ID, runtimeID: ID, formationTemplateID: ID, in: WebhookInput! @validate): Webhook! @hasScopes(path: "graphql.mutation.addWebhook")
	"""
	**Examples**
	- [update webhook](examples/update-webhook/update-webhook.graphql)
	"""
	updateWebhook(webhookID: ID!, in: WebhookInput! @validate): Webhook! @hasScopes(path: "graphql.mutation.updateWebhook")
	"""
	**Examples**
	- [delete webhook](examples/delete-webhook/delete-webhook.graphql)
	"""
	deleteWebhook(webhookID: ID!): Webhook! @hasScopes(path: "graphql.mutation.deleteWebhook")
	"""
	**Examples**
	- [add api definition to bundle](examples/add-api-definition-to-bundle/add-api-definition-to-bundle.graphql)
	"""
	addAPIDefinitionToBundle(bundleID: ID!, in: APIDefinitionInput! @validate): APIDefinition! @hasScopes(path: "graphql.mutation.addAPIDefinitionToBundle")
	"""
	**Examples**
	- [add api definition to application](examples/add-api-definition-to-application/add-api-definition-to-application.graphql)
	"""
	addAPIDefinitionToApplication(appID: ID!, in: APIDefinitionInput! @validate): APIDefinition! @hasScopes(path: "graphql.mutation.addAPIDefinitionToApplication")
	"""
	**Examples**
	- [update api definition](examples/update-api-definition/update-api-definition.graphql)
	"""
	updateAPIDefinition(id: ID!, in: APIDefinitionInput! @validate): APIDefinition! @hasScopes(path: "graphql.mutation.updateAPIDefinition")
	updateAPIDefinitionForApplication(id: ID!, in: APIDefinitionInput! @validate): APIDefinition! @hasScopes(path: "graphql.mutation.updateAPIDefinitionForApplication")
	"""
	**Examples**
	- [delete api definition](examples/delete-api-definition/delete-api-definition.graphql)
	"""
	deleteAPIDefinition(id: ID!): APIDefinition! @hasScopes(path: "graphql.mutation.deleteAPIDefinition")
	"""
	**Examples**
	- [refetch api spec](examples/refetch-api-spec/refetch-api-spec.graphql)
	"""
	refetchAPISpec(apiID: ID!): APISpec! @hasScopes(path: "graphql.mutation.refetchAPISpec")
	requestOneTimeTokenForRuntime(id: ID!, systemAuthID: ID): OneTimeTokenForRuntime! @hasScopes(path: "graphql.mutation.requestOneTimeTokenForRuntime")
	requestOneTimeTokenForApplication(id: ID!, systemAuthID: ID): OneTimeTokenForApplication! @hasScopes(path: "graphql.mutation.requestOneTimeTokenForApplication")
	requestClientCredentialsForRuntime(id: ID!): SystemAuth! @hasScopes(path: "graphql.mutation.requestClientCredentialsForRuntime")
	requestClientCredentialsForApplication(id: ID!): SystemAuth! @hasScopes(path: "graphql.mutation.requestClientCredentialsForApplication")
	requestClientCredentialsForIntegrationSystem(id: ID!): SystemAuth! @hasScopes(path: "graphql.mutation.requestClientCredentialsForIntegrationSystem")
	deleteSystemAuthForRuntime(authID: ID!): SystemAuth! @hasScopes(path: "graphql.mutation.deleteSystemAuthForRuntime")
	deleteSystemAuthForApplication(authID: ID!): SystemAuth! @hasScopes(path: "graphql.mutation.deleteSystemAuthForApplication")
	deleteSystemAuthForIntegrationSystem(authID: ID!): SystemAuth! @hasScopes(path: "graphql.mutation.deleteSystemAuthForIntegrationSystem")
	updateSystemAuth(authID: ID!, in: AuthInput!): SystemAuth! @hasScopes(path: "graphql.mutation.updateSystemAuth")
	invalidateSystemAuthOneTimeToken(authID: ID!): SystemAuth! @hasScopes(path: "graphql.mutation.invalidateSystemAuthOneTimeToken")
	"""
	**Examples**
	- [add event definition to bundle](examples/add-event-definition-to-bundle/add-event-definition-to-bundle.graphql)
	"""
	addEventDefinitionToBundle(bundleID: ID!, in: EventDefinitionInput! @validate): EventDefinition! @hasScopes(path: "graphql.mutation.addEventDefinitionToBundle")
	"""
	**Examples**
	- [add event definition to application](examples/add-event-definition-to-application/add-event-definition-to-application.graphql)
	"""
	addEventDefinitionToApplication(appID: ID!, in: EventDefinitionInput! @validate): EventDefinition! @hasScopes(path: "graphql.mutation.addEventDefinitionToApplication")
	"""
	**Examples**
	- [update event definition](examples/update-event-definition/update-event-definition.graphql)
	"""
	updateEventDefinition(id: ID!, in: EventDefinitionInput! @validate): EventDefinition! @hasScopes(path: "graphql.mutation.updateEventDefinition")
	updateEventDefinitionForApplication(id: ID!, in: EventDefinitionInput! @validate): EventDefinition! @hasScopes(path: "graphql.mutation.updateEventDefinitionForApplication")
	"""
	**Examples**
	- [delete event definition](examples/delete-event-definition/delete-event-definition.graphql)
	"""
	deleteEventDefinition(id: ID!): EventDefinition! @hasScopes(path: "graphql.mutation.deleteEventDefinition")
	refetchEventDefinitionSpec(eventID: ID!): EventSpec! @hasScopes(path: "graphql.mutation.refetchEventDefinitionSpec")
	"""
	**Examples**
	- [add document to bundle](examples/add-document-to-bundle/add-document-to-bundle.graphql)
	"""
	addDocumentToBundle(bundleID: ID!, in: DocumentInput! @validate): Document! @hasScopes(path: "graphql.mutation.addDocumentToBundle")
	"""
	**Examples**
	- [delete document](examples/delete-document/delete-document.graphql)
	"""
	deleteDocument(id: ID!): Document! @hasScopes(path: "graphql.mutation.deleteDocument")
	"""
	**Examples**
	- [create formation](examples/create-formation/create-formation.graphql)
	"""
	createFormation(formation: FormationInput!): Formation! @hasScopes(path: "graphql.mutation.createFormation")
	"""
	**Examples**
	- [resynchronize formation notifications](examples/resynchronize-formation-notifications/resynchronize-formation-notifications.graphql)
	"""
	resynchronizeFormationNotifications(formationID: ID!): Formation! @hasScopes(path: "graphql.mutation.resynchronizeFormationNotifications")
	"""
	**Examples**
	- [delete formation](examples/delete-formation/delete-formation.graphql)
	"""
	deleteFormation(formation: FormationInput!): Formation! @hasScopes(path: "graphql.mutation.deleteFormation")
	"""
	**Examples**
	- [assign application to formation](examples/assign-formation/assign-application-to-formation.graphql)
	- [assign runtime context to formation](examples/assign-formation/assign-runtime-context-to-formation.graphql)
	- [assign runtime to formation](examples/assign-formation/assign-runtime-to-formation.graphql)
	- [assign tenant to formation](examples/assign-formation/assign-tenant-to-formation.graphql)
	"""
	assignFormation(objectID: ID!, objectType: FormationObjectType!, formation: FormationInput!): Formation! @hasScopes(path: "graphql.mutation.assignFormation")
	"""
	**Examples**
	- [unassign application from formation](examples/unassign-formation/unassign-application-from-formation.graphql)
	- [unassign runtime context from formation](examples/unassign-formation/unassign-runtime-context-from-formation.graphql)
	- [unassign runtime from formation](examples/unassign-formation/unassign-runtime-from-formation.graphql)
	- [unassign tenant from formation](examples/unassign-formation/unassign-tenant-from-formation.graphql)
	"""
	unassignFormation(objectID: ID!, objectType: FormationObjectType!, formation: FormationInput!): Formation! @hasScopes(path: "graphql.mutation.unassignFormation")
	"""
	**Examples**
	- [create formation constraint](examples/create-formation-constraint/create-formation-constraint.graphql)
	"""
	createFormationConstraint(formationConstraint: FormationConstraintInput! @validate): FormationConstraint! @hasScopes(path: "graphql.mutation.createFormationConstraint")
	"""
	**Examples**
	- [delete formation constraint](examples/delete-formation-constraint/delete-formation-constraint.graphql)
	"""
	deleteFormationConstraint(id: ID!): FormationConstraint! @hasScopes(path: "graphql.mutation.deleteFormationConstraint")
	"""
	**Examples**
	- [update formation constraint](examples/update-formation-constraint/update-formation-constraint.graphql)
	"""
	updateFormationConstraint(id: ID!, in: FormationConstraintUpdateInput!): FormationConstraint! @hasScopes(path: "graphql.mutation.updateFormationConstraint")
	"""
	**Examples**
	- [attach constraint to formation template](examples/attach-constraint-to-formation-template/attach-constraint-to-formation-template.graphql)
	"""
	attachConstraintToFormationTemplate(constraintID: ID!, formationTemplateID: ID!): ConstraintReference! @hasScopes(path: "graphql.mutation.attachConstraintToFormationTemplate")
	"""
	**Examples**
	- [detach constraint from formation template](examples/detach-constraint-from-formation-template/detach-constraint-from-formation-template.graphql)
	"""
	detachConstraintFromFormationTemplate(constraintID: ID!, formationTemplateID: ID!): ConstraintReference! @hasScopes(path: "graphql.mutation.detachConstraintFromFormationTemplate")
	"""
	**Examples**
	- [create label definition](examples/create-label-definition/create-label-definition.graphql)
	"""
	createLabelDefinition(in: LabelDefinitionInput! @validate): LabelDefinition! @hasScopes(path: "graphql.mutation.createLabelDefinition")
	"""
	**Examples**
	- [update label definition](examples/update-label-definition/update-label-definition.graphql)
	"""
	updateLabelDefinition(in: LabelDefinitionInput! @validate): LabelDefinition! @hasScopes(path: "graphql.mutation.updateLabelDefinition")
	"""
	If a label with given key already exist, it will be replaced with provided value.
	
	**Examples**
	- [set application label](examples/set-application-label/set-application-label.graphql)
	"""
	setApplicationLabel(applicationID: ID!, key: String!, value: Any!): Label! @hasScopes(path: "graphql.mutation.setApplicationLabel")
	"""
	If Application does not exist or the label key is not found, it returns an error.
	
	**Examples**
	- [delete application label](examples/delete-application-label/delete-application-label.graphql)
	"""
	deleteApplicationLabel(applicationID: ID!, key: String!): Label! @hasScopes(path: "graphql.mutation.deleteApplicationLabel")
	"""
	If a label with given key already exist, it will be replaced with provided value.
	"""
	setRuntimeLabel(runtimeID: ID!, key: String!, value: Any!): Label! @hasScopes(path: "graphql.mutation.setRuntimeLabel")
	"""
	If Runtime does not exist or the label key is not found, it returns an error.
	"""
	deleteRuntimeLabel(runtimeID: ID!, key: String!): Label! @hasScopes(path: "graphql.mutation.deleteRuntimeLabel")
	setDefaultEventingForApplication(appID: String!, runtimeID: String!): ApplicationEventingConfiguration! @hasScopes(path: "graphql.mutation.setDefaultEventingForApplication")
	deleteDefaultEventingForApplication(appID: String!): ApplicationEventingConfiguration! @hasScopes(path: "graphql.mutation.deleteDefaultEventingForApplication")
	"""
	When BundleInstanceAuth is not in pending state, the operation returns error.
	
	When used without error, the status of pending auth is set to success.
	
	**Examples**
	- [set bundle instance auth](examples/set-bundle-instance-auth/set-bundle-instance-auth.graphql)
	"""
	setBundleInstanceAuth(authID: ID!, in: BundleInstanceAuthSetInput! @validate): BundleInstanceAuth! @hasScopes(path: "graphql.mutation.setBundleInstanceAuth")
	"""
	**Examples**
	- [delete bundle instance auth](examples/delete-bundle-instance-auth/delete-bundle-instance-auth.graphql)
	"""
	deleteBundleInstanceAuth(authID: ID!): BundleInstanceAuth! @hasScopes(path: "graphql.mutation.deleteBundleInstanceAuth")
	"""
	When defaultInstanceAuth is set, it fires "createBundleInstanceAuth" mutation. Otherwise, the status of the BundleInstanceAuth is set to PENDING.
	
	**Examples**
	- [request bundle instance auth creation](examples/request-bundle-instance-auth-creation/request-bundle-instance-auth-creation.graphql)
	"""
	requestBundleInstanceAuthCreation(bundleID: ID!, in: BundleInstanceAuthRequestInput! @validate): BundleInstanceAuth! @hasScenario(applicationProvider: "GetApplicationIDByBundle", idField: "bundleID") @hasScopes(path: "graphql.mutation.requestBundleInstanceAuthCreation")
	"""
	When defaultInstanceAuth is set, it fires "deleteBundleInstanceAuth" mutation. Otherwise, the status of the BundleInstanceAuth is set to UNUSED.
	
	**Examples**
	- [request bundle instance auth deletion](examples/request-bundle-instance-auth-deletion/request-bundle-instance-auth-deletion.graphql)
	"""
	requestBundleInstanceAuthDeletion(authID: ID!): BundleInstanceAuth! @hasScenario(applicationProvider: "GetApplicationIDByBundleInstanceAuth", idField: "authID") @hasScopes(path: "graphql.mutation.requestBundleInstanceAuthDeletion")
	"""
	**Examples**
	- [create bundle instance auth](examples/create-bundle-instance-auth/create-bundle-instance-auth.graphql)
	"""
	createBundleInstanceAuth(bundleID: ID!, in: BundleInstanceAuthCreateInput! @validate): BundleInstanceAuth! @hasScopes(path: "graphql.mutation.createBundleInstanceAuth")
	"""
	**Examples**
	- [update bundle instance auth](examples/update-bundle-instance-auth/update-bundle-instance-auth.graphql)
	"""
	updateBundleInstanceAuth(id: ID!, bundleID: ID!, in: BundleInstanceAuthUpdateInput!): BundleInstanceAuth! @hasScopes(path: "graphql.mutation.updateBundleInstanceAuth")
	"""
	**Examples**
	- [add bundle](examples/add-bundle/add-bundle.graphql)
	"""
	addBundle(applicationID: ID!, in: BundleCreateInput! @validate): Bundle! @hasScopes(path: "graphql.mutation.addBundle")
	"""
	**Examples**
	- [update bundle](examples/update-bundle/update-bundle.graphql)
	"""
	updateBundle(id: ID!, in: BundleUpdateInput! @validate): Bundle! @hasScopes(path: "graphql.mutation.updateBundle")
	"""
	**Examples**
	- [delete bundle](examples/delete-bundle/delete-bundle.graphql)
	"""
	deleteBundle(id: ID!): Bundle! @hasScopes(path: "graphql.mutation.deleteBundle")
	writeTenants(in: [BusinessTenantMappingInput!]): [String!] @hasScopes(path: "graphql.mutation.writeTenants") @synchronizeApplicationTenancy(eventType: NEW_MULTIPLE_TENANTS)
	writeTenant(in: BusinessTenantMappingInput!): String! @hasScopes(path: "graphql.mutation.writeTenants") @synchronizeApplicationTenancy(eventType: NEW_SINGLE_TENANT)
	deleteTenants(in: [String!]): Int! @hasScopes(path: "graphql.mutation.deleteTenants")
	updateTenant(id: ID!, in: BusinessTenantMappingInput!): Tenant! @hasScopes(path: "graphql.mutation.updateTenant")
	subscribeTenant(providerID: String!, subaccountID: String!, providerSubaccountID: String!, consumerTenantID: String!, region: String!, subscriptionAppName: String!, subscriptionPayload: String!): Boolean! @hasScopes(path: "graphql.mutation.subscribeTenant")
	unsubscribeTenant(providerID: String!, subaccountID: String!, providerSubaccountID: String!, consumerTenantID: String!, region: String!): Boolean! @hasScopes(path: "graphql.mutation.unsubscribeTenant")
	"""
	**Examples**
	- [create formation template with webhooks](examples/create-formation-template/create-formation-template-with-webhooks.graphql)
	- [create formation template](examples/create-formation-template/create-formation-template.graphql)
	"""
	createFormationTemplate(in: FormationTemplateInput! @validate): FormationTemplate @hasScopes(path: "graphql.mutation.createFormationTemplate")
	"""
	**Examples**
	- [delete formation template](examples/delete-formation-template/delete-formation-template.graphql)
	"""
	deleteFormationTemplate(id: ID!): FormationTemplate @hasScopes(path: "graphql.mutation.deleteFormationTemplate")
	"""
	**Examples**
	- [update formation template](examples/update-formation-template/update-formation-template.graphql)
	"""
	updateFormationTemplate(id: ID!, in: FormationTemplateInput! @validate): FormationTemplate @hasScopes(path: "graphql.mutation.updateFormationTemplate")
	"""
	**Examples**
	- [create certificate subject mapping](examples/create-certificate-subject-mapping/create-certificate-subject-mapping.graphql)
	"""
	createCertificateSubjectMapping(in: CertificateSubjectMappingInput! @validate): CertificateSubjectMapping @hasScopes(path: "graphql.mutation.createCertificateSubjectMapping")
	"""
	**Examples**
	- [update certificate subject mapping](examples/update-certificate-subject-mapping/update-certificate-subject-mapping.graphql)
	"""
	updateCertificateSubjectMapping(id: ID!, in: CertificateSubjectMappingInput! @validate): CertificateSubjectMapping @hasScopes(path: "graphql.mutation.updateCertificateSubjectMapping")
	"""
	**Examples**
	- [delete certificate subject mapping](examples/delete-certificate-subject-mapping/delete-certificate-subject-mapping.graphql)
	"""
	deleteCertificateSubjectMapping(id: ID!): CertificateSubjectMapping @hasScopes(path: "graphql.mutation.deleteCertificateSubjectMapping")
	"""
	**Examples**
	- [add tenant access](examples/add-tenant-access/add-tenant-access.graphql)
	"""
	addTenantAccess(in: TenantAccessInput!): TenantAccess @hasScopes(path: "graphql.mutation.addTenantAccess")
	"""
	**Examples**
	- [remove tenant access](examples/remove-tenant-access/remove-tenant-access.graphql)
	"""
	removeTenantAccess(tenantID: ID!, resourceID: ID!, resourceType: TenantAccessObjectType!): TenantAccess @hasScopes(path: "graphql.mutation.removeTenantAccess")
}

