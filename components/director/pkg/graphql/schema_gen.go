// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	APIDefinition() APIDefinitionResolver
	APISpec() APISpecResolver
	Application() ApplicationResolver
	ApplicationTemplate() ApplicationTemplateResolver
	Bundle() BundleResolver
	Document() DocumentResolver
	EventDefinition() EventDefinitionResolver
	EventSpec() EventSpecResolver
	Formation() FormationResolver
	FormationAssignment() FormationAssignmentResolver
	FormationTemplate() FormationTemplateResolver
	IntegrationSystem() IntegrationSystemResolver
	Mutation() MutationResolver
	OneTimeTokenForApplication() OneTimeTokenForApplicationResolver
	OneTimeTokenForRuntime() OneTimeTokenForRuntimeResolver
	Query() QueryResolver
	Runtime() RuntimeResolver
	RuntimeContext() RuntimeContextResolver
	Tenant() TenantResolver
}

type DirectiveRoot struct {
	Async                         func(ctx context.Context, obj interface{}, next graphql.Resolver, operationType OperationType, webhookType *WebhookType, idField *string) (res interface{}, err error)
	HasScenario                   func(ctx context.Context, obj interface{}, next graphql.Resolver, applicationProvider string, idField string) (res interface{}, err error)
	HasScopes                     func(ctx context.Context, obj interface{}, next graphql.Resolver, path string) (res interface{}, err error)
	Sanitize                      func(ctx context.Context, obj interface{}, next graphql.Resolver, path string) (res interface{}, err error)
	SynchronizeApplicationTenancy func(ctx context.Context, obj interface{}, next graphql.Resolver, eventType EventType) (res interface{}, err error)
	Validate                      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	APIDefinition struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		Error       func(childComplexity int) int
		Group       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Spec        func(childComplexity int) int
		TargetURL   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	APIDefinitionPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	APISpec struct {
		Data         func(childComplexity int) int
		FetchRequest func(childComplexity int) int
		Format       func(childComplexity int) int
		ID           func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	AppSystemAuth struct {
		Auth              func(childComplexity int) int
		ID                func(childComplexity int) int
		ReferenceObjectID func(childComplexity int) int
		TenantID          func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Application struct {
		APIDefinition           func(childComplexity int, id string) int
		ApplicationNamespace    func(childComplexity int) int
		ApplicationTemplate     func(childComplexity int) int
		ApplicationTemplateID   func(childComplexity int) int
		Auths                   func(childComplexity int) int
		BaseURL                 func(childComplexity int) int
		Bundle                  func(childComplexity int, id string) int
		Bundles                 func(childComplexity int, first *int, after *PageCursor) int
		CreatedAt               func(childComplexity int) int
		DeletedAt               func(childComplexity int) int
		Description             func(childComplexity int) int
		Error                   func(childComplexity int) int
		EventDefinition         func(childComplexity int, id string) int
		EventingConfiguration   func(childComplexity int) int
		HealthCheckURL          func(childComplexity int) int
		ID                      func(childComplexity int) int
		IntegrationDependencies func(childComplexity int, first *int, after *PageCursor) int
		IntegrationSystemID     func(childComplexity int) int
		Labels                  func(childComplexity int, key *string) int
		LocalTenantID           func(childComplexity int) int
		Name                    func(childComplexity int) int
		ProviderName            func(childComplexity int) int
		Status                  func(childComplexity int) int
		SystemNumber            func(childComplexity int) int
		SystemStatus            func(childComplexity int) int
		UpdatedAt               func(childComplexity int) int
		Webhooks                func(childComplexity int) int
	}

	ApplicationEventingConfiguration struct {
		DefaultURL func(childComplexity int) int
	}

	ApplicationPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ApplicationStatus struct {
		Condition func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	ApplicationTemplate struct {
		AccessLevel          func(childComplexity int) int
		ApplicationInput     func(childComplexity int) int
		ApplicationNamespace func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		Description          func(childComplexity int) int
		ID                   func(childComplexity int) int
		Labels               func(childComplexity int, key *string) int
		Name                 func(childComplexity int) int
		Placeholders         func(childComplexity int) int
		UpdatedAt            func(childComplexity int) int
		Webhooks             func(childComplexity int) int
	}

	ApplicationTemplatePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Aspect struct {
		APIResources   func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		DeletedAt      func(childComplexity int) int
		Description    func(childComplexity int) int
		Error          func(childComplexity int) int
		EventResources func(childComplexity int) int
		ID             func(childComplexity int) int
		Mandatory      func(childComplexity int) int
		Name           func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	AspectAPIDefinition struct {
		OrdID func(childComplexity int) int
	}

	AspectEventDefinition struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		Error     func(childComplexity int) int
		OrdID     func(childComplexity int) int
		Subset    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	AspectEventDefinitionSubset struct {
		EventType func(childComplexity int) int
	}

	Auth struct {
		AccessStrategy                  func(childComplexity int) int
		AdditionalHeaders               func(childComplexity int) int
		AdditionalHeadersSerialized     func(childComplexity int) int
		AdditionalQueryParams           func(childComplexity int) int
		AdditionalQueryParamsSerialized func(childComplexity int) int
		CertCommonName                  func(childComplexity int) int
		Credential                      func(childComplexity int) int
		OneTimeToken                    func(childComplexity int) int
		RequestAuth                     func(childComplexity int) int
	}

	AutomaticScenarioAssignment struct {
		ScenarioName func(childComplexity int) int
		Selector     func(childComplexity int) int
	}

	AutomaticScenarioAssignmentPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BasicCredentialData struct {
		Password func(childComplexity int) int
		Username func(childComplexity int) int
	}

	Bundle struct {
		APIDefinition                  func(childComplexity int, id string) int
		APIDefinitions                 func(childComplexity int, group *string, first *int, after *PageCursor) int
		CorrelationIDs                 func(childComplexity int) int
		CreatedAt                      func(childComplexity int) int
		DefaultInstanceAuth            func(childComplexity int) int
		DeletedAt                      func(childComplexity int) int
		Description                    func(childComplexity int) int
		Document                       func(childComplexity int, id string) int
		Documents                      func(childComplexity int, first *int, after *PageCursor) int
		Error                          func(childComplexity int) int
		EventDefinition                func(childComplexity int, id string) int
		EventDefinitions               func(childComplexity int, group *string, first *int, after *PageCursor) int
		ID                             func(childComplexity int) int
		InstanceAuth                   func(childComplexity int, id string) int
		InstanceAuthRequestInputSchema func(childComplexity int) int
		InstanceAuths                  func(childComplexity int) int
		Name                           func(childComplexity int) int
		UpdatedAt                      func(childComplexity int) int
	}

	BundleInstanceAuth struct {
		Auth             func(childComplexity int) int
		Context          func(childComplexity int) int
		ID               func(childComplexity int) int
		InputParams      func(childComplexity int) int
		RuntimeContextID func(childComplexity int) int
		RuntimeID        func(childComplexity int) int
		Status           func(childComplexity int) int
	}

	BundleInstanceAuthStatus struct {
		Condition func(childComplexity int) int
		Message   func(childComplexity int) int
		Reason    func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	BundlePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CSRFTokenCredentialRequestAuth struct {
		AdditionalHeaders               func(childComplexity int) int
		AdditionalHeadersSerialized     func(childComplexity int) int
		AdditionalQueryParams           func(childComplexity int) int
		AdditionalQueryParamsSerialized func(childComplexity int) int
		Credential                      func(childComplexity int) int
		TokenEndpointURL                func(childComplexity int) int
	}

	CertificateOAuthCredentialData struct {
		Certificate func(childComplexity int) int
		ClientID    func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	CertificateSubjectMapping struct {
		ConsumerType       func(childComplexity int) int
		ID                 func(childComplexity int) int
		InternalConsumerID func(childComplexity int) int
		Subject            func(childComplexity int) int
		TenantAccessLevels func(childComplexity int) int
	}

	CertificateSubjectMappingPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ConstraintReference struct {
		ConstraintID        func(childComplexity int) int
		FormationTemplateID func(childComplexity int) int
	}

	CredentialRequestAuth struct {
		Csrf func(childComplexity int) int
	}

	Document struct {
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		DisplayName  func(childComplexity int) int
		Error        func(childComplexity int) int
		FetchRequest func(childComplexity int) int
		Format       func(childComplexity int) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Title        func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	DocumentPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EventDefinition struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		Error       func(childComplexity int) int
		Group       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Spec        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	EventDefinitionPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EventSpec struct {
		Data         func(childComplexity int) int
		FetchRequest func(childComplexity int) int
		Format       func(childComplexity int) int
		ID           func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	FetchRequest struct {
		Auth   func(childComplexity int) int
		Filter func(childComplexity int) int
		Mode   func(childComplexity int) int
		Status func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	FetchRequestStatus struct {
		Condition func(childComplexity int) int
		Message   func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	Formation struct {
		Error                         func(childComplexity int) int
		FormationAssignment           func(childComplexity int, id string) int
		FormationAssignments          func(childComplexity int, first *int, after *PageCursor) int
		FormationTemplateID           func(childComplexity int) int
		ID                            func(childComplexity int) int
		LastNotificationSentTimestamp func(childComplexity int) int
		LastStateChangeTimestamp      func(childComplexity int) int
		Name                          func(childComplexity int) int
		State                         func(childComplexity int) int
		Status                        func(childComplexity int) int
		TenantID                      func(childComplexity int) int
	}

	FormationAssignment struct {
		Configuration                 func(childComplexity int) int
		Error                         func(childComplexity int) int
		ID                            func(childComplexity int) int
		LastNotificationSentTimestamp func(childComplexity int) int
		LastStateChangeTimestamp      func(childComplexity int) int
		Source                        func(childComplexity int) int
		SourceEntity                  func(childComplexity int) int
		SourceType                    func(childComplexity int) int
		State                         func(childComplexity int) int
		Target                        func(childComplexity int) int
		TargetEntity                  func(childComplexity int) int
		TargetType                    func(childComplexity int) int
		Value                         func(childComplexity int) int
	}

	FormationAssignmentPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	FormationConstraint struct {
		ConstraintScope func(childComplexity int) int
		ConstraintType  func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Description     func(childComplexity int) int
		ID              func(childComplexity int) int
		InputTemplate   func(childComplexity int) int
		Name            func(childComplexity int) int
		Operator        func(childComplexity int) int
		Priority        func(childComplexity int) int
		ResourceSubtype func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TargetOperation func(childComplexity int) int
	}

	FormationError struct {
		ErrorCode func(childComplexity int) int
		Message   func(childComplexity int) int
	}

	FormationPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	FormationStatus struct {
		Condition func(childComplexity int) int
		Errors    func(childComplexity int) int
	}

	FormationStatusError struct {
		AssignmentID func(childComplexity int) int
		ErrorCode    func(childComplexity int) int
		Message      func(childComplexity int) int
	}

	FormationTemplate struct {
		ApplicationTypes       func(childComplexity int) int
		DiscoveryConsumers     func(childComplexity int) int
		FormationConstraints   func(childComplexity int) int
		ID                     func(childComplexity int) int
		LeadingProductIDs      func(childComplexity int) int
		Name                   func(childComplexity int) int
		RuntimeArtifactKind    func(childComplexity int) int
		RuntimeTypeDisplayName func(childComplexity int) int
		RuntimeTypes           func(childComplexity int) int
		SupportsReset          func(childComplexity int) int
		Webhooks               func(childComplexity int) int
	}

	FormationTemplatePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HealthCheck struct {
		Condition func(childComplexity int) int
		Message   func(childComplexity int) int
		Origin    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	HealthCheckPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IntSysSystemAuth struct {
		Auth              func(childComplexity int) int
		ID                func(childComplexity int) int
		ReferenceObjectID func(childComplexity int) int
		TenantID          func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	IntegrationDependency struct {
		Aspects       func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		Error         func(childComplexity int) int
		ID            func(childComplexity int) int
		Labels        func(childComplexity int) int
		Mandatory     func(childComplexity int) int
		Name          func(childComplexity int) int
		OrdID         func(childComplexity int) int
		PartOfPackage func(childComplexity int) int
		ReleaseStatus func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Version       func(childComplexity int) int
		Visibility    func(childComplexity int) int
	}

	IntegrationDependencyPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IntegrationSystem struct {
		Auths       func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	IntegrationSystemPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Label struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	LabelDefinition struct {
		Key    func(childComplexity int) int
		Schema func(childComplexity int) int
	}

	Mutation struct {
		AddAPIDefinitionToApplication                func(childComplexity int, appID string, in APIDefinitionInput) int
		AddAPIDefinitionToBundle                     func(childComplexity int, bundleID string, in APIDefinitionInput) int
		AddBundle                                    func(childComplexity int, applicationID string, in BundleCreateInput) int
		AddDocumentToBundle                          func(childComplexity int, bundleID string, in DocumentInput) int
		AddEventDefinitionToApplication              func(childComplexity int, appID string, in EventDefinitionInput) int
		AddEventDefinitionToBundle                   func(childComplexity int, bundleID string, in EventDefinitionInput) int
		AddIntegrationDependencyToApplication        func(childComplexity int, appID string, in IntegrationDependencyInput) int
		AddTenantAccess                              func(childComplexity int, in TenantAccessInput) int
		AddWebhook                                   func(childComplexity int, applicationID *string, applicationTemplateID *string, runtimeID *string, formationTemplateID *string, in WebhookInput) int
		AssignFormation                              func(childComplexity int, objectID string, objectType FormationObjectType, formation FormationInput) int
		AttachConstraintToFormationTemplate          func(childComplexity int, constraintID string, formationTemplateID string) int
		CreateApplicationTemplate                    func(childComplexity int, in ApplicationTemplateInput) int
		CreateBundleInstanceAuth                     func(childComplexity int, bundleID string, in BundleInstanceAuthCreateInput) int
		CreateCertificateSubjectMapping              func(childComplexity int, in CertificateSubjectMappingInput) int
		CreateFormation                              func(childComplexity int, formation FormationInput) int
		CreateFormationConstraint                    func(childComplexity int, formationConstraint FormationConstraintInput) int
		CreateFormationTemplate                      func(childComplexity int, in FormationTemplateInput) int
		CreateLabelDefinition                        func(childComplexity int, in LabelDefinitionInput) int
		DeleteAPIDefinition                          func(childComplexity int, id string) int
		DeleteApplicationLabel                       func(childComplexity int, applicationID string, key string) int
		DeleteApplicationTemplate                    func(childComplexity int, id string) int
		DeleteBundle                                 func(childComplexity int, id string) int
		DeleteBundleInstanceAuth                     func(childComplexity int, authID string) int
		DeleteCertificateSubjectMapping              func(childComplexity int, id string) int
		DeleteDefaultEventingForApplication          func(childComplexity int, appID string) int
		DeleteDocument                               func(childComplexity int, id string) int
		DeleteEventDefinition                        func(childComplexity int, id string) int
		DeleteFormation                              func(childComplexity int, formation FormationInput) int
		DeleteFormationConstraint                    func(childComplexity int, id string) int
		DeleteFormationTemplate                      func(childComplexity int, id string) int
		DeleteIntegrationDependency                  func(childComplexity int, id string) int
		DeleteRuntimeLabel                           func(childComplexity int, runtimeID string, key string) int
		DeleteSystemAuthForApplication               func(childComplexity int, authID string) int
		DeleteSystemAuthForIntegrationSystem         func(childComplexity int, authID string) int
		DeleteSystemAuthForRuntime                   func(childComplexity int, authID string) int
		DeleteTenants                                func(childComplexity int, in []string) int
		DeleteWebhook                                func(childComplexity int, webhookID string) int
		DetachConstraintFromFormationTemplate        func(childComplexity int, constraintID string, formationTemplateID string) int
		FinalizeDraftFormation                       func(childComplexity int, formationID string) int
		InvalidateSystemAuthOneTimeToken             func(childComplexity int, authID string) int
		MergeApplications                            func(childComplexity int, destinationID string, sourceID string) int
		RefetchAPISpec                               func(childComplexity int, apiID string) int
		RefetchEventDefinitionSpec                   func(childComplexity int, eventID string) int
		RegisterApplication                          func(childComplexity int, in ApplicationRegisterInput, mode *OperationMode) int
		RegisterApplicationFromTemplate              func(childComplexity int, in ApplicationFromTemplateInput) int
		RegisterIntegrationSystem                    func(childComplexity int, in IntegrationSystemInput) int
		RegisterRuntime                              func(childComplexity int, in RuntimeRegisterInput) int
		RegisterRuntimeContext                       func(childComplexity int, runtimeID string, in RuntimeContextInput) int
		RemoveTenantAccess                           func(childComplexity int, tenantID string, resourceID string, resourceType TenantAccessObjectType) int
		RequestBundleInstanceAuthCreation            func(childComplexity int, bundleID string, in BundleInstanceAuthRequestInput) int
		RequestBundleInstanceAuthDeletion            func(childComplexity int, authID string) int
		RequestClientCredentialsForApplication       func(childComplexity int, id string) int
		RequestClientCredentialsForIntegrationSystem func(childComplexity int, id string) int
		RequestClientCredentialsForRuntime           func(childComplexity int, id string) int
		RequestOneTimeTokenForApplication            func(childComplexity int, id string, systemAuthID *string) int
		RequestOneTimeTokenForRuntime                func(childComplexity int, id string, systemAuthID *string) int
		ResynchronizeFormationNotifications          func(childComplexity int, formationID string, reset *bool) int
		SetApplicationLabel                          func(childComplexity int, applicationID string, key string, value interface{}) int
		SetBundleInstanceAuth                        func(childComplexity int, authID string, in BundleInstanceAuthSetInput) int
		SetDefaultEventingForApplication             func(childComplexity int, appID string, runtimeID string) int
		SetRuntimeLabel                              func(childComplexity int, runtimeID string, key string, value interface{}) int
		SetTenantLabel                               func(childComplexity int, tenantID string, key string, value interface{}) int
		SubscribeTenant                              func(childComplexity int, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionAppName string, subscriptionPayload string) int
		UnassignFormation                            func(childComplexity int, objectID string, objectType FormationObjectType, formation FormationInput) int
		UnassignFormationGlobal                      func(childComplexity int, objectID string, objectType FormationObjectType, formation string) int
		UnpairApplication                            func(childComplexity int, id string, mode *OperationMode) int
		UnregisterApplication                        func(childComplexity int, id string, mode *OperationMode) int
		UnregisterIntegrationSystem                  func(childComplexity int, id string) int
		UnregisterRuntime                            func(childComplexity int, id string) int
		UnregisterRuntimeContext                     func(childComplexity int, id string) int
		UnsubscribeTenant                            func(childComplexity int, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionPayload string) int
		UpdateAPIDefinition                          func(childComplexity int, id string, in APIDefinitionInput) int
		UpdateAPIDefinitionForApplication            func(childComplexity int, id string, in APIDefinitionInput) int
		UpdateApplication                            func(childComplexity int, id string, in ApplicationUpdateInput) int
		UpdateApplicationTemplate                    func(childComplexity int, id string, override *bool, in ApplicationTemplateUpdateInput) int
		UpdateBundle                                 func(childComplexity int, id string, in BundleUpdateInput) int
		UpdateBundleInstanceAuth                     func(childComplexity int, id string, bundleID string, in BundleInstanceAuthUpdateInput) int
		UpdateCertificateSubjectMapping              func(childComplexity int, id string, in CertificateSubjectMappingInput) int
		UpdateEventDefinition                        func(childComplexity int, id string, in EventDefinitionInput) int
		UpdateEventDefinitionForApplication          func(childComplexity int, id string, in EventDefinitionInput) int
		UpdateFormationConstraint                    func(childComplexity int, id string, in FormationConstraintUpdateInput) int
		UpdateFormationTemplate                      func(childComplexity int, id string, in FormationTemplateInput) int
		UpdateIntegrationSystem                      func(childComplexity int, id string, in IntegrationSystemInput) int
		UpdateLabelDefinition                        func(childComplexity int, in LabelDefinitionInput) int
		UpdateRuntime                                func(childComplexity int, id string, in RuntimeUpdateInput) int
		UpdateRuntimeContext                         func(childComplexity int, id string, in RuntimeContextInput) int
		UpdateSystemAuth                             func(childComplexity int, authID string, in AuthInput) int
		UpdateTenant                                 func(childComplexity int, id string, in BusinessTenantMappingInput) int
		UpdateWebhook                                func(childComplexity int, webhookID string, in WebhookInput) int
		WriteTenant                                  func(childComplexity int, in BusinessTenantMappingInput) int
		WriteTenants                                 func(childComplexity int, in []*BusinessTenantMappingInput) int
	}

	OAuthCredentialData struct {
		ClientID     func(childComplexity int) int
		ClientSecret func(childComplexity int) int
		URL          func(childComplexity int) int
	}

	OneTimeTokenForApplication struct {
		ConnectorURL       func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		ExpiresAt          func(childComplexity int) int
		LegacyConnectorURL func(childComplexity int) int
		Raw                func(childComplexity int) int
		RawEncoded         func(childComplexity int) int
		ScenarioGroups     func(childComplexity int) int
		Token              func(childComplexity int) int
		Type               func(childComplexity int) int
		Used               func(childComplexity int) int
		UsedAt             func(childComplexity int) int
	}

	OneTimeTokenForRuntime struct {
		ConnectorURL func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		ExpiresAt    func(childComplexity int) int
		Raw          func(childComplexity int) int
		RawEncoded   func(childComplexity int) int
		Token        func(childComplexity int) int
		Type         func(childComplexity int) int
		Used         func(childComplexity int) int
		UsedAt       func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor   func(childComplexity int) int
		HasNextPage func(childComplexity int) int
		StartCursor func(childComplexity int) int
	}

	PlaceholderDefinition struct {
		Description func(childComplexity int) int
		JSONPath    func(childComplexity int) int
		Name        func(childComplexity int) int
		Optional    func(childComplexity int) int
	}

	Query struct {
		ApisForApplication                         func(childComplexity int, appID string, first *int, after *PageCursor) int
		Application                                func(childComplexity int, id string) int
		ApplicationByLocalTenantIDAndAppTemplateID func(childComplexity int, localTenantID string, applicationTemplateID string) int
		ApplicationBySystemNumber                  func(childComplexity int, systemNumber string) int
		ApplicationTemplate                        func(childComplexity int, id string) int
		ApplicationTemplates                       func(childComplexity int, filter []*LabelFilter, first *int, after *PageCursor) int
		Applications                               func(childComplexity int, filter []*LabelFilter, first *int, after *PageCursor) int
		ApplicationsForRuntime                     func(childComplexity int, runtimeID string, first *int, after *PageCursor) int
		AutomaticScenarioAssignmentForScenario     func(childComplexity int, scenarioName string) int
		AutomaticScenarioAssignments               func(childComplexity int, first *int, after *PageCursor) int
		AutomaticScenarioAssignmentsForSelector    func(childComplexity int, selector LabelSelectorInput) int
		BundleByInstanceAuth                       func(childComplexity int, authID string) int
		BundleInstanceAuth                         func(childComplexity int, id string) int
		CertificateSubjectMapping                  func(childComplexity int, id string) int
		CertificateSubjectMappings                 func(childComplexity int, first *int, after *PageCursor) int
		EventsForApplication                       func(childComplexity int, appID string, first *int, after *PageCursor) int
		Formation                                  func(childComplexity int, id string) int
		FormationByName                            func(childComplexity int, name string) int
		FormationConstraint                        func(childComplexity int, id string) int
		FormationConstraints                       func(childComplexity int) int
		FormationConstraintsByFormationType        func(childComplexity int, formationTemplateID string) int
		FormationTemplate                          func(childComplexity int, id string) int
		FormationTemplates                         func(childComplexity int, first *int, after *PageCursor) int
		FormationTemplatesByName                   func(childComplexity int, name string, first *int, after *PageCursor) int
		Formations                                 func(childComplexity int, first *int, after *PageCursor) int
		FormationsForObject                        func(childComplexity int, objectID string) int
		HealthChecks                               func(childComplexity int, types []HealthCheckType, origin *string, first *int, after *PageCursor) int
		IntegrationSystem                          func(childComplexity int, id string) int
		IntegrationSystems                         func(childComplexity int, first *int, after *PageCursor) int
		LabelDefinition                            func(childComplexity int, key string) int
		LabelDefinitions                           func(childComplexity int) int
		RootTenants                                func(childComplexity int, externalTenant string) int
		Runtime                                    func(childComplexity int, id string) int
		RuntimeByTokenIssuer                       func(childComplexity int, issuer string) int
		Runtimes                                   func(childComplexity int, filter []*LabelFilter, first *int, after *PageCursor) int
		SystemAuth                                 func(childComplexity int, id string) int
		SystemAuthByToken                          func(childComplexity int, token string) int
		TenantByExternalID                         func(childComplexity int, id string) int
		TenantByInternalID                         func(childComplexity int, id string) int
		TenantByLowestOwnerForResource             func(childComplexity int, id string, resource string) int
		Tenants                                    func(childComplexity int, first *int, after *PageCursor, searchTerm *string) int
		Viewer                                     func(childComplexity int) int
	}

	Runtime struct {
		ApplicationNamespace  func(childComplexity int) int
		Auths                 func(childComplexity int) int
		Description           func(childComplexity int) int
		EventingConfiguration func(childComplexity int) int
		ID                    func(childComplexity int) int
		Labels                func(childComplexity int, key *string) int
		Metadata              func(childComplexity int) int
		Name                  func(childComplexity int) int
		RuntimeContext        func(childComplexity int, id string) int
		RuntimeContexts       func(childComplexity int, first *int, after *PageCursor) int
		Status                func(childComplexity int) int
		Webhooks              func(childComplexity int) int
	}

	RuntimeContext struct {
		ID     func(childComplexity int) int
		Key    func(childComplexity int) int
		Labels func(childComplexity int, key *string) int
		Value  func(childComplexity int) int
	}

	RuntimeContextPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RuntimeEventingConfiguration struct {
		DefaultURL func(childComplexity int) int
	}

	RuntimeMetadata struct {
		CreationTimestamp func(childComplexity int) int
	}

	RuntimePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RuntimeStatus struct {
		Condition func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	RuntimeSystemAuth struct {
		Auth              func(childComplexity int) int
		ID                func(childComplexity int) int
		ReferenceObjectID func(childComplexity int) int
		TenantID          func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Tenant struct {
		ID          func(childComplexity int) int
		Initialized func(childComplexity int) int
		InternalID  func(childComplexity int) int
		Labels      func(childComplexity int, key *string) int
		Name        func(childComplexity int) int
		Parents     func(childComplexity int) int
		Provider    func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	TenantAccess struct {
		Owner        func(childComplexity int) int
		ResourceID   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		TenantID     func(childComplexity int) int
	}

	TenantPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Version struct {
		Deprecated      func(childComplexity int) int
		DeprecatedSince func(childComplexity int) int
		ForRemoval      func(childComplexity int) int
		Value           func(childComplexity int) int
	}

	Viewer struct {
		ID   func(childComplexity int) int
		Type func(childComplexity int) int
	}

	Webhook struct {
		ApplicationID         func(childComplexity int) int
		ApplicationTemplateID func(childComplexity int) int
		Auth                  func(childComplexity int) int
		CorrelationIDKey      func(childComplexity int) int
		CreatedAt             func(childComplexity int) int
		FormationTemplateID   func(childComplexity int) int
		HeaderTemplate        func(childComplexity int) int
		ID                    func(childComplexity int) int
		InputTemplate         func(childComplexity int) int
		IntegrationSystemID   func(childComplexity int) int
		Mode                  func(childComplexity int) int
		OutputTemplate        func(childComplexity int) int
		RetryInterval         func(childComplexity int) int
		RuntimeID             func(childComplexity int) int
		StatusTemplate        func(childComplexity int) int
		Timeout               func(childComplexity int) int
		Type                  func(childComplexity int) int
		URL                   func(childComplexity int) int
		URLTemplate           func(childComplexity int) int
	}
}

type APIDefinitionResolver interface {
	Spec(ctx context.Context, obj *APIDefinition) (*APISpec, error)
}
type APISpecResolver interface {
	FetchRequest(ctx context.Context, obj *APISpec) (*FetchRequest, error)
}
type ApplicationResolver interface {
	ApplicationTemplate(ctx context.Context, obj *Application) (*ApplicationTemplate, error)
	Labels(ctx context.Context, obj *Application, key *string) (Labels, error)

	Webhooks(ctx context.Context, obj *Application) ([]*Webhook, error)

	Bundles(ctx context.Context, obj *Application, first *int, after *PageCursor) (*BundlePage, error)
	Bundle(ctx context.Context, obj *Application, id string) (*Bundle, error)
	APIDefinition(ctx context.Context, obj *Application, id string) (*APIDefinition, error)
	EventDefinition(ctx context.Context, obj *Application, id string) (*EventDefinition, error)
	IntegrationDependencies(ctx context.Context, obj *Application, first *int, after *PageCursor) (*IntegrationDependencyPage, error)
	Auths(ctx context.Context, obj *Application) ([]*AppSystemAuth, error)
	EventingConfiguration(ctx context.Context, obj *Application) (*ApplicationEventingConfiguration, error)
}
type ApplicationTemplateResolver interface {
	Webhooks(ctx context.Context, obj *ApplicationTemplate) ([]*Webhook, error)

	Labels(ctx context.Context, obj *ApplicationTemplate, key *string) (Labels, error)
}
type BundleResolver interface {
	InstanceAuth(ctx context.Context, obj *Bundle, id string) (*BundleInstanceAuth, error)
	InstanceAuths(ctx context.Context, obj *Bundle) ([]*BundleInstanceAuth, error)

	APIDefinitions(ctx context.Context, obj *Bundle, group *string, first *int, after *PageCursor) (*APIDefinitionPage, error)
	EventDefinitions(ctx context.Context, obj *Bundle, group *string, first *int, after *PageCursor) (*EventDefinitionPage, error)
	Documents(ctx context.Context, obj *Bundle, first *int, after *PageCursor) (*DocumentPage, error)
	APIDefinition(ctx context.Context, obj *Bundle, id string) (*APIDefinition, error)
	EventDefinition(ctx context.Context, obj *Bundle, id string) (*EventDefinition, error)

	Document(ctx context.Context, obj *Bundle, id string) (*Document, error)
}
type DocumentResolver interface {
	FetchRequest(ctx context.Context, obj *Document) (*FetchRequest, error)
}
type EventDefinitionResolver interface {
	Spec(ctx context.Context, obj *EventDefinition) (*EventSpec, error)
}
type EventSpecResolver interface {
	FetchRequest(ctx context.Context, obj *EventSpec) (*FetchRequest, error)
}
type FormationResolver interface {
	FormationAssignment(ctx context.Context, obj *Formation, id string) (*FormationAssignment, error)
	FormationAssignments(ctx context.Context, obj *Formation, first *int, after *PageCursor) (*FormationAssignmentPage, error)
	Status(ctx context.Context, obj *Formation) (*FormationStatus, error)
}
type FormationAssignmentResolver interface {
	SourceEntity(ctx context.Context, obj *FormationAssignment) (FormationParticipant, error)

	TargetEntity(ctx context.Context, obj *FormationAssignment) (FormationParticipant, error)
}
type FormationTemplateResolver interface {
	Webhooks(ctx context.Context, obj *FormationTemplate) ([]*Webhook, error)

	FormationConstraints(ctx context.Context, obj *FormationTemplate) ([]*FormationConstraint, error)
}
type IntegrationSystemResolver interface {
	Auths(ctx context.Context, obj *IntegrationSystem) ([]*IntSysSystemAuth, error)
}
type MutationResolver interface {
	RegisterApplication(ctx context.Context, in ApplicationRegisterInput, mode *OperationMode) (*Application, error)
	UpdateApplication(ctx context.Context, id string, in ApplicationUpdateInput) (*Application, error)
	UnregisterApplication(ctx context.Context, id string, mode *OperationMode) (*Application, error)
	UnpairApplication(ctx context.Context, id string, mode *OperationMode) (*Application, error)
	CreateApplicationTemplate(ctx context.Context, in ApplicationTemplateInput) (*ApplicationTemplate, error)
	RegisterApplicationFromTemplate(ctx context.Context, in ApplicationFromTemplateInput) (*Application, error)
	UpdateApplicationTemplate(ctx context.Context, id string, override *bool, in ApplicationTemplateUpdateInput) (*ApplicationTemplate, error)
	DeleteApplicationTemplate(ctx context.Context, id string) (*ApplicationTemplate, error)
	MergeApplications(ctx context.Context, destinationID string, sourceID string) (*Application, error)
	RegisterRuntime(ctx context.Context, in RuntimeRegisterInput) (*Runtime, error)
	UpdateRuntime(ctx context.Context, id string, in RuntimeUpdateInput) (*Runtime, error)
	UnregisterRuntime(ctx context.Context, id string) (*Runtime, error)
	RegisterRuntimeContext(ctx context.Context, runtimeID string, in RuntimeContextInput) (*RuntimeContext, error)
	UpdateRuntimeContext(ctx context.Context, id string, in RuntimeContextInput) (*RuntimeContext, error)
	UnregisterRuntimeContext(ctx context.Context, id string) (*RuntimeContext, error)
	RegisterIntegrationSystem(ctx context.Context, in IntegrationSystemInput) (*IntegrationSystem, error)
	UpdateIntegrationSystem(ctx context.Context, id string, in IntegrationSystemInput) (*IntegrationSystem, error)
	UnregisterIntegrationSystem(ctx context.Context, id string) (*IntegrationSystem, error)
	AddWebhook(ctx context.Context, applicationID *string, applicationTemplateID *string, runtimeID *string, formationTemplateID *string, in WebhookInput) (*Webhook, error)
	UpdateWebhook(ctx context.Context, webhookID string, in WebhookInput) (*Webhook, error)
	DeleteWebhook(ctx context.Context, webhookID string) (*Webhook, error)
	AddAPIDefinitionToBundle(ctx context.Context, bundleID string, in APIDefinitionInput) (*APIDefinition, error)
	AddAPIDefinitionToApplication(ctx context.Context, appID string, in APIDefinitionInput) (*APIDefinition, error)
	UpdateAPIDefinition(ctx context.Context, id string, in APIDefinitionInput) (*APIDefinition, error)
	UpdateAPIDefinitionForApplication(ctx context.Context, id string, in APIDefinitionInput) (*APIDefinition, error)
	DeleteAPIDefinition(ctx context.Context, id string) (*APIDefinition, error)
	RefetchAPISpec(ctx context.Context, apiID string) (*APISpec, error)
	AddIntegrationDependencyToApplication(ctx context.Context, appID string, in IntegrationDependencyInput) (*IntegrationDependency, error)
	DeleteIntegrationDependency(ctx context.Context, id string) (*IntegrationDependency, error)
	RequestOneTimeTokenForRuntime(ctx context.Context, id string, systemAuthID *string) (*OneTimeTokenForRuntime, error)
	RequestOneTimeTokenForApplication(ctx context.Context, id string, systemAuthID *string) (*OneTimeTokenForApplication, error)
	RequestClientCredentialsForRuntime(ctx context.Context, id string) (SystemAuth, error)
	RequestClientCredentialsForApplication(ctx context.Context, id string) (SystemAuth, error)
	RequestClientCredentialsForIntegrationSystem(ctx context.Context, id string) (SystemAuth, error)
	DeleteSystemAuthForRuntime(ctx context.Context, authID string) (SystemAuth, error)
	DeleteSystemAuthForApplication(ctx context.Context, authID string) (SystemAuth, error)
	DeleteSystemAuthForIntegrationSystem(ctx context.Context, authID string) (SystemAuth, error)
	UpdateSystemAuth(ctx context.Context, authID string, in AuthInput) (SystemAuth, error)
	InvalidateSystemAuthOneTimeToken(ctx context.Context, authID string) (SystemAuth, error)
	AddEventDefinitionToBundle(ctx context.Context, bundleID string, in EventDefinitionInput) (*EventDefinition, error)
	AddEventDefinitionToApplication(ctx context.Context, appID string, in EventDefinitionInput) (*EventDefinition, error)
	UpdateEventDefinition(ctx context.Context, id string, in EventDefinitionInput) (*EventDefinition, error)
	UpdateEventDefinitionForApplication(ctx context.Context, id string, in EventDefinitionInput) (*EventDefinition, error)
	DeleteEventDefinition(ctx context.Context, id string) (*EventDefinition, error)
	RefetchEventDefinitionSpec(ctx context.Context, eventID string) (*EventSpec, error)
	AddDocumentToBundle(ctx context.Context, bundleID string, in DocumentInput) (*Document, error)
	DeleteDocument(ctx context.Context, id string) (*Document, error)
	CreateFormation(ctx context.Context, formation FormationInput) (*Formation, error)
	ResynchronizeFormationNotifications(ctx context.Context, formationID string, reset *bool) (*Formation, error)
	FinalizeDraftFormation(ctx context.Context, formationID string) (*Formation, error)
	DeleteFormation(ctx context.Context, formation FormationInput) (*Formation, error)
	AssignFormation(ctx context.Context, objectID string, objectType FormationObjectType, formation FormationInput) (*Formation, error)
	UnassignFormation(ctx context.Context, objectID string, objectType FormationObjectType, formation FormationInput) (*Formation, error)
	UnassignFormationGlobal(ctx context.Context, objectID string, objectType FormationObjectType, formation string) (*Formation, error)
	CreateFormationConstraint(ctx context.Context, formationConstraint FormationConstraintInput) (*FormationConstraint, error)
	DeleteFormationConstraint(ctx context.Context, id string) (*FormationConstraint, error)
	UpdateFormationConstraint(ctx context.Context, id string, in FormationConstraintUpdateInput) (*FormationConstraint, error)
	AttachConstraintToFormationTemplate(ctx context.Context, constraintID string, formationTemplateID string) (*ConstraintReference, error)
	DetachConstraintFromFormationTemplate(ctx context.Context, constraintID string, formationTemplateID string) (*ConstraintReference, error)
	CreateLabelDefinition(ctx context.Context, in LabelDefinitionInput) (*LabelDefinition, error)
	UpdateLabelDefinition(ctx context.Context, in LabelDefinitionInput) (*LabelDefinition, error)
	SetApplicationLabel(ctx context.Context, applicationID string, key string, value interface{}) (*Label, error)
	SetTenantLabel(ctx context.Context, tenantID string, key string, value interface{}) (*Label, error)
	DeleteApplicationLabel(ctx context.Context, applicationID string, key string) (*Label, error)
	SetRuntimeLabel(ctx context.Context, runtimeID string, key string, value interface{}) (*Label, error)
	DeleteRuntimeLabel(ctx context.Context, runtimeID string, key string) (*Label, error)
	SetDefaultEventingForApplication(ctx context.Context, appID string, runtimeID string) (*ApplicationEventingConfiguration, error)
	DeleteDefaultEventingForApplication(ctx context.Context, appID string) (*ApplicationEventingConfiguration, error)
	SetBundleInstanceAuth(ctx context.Context, authID string, in BundleInstanceAuthSetInput) (*BundleInstanceAuth, error)
	DeleteBundleInstanceAuth(ctx context.Context, authID string) (*BundleInstanceAuth, error)
	RequestBundleInstanceAuthCreation(ctx context.Context, bundleID string, in BundleInstanceAuthRequestInput) (*BundleInstanceAuth, error)
	RequestBundleInstanceAuthDeletion(ctx context.Context, authID string) (*BundleInstanceAuth, error)
	CreateBundleInstanceAuth(ctx context.Context, bundleID string, in BundleInstanceAuthCreateInput) (*BundleInstanceAuth, error)
	UpdateBundleInstanceAuth(ctx context.Context, id string, bundleID string, in BundleInstanceAuthUpdateInput) (*BundleInstanceAuth, error)
	AddBundle(ctx context.Context, applicationID string, in BundleCreateInput) (*Bundle, error)
	UpdateBundle(ctx context.Context, id string, in BundleUpdateInput) (*Bundle, error)
	DeleteBundle(ctx context.Context, id string) (*Bundle, error)
	WriteTenants(ctx context.Context, in []*BusinessTenantMappingInput) ([]string, error)
	WriteTenant(ctx context.Context, in BusinessTenantMappingInput) (string, error)
	DeleteTenants(ctx context.Context, in []string) (int, error)
	UpdateTenant(ctx context.Context, id string, in BusinessTenantMappingInput) (*Tenant, error)
	SubscribeTenant(ctx context.Context, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionAppName string, subscriptionPayload string) (bool, error)
	UnsubscribeTenant(ctx context.Context, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionPayload string) (bool, error)
	CreateFormationTemplate(ctx context.Context, in FormationTemplateInput) (*FormationTemplate, error)
	DeleteFormationTemplate(ctx context.Context, id string) (*FormationTemplate, error)
	UpdateFormationTemplate(ctx context.Context, id string, in FormationTemplateInput) (*FormationTemplate, error)
	CreateCertificateSubjectMapping(ctx context.Context, in CertificateSubjectMappingInput) (*CertificateSubjectMapping, error)
	UpdateCertificateSubjectMapping(ctx context.Context, id string, in CertificateSubjectMappingInput) (*CertificateSubjectMapping, error)
	DeleteCertificateSubjectMapping(ctx context.Context, id string) (*CertificateSubjectMapping, error)
	AddTenantAccess(ctx context.Context, in TenantAccessInput) (*TenantAccess, error)
	RemoveTenantAccess(ctx context.Context, tenantID string, resourceID string, resourceType TenantAccessObjectType) (*TenantAccess, error)
}
type OneTimeTokenForApplicationResolver interface {
	Raw(ctx context.Context, obj *OneTimeTokenForApplication) (*string, error)
	RawEncoded(ctx context.Context, obj *OneTimeTokenForApplication) (*string, error)
}
type OneTimeTokenForRuntimeResolver interface {
	Raw(ctx context.Context, obj *OneTimeTokenForRuntime) (*string, error)
	RawEncoded(ctx context.Context, obj *OneTimeTokenForRuntime) (*string, error)
}
type QueryResolver interface {
	ApisForApplication(ctx context.Context, appID string, first *int, after *PageCursor) (*APIDefinitionPage, error)
	EventsForApplication(ctx context.Context, appID string, first *int, after *PageCursor) (*EventDefinitionPage, error)
	Applications(ctx context.Context, filter []*LabelFilter, first *int, after *PageCursor) (*ApplicationPage, error)
	Application(ctx context.Context, id string) (*Application, error)
	ApplicationBySystemNumber(ctx context.Context, systemNumber string) (*Application, error)
	ApplicationByLocalTenantIDAndAppTemplateID(ctx context.Context, localTenantID string, applicationTemplateID string) (*Application, error)
	ApplicationsForRuntime(ctx context.Context, runtimeID string, first *int, after *PageCursor) (*ApplicationPage, error)
	ApplicationTemplates(ctx context.Context, filter []*LabelFilter, first *int, after *PageCursor) (*ApplicationTemplatePage, error)
	ApplicationTemplate(ctx context.Context, id string) (*ApplicationTemplate, error)
	Runtimes(ctx context.Context, filter []*LabelFilter, first *int, after *PageCursor) (*RuntimePage, error)
	Runtime(ctx context.Context, id string) (*Runtime, error)
	RuntimeByTokenIssuer(ctx context.Context, issuer string) (*Runtime, error)
	LabelDefinitions(ctx context.Context) ([]*LabelDefinition, error)
	LabelDefinition(ctx context.Context, key string) (*LabelDefinition, error)
	BundleByInstanceAuth(ctx context.Context, authID string) (*Bundle, error)
	BundleInstanceAuth(ctx context.Context, id string) (*BundleInstanceAuth, error)
	HealthChecks(ctx context.Context, types []HealthCheckType, origin *string, first *int, after *PageCursor) (*HealthCheckPage, error)
	IntegrationSystems(ctx context.Context, first *int, after *PageCursor) (*IntegrationSystemPage, error)
	IntegrationSystem(ctx context.Context, id string) (*IntegrationSystem, error)
	Viewer(ctx context.Context) (*Viewer, error)
	Tenants(ctx context.Context, first *int, after *PageCursor, searchTerm *string) (*TenantPage, error)
	TenantByExternalID(ctx context.Context, id string) (*Tenant, error)
	TenantByInternalID(ctx context.Context, id string) (*Tenant, error)
	TenantByLowestOwnerForResource(ctx context.Context, id string, resource string) (string, error)
	RootTenants(ctx context.Context, externalTenant string) ([]*Tenant, error)
	AutomaticScenarioAssignmentForScenario(ctx context.Context, scenarioName string) (*AutomaticScenarioAssignment, error)
	AutomaticScenarioAssignmentsForSelector(ctx context.Context, selector LabelSelectorInput) ([]*AutomaticScenarioAssignment, error)
	AutomaticScenarioAssignments(ctx context.Context, first *int, after *PageCursor) (*AutomaticScenarioAssignmentPage, error)
	SystemAuth(ctx context.Context, id string) (SystemAuth, error)
	SystemAuthByToken(ctx context.Context, token string) (SystemAuth, error)
	Formation(ctx context.Context, id string) (*Formation, error)
	FormationByName(ctx context.Context, name string) (*Formation, error)
	Formations(ctx context.Context, first *int, after *PageCursor) (*FormationPage, error)
	FormationsForObject(ctx context.Context, objectID string) ([]*Formation, error)
	FormationConstraints(ctx context.Context) ([]*FormationConstraint, error)
	FormationConstraint(ctx context.Context, id string) (*FormationConstraint, error)
	FormationConstraintsByFormationType(ctx context.Context, formationTemplateID string) ([]*FormationConstraint, error)
	FormationTemplate(ctx context.Context, id string) (*FormationTemplate, error)
	FormationTemplates(ctx context.Context, first *int, after *PageCursor) (*FormationTemplatePage, error)
	FormationTemplatesByName(ctx context.Context, name string, first *int, after *PageCursor) (*FormationTemplatePage, error)
	CertificateSubjectMapping(ctx context.Context, id string) (*CertificateSubjectMapping, error)
	CertificateSubjectMappings(ctx context.Context, first *int, after *PageCursor) (*CertificateSubjectMappingPage, error)
}
type RuntimeResolver interface {
	Labels(ctx context.Context, obj *Runtime, key *string) (Labels, error)
	Webhooks(ctx context.Context, obj *Runtime) ([]*Webhook, error)

	Auths(ctx context.Context, obj *Runtime) ([]*RuntimeSystemAuth, error)
	EventingConfiguration(ctx context.Context, obj *Runtime) (*RuntimeEventingConfiguration, error)
	RuntimeContext(ctx context.Context, obj *Runtime, id string) (*RuntimeContext, error)
	RuntimeContexts(ctx context.Context, obj *Runtime, first *int, after *PageCursor) (*RuntimeContextPage, error)
}
type RuntimeContextResolver interface {
	Labels(ctx context.Context, obj *RuntimeContext, key *string) (Labels, error)
}
type TenantResolver interface {
	Labels(ctx context.Context, obj *Tenant, key *string) (Labels, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "APIDefinition.created_at":
		if e.complexity.APIDefinition.CreatedAt == nil {
			break
		}

		return e.complexity.APIDefinition.CreatedAt(childComplexity), true

	case "APIDefinition.deleted_at":
		if e.complexity.APIDefinition.DeletedAt == nil {
			break
		}

		return e.complexity.APIDefinition.DeletedAt(childComplexity), true

	case "APIDefinition.description":
		if e.complexity.APIDefinition.Description == nil {
			break
		}

		return e.complexity.APIDefinition.Description(childComplexity), true

	case "APIDefinition.error":
		if e.complexity.APIDefinition.Error == nil {
			break
		}

		return e.complexity.APIDefinition.Error(childComplexity), true

	case "APIDefinition.group":
		if e.complexity.APIDefinition.Group == nil {
			break
		}

		return e.complexity.APIDefinition.Group(childComplexity), true

	case "APIDefinition.id":
		if e.complexity.APIDefinition.ID == nil {
			break
		}

		return e.complexity.APIDefinition.ID(childComplexity), true

	case "APIDefinition.name":
		if e.complexity.APIDefinition.Name == nil {
			break
		}

		return e.complexity.APIDefinition.Name(childComplexity), true

	case "APIDefinition.spec":
		if e.complexity.APIDefinition.Spec == nil {
			break
		}

		return e.complexity.APIDefinition.Spec(childComplexity), true

	case "APIDefinition.targetURL":
		if e.complexity.APIDefinition.TargetURL == nil {
			break
		}

		return e.complexity.APIDefinition.TargetURL(childComplexity), true

	case "APIDefinition.updated_at":
		if e.complexity.APIDefinition.UpdatedAt == nil {
			break
		}

		return e.complexity.APIDefinition.UpdatedAt(childComplexity), true

	case "APIDefinition.version":
		if e.complexity.APIDefinition.Version == nil {
			break
		}

		return e.complexity.APIDefinition.Version(childComplexity), true

	case "APIDefinitionPage.data":
		if e.complexity.APIDefinitionPage.Data == nil {
			break
		}

		return e.complexity.APIDefinitionPage.Data(childComplexity), true

	case "APIDefinitionPage.pageInfo":
		if e.complexity.APIDefinitionPage.PageInfo == nil {
			break
		}

		return e.complexity.APIDefinitionPage.PageInfo(childComplexity), true

	case "APIDefinitionPage.totalCount":
		if e.complexity.APIDefinitionPage.TotalCount == nil {
			break
		}

		return e.complexity.APIDefinitionPage.TotalCount(childComplexity), true

	case "APISpec.data":
		if e.complexity.APISpec.Data == nil {
			break
		}

		return e.complexity.APISpec.Data(childComplexity), true

	case "APISpec.fetchRequest":
		if e.complexity.APISpec.FetchRequest == nil {
			break
		}

		return e.complexity.APISpec.FetchRequest(childComplexity), true

	case "APISpec.format":
		if e.complexity.APISpec.Format == nil {
			break
		}

		return e.complexity.APISpec.Format(childComplexity), true

	case "APISpec.id":
		if e.complexity.APISpec.ID == nil {
			break
		}

		return e.complexity.APISpec.ID(childComplexity), true

	case "APISpec.type":
		if e.complexity.APISpec.Type == nil {
			break
		}

		return e.complexity.APISpec.Type(childComplexity), true

	case "AppSystemAuth.auth":
		if e.complexity.AppSystemAuth.Auth == nil {
			break
		}

		return e.complexity.AppSystemAuth.Auth(childComplexity), true

	case "AppSystemAuth.id":
		if e.complexity.AppSystemAuth.ID == nil {
			break
		}

		return e.complexity.AppSystemAuth.ID(childComplexity), true

	case "AppSystemAuth.referenceObjectId":
		if e.complexity.AppSystemAuth.ReferenceObjectID == nil {
			break
		}

		return e.complexity.AppSystemAuth.ReferenceObjectID(childComplexity), true

	case "AppSystemAuth.tenantId":
		if e.complexity.AppSystemAuth.TenantID == nil {
			break
		}

		return e.complexity.AppSystemAuth.TenantID(childComplexity), true

	case "AppSystemAuth.type":
		if e.complexity.AppSystemAuth.Type == nil {
			break
		}

		return e.complexity.AppSystemAuth.Type(childComplexity), true

	case "Application.apiDefinition":
		if e.complexity.Application.APIDefinition == nil {
			break
		}

		args, err := ec.field_Application_apiDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.APIDefinition(childComplexity, args["id"].(string)), true

	case "Application.applicationNamespace":
		if e.complexity.Application.ApplicationNamespace == nil {
			break
		}

		return e.complexity.Application.ApplicationNamespace(childComplexity), true

	case "Application.applicationTemplate":
		if e.complexity.Application.ApplicationTemplate == nil {
			break
		}

		return e.complexity.Application.ApplicationTemplate(childComplexity), true

	case "Application.applicationTemplateID":
		if e.complexity.Application.ApplicationTemplateID == nil {
			break
		}

		return e.complexity.Application.ApplicationTemplateID(childComplexity), true

	case "Application.auths":
		if e.complexity.Application.Auths == nil {
			break
		}

		return e.complexity.Application.Auths(childComplexity), true

	case "Application.baseUrl":
		if e.complexity.Application.BaseURL == nil {
			break
		}

		return e.complexity.Application.BaseURL(childComplexity), true

	case "Application.bundle":
		if e.complexity.Application.Bundle == nil {
			break
		}

		args, err := ec.field_Application_bundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Bundle(childComplexity, args["id"].(string)), true

	case "Application.bundles":
		if e.complexity.Application.Bundles == nil {
			break
		}

		args, err := ec.field_Application_bundles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Bundles(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Application.createdAt":
		if e.complexity.Application.CreatedAt == nil {
			break
		}

		return e.complexity.Application.CreatedAt(childComplexity), true

	case "Application.deletedAt":
		if e.complexity.Application.DeletedAt == nil {
			break
		}

		return e.complexity.Application.DeletedAt(childComplexity), true

	case "Application.description":
		if e.complexity.Application.Description == nil {
			break
		}

		return e.complexity.Application.Description(childComplexity), true

	case "Application.error":
		if e.complexity.Application.Error == nil {
			break
		}

		return e.complexity.Application.Error(childComplexity), true

	case "Application.eventDefinition":
		if e.complexity.Application.EventDefinition == nil {
			break
		}

		args, err := ec.field_Application_eventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.EventDefinition(childComplexity, args["id"].(string)), true

	case "Application.eventingConfiguration":
		if e.complexity.Application.EventingConfiguration == nil {
			break
		}

		return e.complexity.Application.EventingConfiguration(childComplexity), true

	case "Application.healthCheckURL":
		if e.complexity.Application.HealthCheckURL == nil {
			break
		}

		return e.complexity.Application.HealthCheckURL(childComplexity), true

	case "Application.id":
		if e.complexity.Application.ID == nil {
			break
		}

		return e.complexity.Application.ID(childComplexity), true

	case "Application.integrationDependencies":
		if e.complexity.Application.IntegrationDependencies == nil {
			break
		}

		args, err := ec.field_Application_integrationDependencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.IntegrationDependencies(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Application.integrationSystemID":
		if e.complexity.Application.IntegrationSystemID == nil {
			break
		}

		return e.complexity.Application.IntegrationSystemID(childComplexity), true

	case "Application.labels":
		if e.complexity.Application.Labels == nil {
			break
		}

		args, err := ec.field_Application_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Labels(childComplexity, args["key"].(*string)), true

	case "Application.localTenantID":
		if e.complexity.Application.LocalTenantID == nil {
			break
		}

		return e.complexity.Application.LocalTenantID(childComplexity), true

	case "Application.name":
		if e.complexity.Application.Name == nil {
			break
		}

		return e.complexity.Application.Name(childComplexity), true

	case "Application.providerName":
		if e.complexity.Application.ProviderName == nil {
			break
		}

		return e.complexity.Application.ProviderName(childComplexity), true

	case "Application.status":
		if e.complexity.Application.Status == nil {
			break
		}

		return e.complexity.Application.Status(childComplexity), true

	case "Application.systemNumber":
		if e.complexity.Application.SystemNumber == nil {
			break
		}

		return e.complexity.Application.SystemNumber(childComplexity), true

	case "Application.systemStatus":
		if e.complexity.Application.SystemStatus == nil {
			break
		}

		return e.complexity.Application.SystemStatus(childComplexity), true

	case "Application.updatedAt":
		if e.complexity.Application.UpdatedAt == nil {
			break
		}

		return e.complexity.Application.UpdatedAt(childComplexity), true

	case "Application.webhooks":
		if e.complexity.Application.Webhooks == nil {
			break
		}

		return e.complexity.Application.Webhooks(childComplexity), true

	case "ApplicationEventingConfiguration.defaultURL":
		if e.complexity.ApplicationEventingConfiguration.DefaultURL == nil {
			break
		}

		return e.complexity.ApplicationEventingConfiguration.DefaultURL(childComplexity), true

	case "ApplicationPage.data":
		if e.complexity.ApplicationPage.Data == nil {
			break
		}

		return e.complexity.ApplicationPage.Data(childComplexity), true

	case "ApplicationPage.pageInfo":
		if e.complexity.ApplicationPage.PageInfo == nil {
			break
		}

		return e.complexity.ApplicationPage.PageInfo(childComplexity), true

	case "ApplicationPage.totalCount":
		if e.complexity.ApplicationPage.TotalCount == nil {
			break
		}

		return e.complexity.ApplicationPage.TotalCount(childComplexity), true

	case "ApplicationStatus.condition":
		if e.complexity.ApplicationStatus.Condition == nil {
			break
		}

		return e.complexity.ApplicationStatus.Condition(childComplexity), true

	case "ApplicationStatus.timestamp":
		if e.complexity.ApplicationStatus.Timestamp == nil {
			break
		}

		return e.complexity.ApplicationStatus.Timestamp(childComplexity), true

	case "ApplicationTemplate.accessLevel":
		if e.complexity.ApplicationTemplate.AccessLevel == nil {
			break
		}

		return e.complexity.ApplicationTemplate.AccessLevel(childComplexity), true

	case "ApplicationTemplate.applicationInput":
		if e.complexity.ApplicationTemplate.ApplicationInput == nil {
			break
		}

		return e.complexity.ApplicationTemplate.ApplicationInput(childComplexity), true

	case "ApplicationTemplate.applicationNamespace":
		if e.complexity.ApplicationTemplate.ApplicationNamespace == nil {
			break
		}

		return e.complexity.ApplicationTemplate.ApplicationNamespace(childComplexity), true

	case "ApplicationTemplate.createdAt":
		if e.complexity.ApplicationTemplate.CreatedAt == nil {
			break
		}

		return e.complexity.ApplicationTemplate.CreatedAt(childComplexity), true

	case "ApplicationTemplate.description":
		if e.complexity.ApplicationTemplate.Description == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Description(childComplexity), true

	case "ApplicationTemplate.id":
		if e.complexity.ApplicationTemplate.ID == nil {
			break
		}

		return e.complexity.ApplicationTemplate.ID(childComplexity), true

	case "ApplicationTemplate.labels":
		if e.complexity.ApplicationTemplate.Labels == nil {
			break
		}

		args, err := ec.field_ApplicationTemplate_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationTemplate.Labels(childComplexity, args["key"].(*string)), true

	case "ApplicationTemplate.name":
		if e.complexity.ApplicationTemplate.Name == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Name(childComplexity), true

	case "ApplicationTemplate.placeholders":
		if e.complexity.ApplicationTemplate.Placeholders == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Placeholders(childComplexity), true

	case "ApplicationTemplate.updatedAt":
		if e.complexity.ApplicationTemplate.UpdatedAt == nil {
			break
		}

		return e.complexity.ApplicationTemplate.UpdatedAt(childComplexity), true

	case "ApplicationTemplate.webhooks":
		if e.complexity.ApplicationTemplate.Webhooks == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Webhooks(childComplexity), true

	case "ApplicationTemplatePage.data":
		if e.complexity.ApplicationTemplatePage.Data == nil {
			break
		}

		return e.complexity.ApplicationTemplatePage.Data(childComplexity), true

	case "ApplicationTemplatePage.pageInfo":
		if e.complexity.ApplicationTemplatePage.PageInfo == nil {
			break
		}

		return e.complexity.ApplicationTemplatePage.PageInfo(childComplexity), true

	case "ApplicationTemplatePage.totalCount":
		if e.complexity.ApplicationTemplatePage.TotalCount == nil {
			break
		}

		return e.complexity.ApplicationTemplatePage.TotalCount(childComplexity), true

	case "Aspect.apiResources":
		if e.complexity.Aspect.APIResources == nil {
			break
		}

		return e.complexity.Aspect.APIResources(childComplexity), true

	case "Aspect.created_at":
		if e.complexity.Aspect.CreatedAt == nil {
			break
		}

		return e.complexity.Aspect.CreatedAt(childComplexity), true

	case "Aspect.deleted_at":
		if e.complexity.Aspect.DeletedAt == nil {
			break
		}

		return e.complexity.Aspect.DeletedAt(childComplexity), true

	case "Aspect.description":
		if e.complexity.Aspect.Description == nil {
			break
		}

		return e.complexity.Aspect.Description(childComplexity), true

	case "Aspect.error":
		if e.complexity.Aspect.Error == nil {
			break
		}

		return e.complexity.Aspect.Error(childComplexity), true

	case "Aspect.eventResources":
		if e.complexity.Aspect.EventResources == nil {
			break
		}

		return e.complexity.Aspect.EventResources(childComplexity), true

	case "Aspect.id":
		if e.complexity.Aspect.ID == nil {
			break
		}

		return e.complexity.Aspect.ID(childComplexity), true

	case "Aspect.mandatory":
		if e.complexity.Aspect.Mandatory == nil {
			break
		}

		return e.complexity.Aspect.Mandatory(childComplexity), true

	case "Aspect.name":
		if e.complexity.Aspect.Name == nil {
			break
		}

		return e.complexity.Aspect.Name(childComplexity), true

	case "Aspect.updated_at":
		if e.complexity.Aspect.UpdatedAt == nil {
			break
		}

		return e.complexity.Aspect.UpdatedAt(childComplexity), true

	case "AspectAPIDefinition.ordID":
		if e.complexity.AspectAPIDefinition.OrdID == nil {
			break
		}

		return e.complexity.AspectAPIDefinition.OrdID(childComplexity), true

	case "AspectEventDefinition.created_at":
		if e.complexity.AspectEventDefinition.CreatedAt == nil {
			break
		}

		return e.complexity.AspectEventDefinition.CreatedAt(childComplexity), true

	case "AspectEventDefinition.deleted_at":
		if e.complexity.AspectEventDefinition.DeletedAt == nil {
			break
		}

		return e.complexity.AspectEventDefinition.DeletedAt(childComplexity), true

	case "AspectEventDefinition.error":
		if e.complexity.AspectEventDefinition.Error == nil {
			break
		}

		return e.complexity.AspectEventDefinition.Error(childComplexity), true

	case "AspectEventDefinition.ordID":
		if e.complexity.AspectEventDefinition.OrdID == nil {
			break
		}

		return e.complexity.AspectEventDefinition.OrdID(childComplexity), true

	case "AspectEventDefinition.subset":
		if e.complexity.AspectEventDefinition.Subset == nil {
			break
		}

		return e.complexity.AspectEventDefinition.Subset(childComplexity), true

	case "AspectEventDefinition.updated_at":
		if e.complexity.AspectEventDefinition.UpdatedAt == nil {
			break
		}

		return e.complexity.AspectEventDefinition.UpdatedAt(childComplexity), true

	case "AspectEventDefinitionSubset.eventType":
		if e.complexity.AspectEventDefinitionSubset.EventType == nil {
			break
		}

		return e.complexity.AspectEventDefinitionSubset.EventType(childComplexity), true

	case "Auth.accessStrategy":
		if e.complexity.Auth.AccessStrategy == nil {
			break
		}

		return e.complexity.Auth.AccessStrategy(childComplexity), true

	case "Auth.additionalHeaders":
		if e.complexity.Auth.AdditionalHeaders == nil {
			break
		}

		return e.complexity.Auth.AdditionalHeaders(childComplexity), true

	case "Auth.additionalHeadersSerialized":
		if e.complexity.Auth.AdditionalHeadersSerialized == nil {
			break
		}

		return e.complexity.Auth.AdditionalHeadersSerialized(childComplexity), true

	case "Auth.additionalQueryParams":
		if e.complexity.Auth.AdditionalQueryParams == nil {
			break
		}

		return e.complexity.Auth.AdditionalQueryParams(childComplexity), true

	case "Auth.additionalQueryParamsSerialized":
		if e.complexity.Auth.AdditionalQueryParamsSerialized == nil {
			break
		}

		return e.complexity.Auth.AdditionalQueryParamsSerialized(childComplexity), true

	case "Auth.certCommonName":
		if e.complexity.Auth.CertCommonName == nil {
			break
		}

		return e.complexity.Auth.CertCommonName(childComplexity), true

	case "Auth.credential":
		if e.complexity.Auth.Credential == nil {
			break
		}

		return e.complexity.Auth.Credential(childComplexity), true

	case "Auth.oneTimeToken":
		if e.complexity.Auth.OneTimeToken == nil {
			break
		}

		return e.complexity.Auth.OneTimeToken(childComplexity), true

	case "Auth.requestAuth":
		if e.complexity.Auth.RequestAuth == nil {
			break
		}

		return e.complexity.Auth.RequestAuth(childComplexity), true

	case "AutomaticScenarioAssignment.scenarioName":
		if e.complexity.AutomaticScenarioAssignment.ScenarioName == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignment.ScenarioName(childComplexity), true

	case "AutomaticScenarioAssignment.selector":
		if e.complexity.AutomaticScenarioAssignment.Selector == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignment.Selector(childComplexity), true

	case "AutomaticScenarioAssignmentPage.data":
		if e.complexity.AutomaticScenarioAssignmentPage.Data == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignmentPage.Data(childComplexity), true

	case "AutomaticScenarioAssignmentPage.pageInfo":
		if e.complexity.AutomaticScenarioAssignmentPage.PageInfo == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignmentPage.PageInfo(childComplexity), true

	case "AutomaticScenarioAssignmentPage.totalCount":
		if e.complexity.AutomaticScenarioAssignmentPage.TotalCount == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignmentPage.TotalCount(childComplexity), true

	case "BasicCredentialData.password":
		if e.complexity.BasicCredentialData.Password == nil {
			break
		}

		return e.complexity.BasicCredentialData.Password(childComplexity), true

	case "BasicCredentialData.username":
		if e.complexity.BasicCredentialData.Username == nil {
			break
		}

		return e.complexity.BasicCredentialData.Username(childComplexity), true

	case "Bundle.apiDefinition":
		if e.complexity.Bundle.APIDefinition == nil {
			break
		}

		args, err := ec.field_Bundle_apiDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.APIDefinition(childComplexity, args["id"].(string)), true

	case "Bundle.apiDefinitions":
		if e.complexity.Bundle.APIDefinitions == nil {
			break
		}

		args, err := ec.field_Bundle_apiDefinitions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.APIDefinitions(childComplexity, args["group"].(*string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Bundle.correlationIDs":
		if e.complexity.Bundle.CorrelationIDs == nil {
			break
		}

		return e.complexity.Bundle.CorrelationIDs(childComplexity), true

	case "Bundle.createdAt":
		if e.complexity.Bundle.CreatedAt == nil {
			break
		}

		return e.complexity.Bundle.CreatedAt(childComplexity), true

	case "Bundle.defaultInstanceAuth":
		if e.complexity.Bundle.DefaultInstanceAuth == nil {
			break
		}

		return e.complexity.Bundle.DefaultInstanceAuth(childComplexity), true

	case "Bundle.deletedAt":
		if e.complexity.Bundle.DeletedAt == nil {
			break
		}

		return e.complexity.Bundle.DeletedAt(childComplexity), true

	case "Bundle.description":
		if e.complexity.Bundle.Description == nil {
			break
		}

		return e.complexity.Bundle.Description(childComplexity), true

	case "Bundle.document":
		if e.complexity.Bundle.Document == nil {
			break
		}

		args, err := ec.field_Bundle_document_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.Document(childComplexity, args["id"].(string)), true

	case "Bundle.documents":
		if e.complexity.Bundle.Documents == nil {
			break
		}

		args, err := ec.field_Bundle_documents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.Documents(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Bundle.error":
		if e.complexity.Bundle.Error == nil {
			break
		}

		return e.complexity.Bundle.Error(childComplexity), true

	case "Bundle.eventDefinition":
		if e.complexity.Bundle.EventDefinition == nil {
			break
		}

		args, err := ec.field_Bundle_eventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.EventDefinition(childComplexity, args["id"].(string)), true

	case "Bundle.eventDefinitions":
		if e.complexity.Bundle.EventDefinitions == nil {
			break
		}

		args, err := ec.field_Bundle_eventDefinitions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.EventDefinitions(childComplexity, args["group"].(*string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Bundle.id":
		if e.complexity.Bundle.ID == nil {
			break
		}

		return e.complexity.Bundle.ID(childComplexity), true

	case "Bundle.instanceAuth":
		if e.complexity.Bundle.InstanceAuth == nil {
			break
		}

		args, err := ec.field_Bundle_instanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.InstanceAuth(childComplexity, args["id"].(string)), true

	case "Bundle.instanceAuthRequestInputSchema":
		if e.complexity.Bundle.InstanceAuthRequestInputSchema == nil {
			break
		}

		return e.complexity.Bundle.InstanceAuthRequestInputSchema(childComplexity), true

	case "Bundle.instanceAuths":
		if e.complexity.Bundle.InstanceAuths == nil {
			break
		}

		return e.complexity.Bundle.InstanceAuths(childComplexity), true

	case "Bundle.name":
		if e.complexity.Bundle.Name == nil {
			break
		}

		return e.complexity.Bundle.Name(childComplexity), true

	case "Bundle.updatedAt":
		if e.complexity.Bundle.UpdatedAt == nil {
			break
		}

		return e.complexity.Bundle.UpdatedAt(childComplexity), true

	case "BundleInstanceAuth.auth":
		if e.complexity.BundleInstanceAuth.Auth == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.Auth(childComplexity), true

	case "BundleInstanceAuth.context":
		if e.complexity.BundleInstanceAuth.Context == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.Context(childComplexity), true

	case "BundleInstanceAuth.id":
		if e.complexity.BundleInstanceAuth.ID == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.ID(childComplexity), true

	case "BundleInstanceAuth.inputParams":
		if e.complexity.BundleInstanceAuth.InputParams == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.InputParams(childComplexity), true

	case "BundleInstanceAuth.runtimeContextID":
		if e.complexity.BundleInstanceAuth.RuntimeContextID == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.RuntimeContextID(childComplexity), true

	case "BundleInstanceAuth.runtimeID":
		if e.complexity.BundleInstanceAuth.RuntimeID == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.RuntimeID(childComplexity), true

	case "BundleInstanceAuth.status":
		if e.complexity.BundleInstanceAuth.Status == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.Status(childComplexity), true

	case "BundleInstanceAuthStatus.condition":
		if e.complexity.BundleInstanceAuthStatus.Condition == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Condition(childComplexity), true

	case "BundleInstanceAuthStatus.message":
		if e.complexity.BundleInstanceAuthStatus.Message == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Message(childComplexity), true

	case "BundleInstanceAuthStatus.reason":
		if e.complexity.BundleInstanceAuthStatus.Reason == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Reason(childComplexity), true

	case "BundleInstanceAuthStatus.timestamp":
		if e.complexity.BundleInstanceAuthStatus.Timestamp == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Timestamp(childComplexity), true

	case "BundlePage.data":
		if e.complexity.BundlePage.Data == nil {
			break
		}

		return e.complexity.BundlePage.Data(childComplexity), true

	case "BundlePage.pageInfo":
		if e.complexity.BundlePage.PageInfo == nil {
			break
		}

		return e.complexity.BundlePage.PageInfo(childComplexity), true

	case "BundlePage.totalCount":
		if e.complexity.BundlePage.TotalCount == nil {
			break
		}

		return e.complexity.BundlePage.TotalCount(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalHeaders":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeaders == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeaders(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalHeadersSerialized":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeadersSerialized == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeadersSerialized(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalQueryParams":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParams == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParams(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalQueryParamsSerialized":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParamsSerialized == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParamsSerialized(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.credential":
		if e.complexity.CSRFTokenCredentialRequestAuth.Credential == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.Credential(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.tokenEndpointURL":
		if e.complexity.CSRFTokenCredentialRequestAuth.TokenEndpointURL == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.TokenEndpointURL(childComplexity), true

	case "CertificateOAuthCredentialData.certificate":
		if e.complexity.CertificateOAuthCredentialData.Certificate == nil {
			break
		}

		return e.complexity.CertificateOAuthCredentialData.Certificate(childComplexity), true

	case "CertificateOAuthCredentialData.clientId":
		if e.complexity.CertificateOAuthCredentialData.ClientID == nil {
			break
		}

		return e.complexity.CertificateOAuthCredentialData.ClientID(childComplexity), true

	case "CertificateOAuthCredentialData.url":
		if e.complexity.CertificateOAuthCredentialData.URL == nil {
			break
		}

		return e.complexity.CertificateOAuthCredentialData.URL(childComplexity), true

	case "CertificateSubjectMapping.consumerType":
		if e.complexity.CertificateSubjectMapping.ConsumerType == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.ConsumerType(childComplexity), true

	case "CertificateSubjectMapping.id":
		if e.complexity.CertificateSubjectMapping.ID == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.ID(childComplexity), true

	case "CertificateSubjectMapping.internalConsumerID":
		if e.complexity.CertificateSubjectMapping.InternalConsumerID == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.InternalConsumerID(childComplexity), true

	case "CertificateSubjectMapping.subject":
		if e.complexity.CertificateSubjectMapping.Subject == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.Subject(childComplexity), true

	case "CertificateSubjectMapping.tenantAccessLevels":
		if e.complexity.CertificateSubjectMapping.TenantAccessLevels == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.TenantAccessLevels(childComplexity), true

	case "CertificateSubjectMappingPage.data":
		if e.complexity.CertificateSubjectMappingPage.Data == nil {
			break
		}

		return e.complexity.CertificateSubjectMappingPage.Data(childComplexity), true

	case "CertificateSubjectMappingPage.pageInfo":
		if e.complexity.CertificateSubjectMappingPage.PageInfo == nil {
			break
		}

		return e.complexity.CertificateSubjectMappingPage.PageInfo(childComplexity), true

	case "CertificateSubjectMappingPage.totalCount":
		if e.complexity.CertificateSubjectMappingPage.TotalCount == nil {
			break
		}

		return e.complexity.CertificateSubjectMappingPage.TotalCount(childComplexity), true

	case "ConstraintReference.constraintID":
		if e.complexity.ConstraintReference.ConstraintID == nil {
			break
		}

		return e.complexity.ConstraintReference.ConstraintID(childComplexity), true

	case "ConstraintReference.formationTemplateID":
		if e.complexity.ConstraintReference.FormationTemplateID == nil {
			break
		}

		return e.complexity.ConstraintReference.FormationTemplateID(childComplexity), true

	case "CredentialRequestAuth.csrf":
		if e.complexity.CredentialRequestAuth.Csrf == nil {
			break
		}

		return e.complexity.CredentialRequestAuth.Csrf(childComplexity), true

	case "Document.createdAt":
		if e.complexity.Document.CreatedAt == nil {
			break
		}

		return e.complexity.Document.CreatedAt(childComplexity), true

	case "Document.data":
		if e.complexity.Document.Data == nil {
			break
		}

		return e.complexity.Document.Data(childComplexity), true

	case "Document.deletedAt":
		if e.complexity.Document.DeletedAt == nil {
			break
		}

		return e.complexity.Document.DeletedAt(childComplexity), true

	case "Document.description":
		if e.complexity.Document.Description == nil {
			break
		}

		return e.complexity.Document.Description(childComplexity), true

	case "Document.displayName":
		if e.complexity.Document.DisplayName == nil {
			break
		}

		return e.complexity.Document.DisplayName(childComplexity), true

	case "Document.error":
		if e.complexity.Document.Error == nil {
			break
		}

		return e.complexity.Document.Error(childComplexity), true

	case "Document.fetchRequest":
		if e.complexity.Document.FetchRequest == nil {
			break
		}

		return e.complexity.Document.FetchRequest(childComplexity), true

	case "Document.format":
		if e.complexity.Document.Format == nil {
			break
		}

		return e.complexity.Document.Format(childComplexity), true

	case "Document.id":
		if e.complexity.Document.ID == nil {
			break
		}

		return e.complexity.Document.ID(childComplexity), true

	case "Document.kind":
		if e.complexity.Document.Kind == nil {
			break
		}

		return e.complexity.Document.Kind(childComplexity), true

	case "Document.title":
		if e.complexity.Document.Title == nil {
			break
		}

		return e.complexity.Document.Title(childComplexity), true

	case "Document.updatedAt":
		if e.complexity.Document.UpdatedAt == nil {
			break
		}

		return e.complexity.Document.UpdatedAt(childComplexity), true

	case "DocumentPage.data":
		if e.complexity.DocumentPage.Data == nil {
			break
		}

		return e.complexity.DocumentPage.Data(childComplexity), true

	case "DocumentPage.pageInfo":
		if e.complexity.DocumentPage.PageInfo == nil {
			break
		}

		return e.complexity.DocumentPage.PageInfo(childComplexity), true

	case "DocumentPage.totalCount":
		if e.complexity.DocumentPage.TotalCount == nil {
			break
		}

		return e.complexity.DocumentPage.TotalCount(childComplexity), true

	case "EventDefinition.createdAt":
		if e.complexity.EventDefinition.CreatedAt == nil {
			break
		}

		return e.complexity.EventDefinition.CreatedAt(childComplexity), true

	case "EventDefinition.deletedAt":
		if e.complexity.EventDefinition.DeletedAt == nil {
			break
		}

		return e.complexity.EventDefinition.DeletedAt(childComplexity), true

	case "EventDefinition.description":
		if e.complexity.EventDefinition.Description == nil {
			break
		}

		return e.complexity.EventDefinition.Description(childComplexity), true

	case "EventDefinition.error":
		if e.complexity.EventDefinition.Error == nil {
			break
		}

		return e.complexity.EventDefinition.Error(childComplexity), true

	case "EventDefinition.group":
		if e.complexity.EventDefinition.Group == nil {
			break
		}

		return e.complexity.EventDefinition.Group(childComplexity), true

	case "EventDefinition.id":
		if e.complexity.EventDefinition.ID == nil {
			break
		}

		return e.complexity.EventDefinition.ID(childComplexity), true

	case "EventDefinition.name":
		if e.complexity.EventDefinition.Name == nil {
			break
		}

		return e.complexity.EventDefinition.Name(childComplexity), true

	case "EventDefinition.spec":
		if e.complexity.EventDefinition.Spec == nil {
			break
		}

		return e.complexity.EventDefinition.Spec(childComplexity), true

	case "EventDefinition.updatedAt":
		if e.complexity.EventDefinition.UpdatedAt == nil {
			break
		}

		return e.complexity.EventDefinition.UpdatedAt(childComplexity), true

	case "EventDefinition.version":
		if e.complexity.EventDefinition.Version == nil {
			break
		}

		return e.complexity.EventDefinition.Version(childComplexity), true

	case "EventDefinitionPage.data":
		if e.complexity.EventDefinitionPage.Data == nil {
			break
		}

		return e.complexity.EventDefinitionPage.Data(childComplexity), true

	case "EventDefinitionPage.pageInfo":
		if e.complexity.EventDefinitionPage.PageInfo == nil {
			break
		}

		return e.complexity.EventDefinitionPage.PageInfo(childComplexity), true

	case "EventDefinitionPage.totalCount":
		if e.complexity.EventDefinitionPage.TotalCount == nil {
			break
		}

		return e.complexity.EventDefinitionPage.TotalCount(childComplexity), true

	case "EventSpec.data":
		if e.complexity.EventSpec.Data == nil {
			break
		}

		return e.complexity.EventSpec.Data(childComplexity), true

	case "EventSpec.fetchRequest":
		if e.complexity.EventSpec.FetchRequest == nil {
			break
		}

		return e.complexity.EventSpec.FetchRequest(childComplexity), true

	case "EventSpec.format":
		if e.complexity.EventSpec.Format == nil {
			break
		}

		return e.complexity.EventSpec.Format(childComplexity), true

	case "EventSpec.id":
		if e.complexity.EventSpec.ID == nil {
			break
		}

		return e.complexity.EventSpec.ID(childComplexity), true

	case "EventSpec.type":
		if e.complexity.EventSpec.Type == nil {
			break
		}

		return e.complexity.EventSpec.Type(childComplexity), true

	case "FetchRequest.auth":
		if e.complexity.FetchRequest.Auth == nil {
			break
		}

		return e.complexity.FetchRequest.Auth(childComplexity), true

	case "FetchRequest.filter":
		if e.complexity.FetchRequest.Filter == nil {
			break
		}

		return e.complexity.FetchRequest.Filter(childComplexity), true

	case "FetchRequest.mode":
		if e.complexity.FetchRequest.Mode == nil {
			break
		}

		return e.complexity.FetchRequest.Mode(childComplexity), true

	case "FetchRequest.status":
		if e.complexity.FetchRequest.Status == nil {
			break
		}

		return e.complexity.FetchRequest.Status(childComplexity), true

	case "FetchRequest.url":
		if e.complexity.FetchRequest.URL == nil {
			break
		}

		return e.complexity.FetchRequest.URL(childComplexity), true

	case "FetchRequestStatus.condition":
		if e.complexity.FetchRequestStatus.Condition == nil {
			break
		}

		return e.complexity.FetchRequestStatus.Condition(childComplexity), true

	case "FetchRequestStatus.message":
		if e.complexity.FetchRequestStatus.Message == nil {
			break
		}

		return e.complexity.FetchRequestStatus.Message(childComplexity), true

	case "FetchRequestStatus.timestamp":
		if e.complexity.FetchRequestStatus.Timestamp == nil {
			break
		}

		return e.complexity.FetchRequestStatus.Timestamp(childComplexity), true

	case "Formation.error":
		if e.complexity.Formation.Error == nil {
			break
		}

		return e.complexity.Formation.Error(childComplexity), true

	case "Formation.formationAssignment":
		if e.complexity.Formation.FormationAssignment == nil {
			break
		}

		args, err := ec.field_Formation_formationAssignment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Formation.FormationAssignment(childComplexity, args["id"].(string)), true

	case "Formation.formationAssignments":
		if e.complexity.Formation.FormationAssignments == nil {
			break
		}

		args, err := ec.field_Formation_formationAssignments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Formation.FormationAssignments(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Formation.formationTemplateId":
		if e.complexity.Formation.FormationTemplateID == nil {
			break
		}

		return e.complexity.Formation.FormationTemplateID(childComplexity), true

	case "Formation.id":
		if e.complexity.Formation.ID == nil {
			break
		}

		return e.complexity.Formation.ID(childComplexity), true

	case "Formation.lastNotificationSentTimestamp":
		if e.complexity.Formation.LastNotificationSentTimestamp == nil {
			break
		}

		return e.complexity.Formation.LastNotificationSentTimestamp(childComplexity), true

	case "Formation.lastStateChangeTimestamp":
		if e.complexity.Formation.LastStateChangeTimestamp == nil {
			break
		}

		return e.complexity.Formation.LastStateChangeTimestamp(childComplexity), true

	case "Formation.name":
		if e.complexity.Formation.Name == nil {
			break
		}

		return e.complexity.Formation.Name(childComplexity), true

	case "Formation.state":
		if e.complexity.Formation.State == nil {
			break
		}

		return e.complexity.Formation.State(childComplexity), true

	case "Formation.status":
		if e.complexity.Formation.Status == nil {
			break
		}

		return e.complexity.Formation.Status(childComplexity), true

	case "Formation.tenantID":
		if e.complexity.Formation.TenantID == nil {
			break
		}

		return e.complexity.Formation.TenantID(childComplexity), true

	case "FormationAssignment.configuration":
		if e.complexity.FormationAssignment.Configuration == nil {
			break
		}

		return e.complexity.FormationAssignment.Configuration(childComplexity), true

	case "FormationAssignment.error":
		if e.complexity.FormationAssignment.Error == nil {
			break
		}

		return e.complexity.FormationAssignment.Error(childComplexity), true

	case "FormationAssignment.id":
		if e.complexity.FormationAssignment.ID == nil {
			break
		}

		return e.complexity.FormationAssignment.ID(childComplexity), true

	case "FormationAssignment.lastNotificationSentTimestamp":
		if e.complexity.FormationAssignment.LastNotificationSentTimestamp == nil {
			break
		}

		return e.complexity.FormationAssignment.LastNotificationSentTimestamp(childComplexity), true

	case "FormationAssignment.lastStateChangeTimestamp":
		if e.complexity.FormationAssignment.LastStateChangeTimestamp == nil {
			break
		}

		return e.complexity.FormationAssignment.LastStateChangeTimestamp(childComplexity), true

	case "FormationAssignment.source":
		if e.complexity.FormationAssignment.Source == nil {
			break
		}

		return e.complexity.FormationAssignment.Source(childComplexity), true

	case "FormationAssignment.sourceEntity":
		if e.complexity.FormationAssignment.SourceEntity == nil {
			break
		}

		return e.complexity.FormationAssignment.SourceEntity(childComplexity), true

	case "FormationAssignment.sourceType":
		if e.complexity.FormationAssignment.SourceType == nil {
			break
		}

		return e.complexity.FormationAssignment.SourceType(childComplexity), true

	case "FormationAssignment.state":
		if e.complexity.FormationAssignment.State == nil {
			break
		}

		return e.complexity.FormationAssignment.State(childComplexity), true

	case "FormationAssignment.target":
		if e.complexity.FormationAssignment.Target == nil {
			break
		}

		return e.complexity.FormationAssignment.Target(childComplexity), true

	case "FormationAssignment.targetEntity":
		if e.complexity.FormationAssignment.TargetEntity == nil {
			break
		}

		return e.complexity.FormationAssignment.TargetEntity(childComplexity), true

	case "FormationAssignment.targetType":
		if e.complexity.FormationAssignment.TargetType == nil {
			break
		}

		return e.complexity.FormationAssignment.TargetType(childComplexity), true

	case "FormationAssignment.value":
		if e.complexity.FormationAssignment.Value == nil {
			break
		}

		return e.complexity.FormationAssignment.Value(childComplexity), true

	case "FormationAssignmentPage.data":
		if e.complexity.FormationAssignmentPage.Data == nil {
			break
		}

		return e.complexity.FormationAssignmentPage.Data(childComplexity), true

	case "FormationAssignmentPage.pageInfo":
		if e.complexity.FormationAssignmentPage.PageInfo == nil {
			break
		}

		return e.complexity.FormationAssignmentPage.PageInfo(childComplexity), true

	case "FormationAssignmentPage.totalCount":
		if e.complexity.FormationAssignmentPage.TotalCount == nil {
			break
		}

		return e.complexity.FormationAssignmentPage.TotalCount(childComplexity), true

	case "FormationConstraint.constraintScope":
		if e.complexity.FormationConstraint.ConstraintScope == nil {
			break
		}

		return e.complexity.FormationConstraint.ConstraintScope(childComplexity), true

	case "FormationConstraint.constraintType":
		if e.complexity.FormationConstraint.ConstraintType == nil {
			break
		}

		return e.complexity.FormationConstraint.ConstraintType(childComplexity), true

	case "FormationConstraint.createdAt":
		if e.complexity.FormationConstraint.CreatedAt == nil {
			break
		}

		return e.complexity.FormationConstraint.CreatedAt(childComplexity), true

	case "FormationConstraint.description":
		if e.complexity.FormationConstraint.Description == nil {
			break
		}

		return e.complexity.FormationConstraint.Description(childComplexity), true

	case "FormationConstraint.id":
		if e.complexity.FormationConstraint.ID == nil {
			break
		}

		return e.complexity.FormationConstraint.ID(childComplexity), true

	case "FormationConstraint.inputTemplate":
		if e.complexity.FormationConstraint.InputTemplate == nil {
			break
		}

		return e.complexity.FormationConstraint.InputTemplate(childComplexity), true

	case "FormationConstraint.name":
		if e.complexity.FormationConstraint.Name == nil {
			break
		}

		return e.complexity.FormationConstraint.Name(childComplexity), true

	case "FormationConstraint.operator":
		if e.complexity.FormationConstraint.Operator == nil {
			break
		}

		return e.complexity.FormationConstraint.Operator(childComplexity), true

	case "FormationConstraint.priority":
		if e.complexity.FormationConstraint.Priority == nil {
			break
		}

		return e.complexity.FormationConstraint.Priority(childComplexity), true

	case "FormationConstraint.resourceSubtype":
		if e.complexity.FormationConstraint.ResourceSubtype == nil {
			break
		}

		return e.complexity.FormationConstraint.ResourceSubtype(childComplexity), true

	case "FormationConstraint.resourceType":
		if e.complexity.FormationConstraint.ResourceType == nil {
			break
		}

		return e.complexity.FormationConstraint.ResourceType(childComplexity), true

	case "FormationConstraint.targetOperation":
		if e.complexity.FormationConstraint.TargetOperation == nil {
			break
		}

		return e.complexity.FormationConstraint.TargetOperation(childComplexity), true

	case "FormationError.errorCode":
		if e.complexity.FormationError.ErrorCode == nil {
			break
		}

		return e.complexity.FormationError.ErrorCode(childComplexity), true

	case "FormationError.message":
		if e.complexity.FormationError.Message == nil {
			break
		}

		return e.complexity.FormationError.Message(childComplexity), true

	case "FormationPage.data":
		if e.complexity.FormationPage.Data == nil {
			break
		}

		return e.complexity.FormationPage.Data(childComplexity), true

	case "FormationPage.pageInfo":
		if e.complexity.FormationPage.PageInfo == nil {
			break
		}

		return e.complexity.FormationPage.PageInfo(childComplexity), true

	case "FormationPage.totalCount":
		if e.complexity.FormationPage.TotalCount == nil {
			break
		}

		return e.complexity.FormationPage.TotalCount(childComplexity), true

	case "FormationStatus.condition":
		if e.complexity.FormationStatus.Condition == nil {
			break
		}

		return e.complexity.FormationStatus.Condition(childComplexity), true

	case "FormationStatus.errors":
		if e.complexity.FormationStatus.Errors == nil {
			break
		}

		return e.complexity.FormationStatus.Errors(childComplexity), true

	case "FormationStatusError.assignmentID":
		if e.complexity.FormationStatusError.AssignmentID == nil {
			break
		}

		return e.complexity.FormationStatusError.AssignmentID(childComplexity), true

	case "FormationStatusError.errorCode":
		if e.complexity.FormationStatusError.ErrorCode == nil {
			break
		}

		return e.complexity.FormationStatusError.ErrorCode(childComplexity), true

	case "FormationStatusError.message":
		if e.complexity.FormationStatusError.Message == nil {
			break
		}

		return e.complexity.FormationStatusError.Message(childComplexity), true

	case "FormationTemplate.applicationTypes":
		if e.complexity.FormationTemplate.ApplicationTypes == nil {
			break
		}

		return e.complexity.FormationTemplate.ApplicationTypes(childComplexity), true

	case "FormationTemplate.discoveryConsumers":
		if e.complexity.FormationTemplate.DiscoveryConsumers == nil {
			break
		}

		return e.complexity.FormationTemplate.DiscoveryConsumers(childComplexity), true

	case "FormationTemplate.formationConstraints":
		if e.complexity.FormationTemplate.FormationConstraints == nil {
			break
		}

		return e.complexity.FormationTemplate.FormationConstraints(childComplexity), true

	case "FormationTemplate.id":
		if e.complexity.FormationTemplate.ID == nil {
			break
		}

		return e.complexity.FormationTemplate.ID(childComplexity), true

	case "FormationTemplate.leadingProductIDs":
		if e.complexity.FormationTemplate.LeadingProductIDs == nil {
			break
		}

		return e.complexity.FormationTemplate.LeadingProductIDs(childComplexity), true

	case "FormationTemplate.name":
		if e.complexity.FormationTemplate.Name == nil {
			break
		}

		return e.complexity.FormationTemplate.Name(childComplexity), true

	case "FormationTemplate.runtimeArtifactKind":
		if e.complexity.FormationTemplate.RuntimeArtifactKind == nil {
			break
		}

		return e.complexity.FormationTemplate.RuntimeArtifactKind(childComplexity), true

	case "FormationTemplate.runtimeTypeDisplayName":
		if e.complexity.FormationTemplate.RuntimeTypeDisplayName == nil {
			break
		}

		return e.complexity.FormationTemplate.RuntimeTypeDisplayName(childComplexity), true

	case "FormationTemplate.runtimeTypes":
		if e.complexity.FormationTemplate.RuntimeTypes == nil {
			break
		}

		return e.complexity.FormationTemplate.RuntimeTypes(childComplexity), true

	case "FormationTemplate.supportsReset":
		if e.complexity.FormationTemplate.SupportsReset == nil {
			break
		}

		return e.complexity.FormationTemplate.SupportsReset(childComplexity), true

	case "FormationTemplate.webhooks":
		if e.complexity.FormationTemplate.Webhooks == nil {
			break
		}

		return e.complexity.FormationTemplate.Webhooks(childComplexity), true

	case "FormationTemplatePage.data":
		if e.complexity.FormationTemplatePage.Data == nil {
			break
		}

		return e.complexity.FormationTemplatePage.Data(childComplexity), true

	case "FormationTemplatePage.pageInfo":
		if e.complexity.FormationTemplatePage.PageInfo == nil {
			break
		}

		return e.complexity.FormationTemplatePage.PageInfo(childComplexity), true

	case "FormationTemplatePage.totalCount":
		if e.complexity.FormationTemplatePage.TotalCount == nil {
			break
		}

		return e.complexity.FormationTemplatePage.TotalCount(childComplexity), true

	case "HealthCheck.condition":
		if e.complexity.HealthCheck.Condition == nil {
			break
		}

		return e.complexity.HealthCheck.Condition(childComplexity), true

	case "HealthCheck.message":
		if e.complexity.HealthCheck.Message == nil {
			break
		}

		return e.complexity.HealthCheck.Message(childComplexity), true

	case "HealthCheck.origin":
		if e.complexity.HealthCheck.Origin == nil {
			break
		}

		return e.complexity.HealthCheck.Origin(childComplexity), true

	case "HealthCheck.timestamp":
		if e.complexity.HealthCheck.Timestamp == nil {
			break
		}

		return e.complexity.HealthCheck.Timestamp(childComplexity), true

	case "HealthCheck.type":
		if e.complexity.HealthCheck.Type == nil {
			break
		}

		return e.complexity.HealthCheck.Type(childComplexity), true

	case "HealthCheckPage.data":
		if e.complexity.HealthCheckPage.Data == nil {
			break
		}

		return e.complexity.HealthCheckPage.Data(childComplexity), true

	case "HealthCheckPage.pageInfo":
		if e.complexity.HealthCheckPage.PageInfo == nil {
			break
		}

		return e.complexity.HealthCheckPage.PageInfo(childComplexity), true

	case "HealthCheckPage.totalCount":
		if e.complexity.HealthCheckPage.TotalCount == nil {
			break
		}

		return e.complexity.HealthCheckPage.TotalCount(childComplexity), true

	case "IntSysSystemAuth.auth":
		if e.complexity.IntSysSystemAuth.Auth == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.Auth(childComplexity), true

	case "IntSysSystemAuth.id":
		if e.complexity.IntSysSystemAuth.ID == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.ID(childComplexity), true

	case "IntSysSystemAuth.referenceObjectId":
		if e.complexity.IntSysSystemAuth.ReferenceObjectID == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.ReferenceObjectID(childComplexity), true

	case "IntSysSystemAuth.tenantId":
		if e.complexity.IntSysSystemAuth.TenantID == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.TenantID(childComplexity), true

	case "IntSysSystemAuth.type":
		if e.complexity.IntSysSystemAuth.Type == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.Type(childComplexity), true

	case "IntegrationDependency.aspects":
		if e.complexity.IntegrationDependency.Aspects == nil {
			break
		}

		return e.complexity.IntegrationDependency.Aspects(childComplexity), true

	case "IntegrationDependency.created_at":
		if e.complexity.IntegrationDependency.CreatedAt == nil {
			break
		}

		return e.complexity.IntegrationDependency.CreatedAt(childComplexity), true

	case "IntegrationDependency.deleted_at":
		if e.complexity.IntegrationDependency.DeletedAt == nil {
			break
		}

		return e.complexity.IntegrationDependency.DeletedAt(childComplexity), true

	case "IntegrationDependency.description":
		if e.complexity.IntegrationDependency.Description == nil {
			break
		}

		return e.complexity.IntegrationDependency.Description(childComplexity), true

	case "IntegrationDependency.error":
		if e.complexity.IntegrationDependency.Error == nil {
			break
		}

		return e.complexity.IntegrationDependency.Error(childComplexity), true

	case "IntegrationDependency.id":
		if e.complexity.IntegrationDependency.ID == nil {
			break
		}

		return e.complexity.IntegrationDependency.ID(childComplexity), true

	case "IntegrationDependency.labels":
		if e.complexity.IntegrationDependency.Labels == nil {
			break
		}

		return e.complexity.IntegrationDependency.Labels(childComplexity), true

	case "IntegrationDependency.mandatory":
		if e.complexity.IntegrationDependency.Mandatory == nil {
			break
		}

		return e.complexity.IntegrationDependency.Mandatory(childComplexity), true

	case "IntegrationDependency.name":
		if e.complexity.IntegrationDependency.Name == nil {
			break
		}

		return e.complexity.IntegrationDependency.Name(childComplexity), true

	case "IntegrationDependency.ordID":
		if e.complexity.IntegrationDependency.OrdID == nil {
			break
		}

		return e.complexity.IntegrationDependency.OrdID(childComplexity), true

	case "IntegrationDependency.partOfPackage":
		if e.complexity.IntegrationDependency.PartOfPackage == nil {
			break
		}

		return e.complexity.IntegrationDependency.PartOfPackage(childComplexity), true

	case "IntegrationDependency.releaseStatus":
		if e.complexity.IntegrationDependency.ReleaseStatus == nil {
			break
		}

		return e.complexity.IntegrationDependency.ReleaseStatus(childComplexity), true

	case "IntegrationDependency.updated_at":
		if e.complexity.IntegrationDependency.UpdatedAt == nil {
			break
		}

		return e.complexity.IntegrationDependency.UpdatedAt(childComplexity), true

	case "IntegrationDependency.version":
		if e.complexity.IntegrationDependency.Version == nil {
			break
		}

		return e.complexity.IntegrationDependency.Version(childComplexity), true

	case "IntegrationDependency.visibility":
		if e.complexity.IntegrationDependency.Visibility == nil {
			break
		}

		return e.complexity.IntegrationDependency.Visibility(childComplexity), true

	case "IntegrationDependencyPage.data":
		if e.complexity.IntegrationDependencyPage.Data == nil {
			break
		}

		return e.complexity.IntegrationDependencyPage.Data(childComplexity), true

	case "IntegrationDependencyPage.pageInfo":
		if e.complexity.IntegrationDependencyPage.PageInfo == nil {
			break
		}

		return e.complexity.IntegrationDependencyPage.PageInfo(childComplexity), true

	case "IntegrationDependencyPage.totalCount":
		if e.complexity.IntegrationDependencyPage.TotalCount == nil {
			break
		}

		return e.complexity.IntegrationDependencyPage.TotalCount(childComplexity), true

	case "IntegrationSystem.auths":
		if e.complexity.IntegrationSystem.Auths == nil {
			break
		}

		return e.complexity.IntegrationSystem.Auths(childComplexity), true

	case "IntegrationSystem.description":
		if e.complexity.IntegrationSystem.Description == nil {
			break
		}

		return e.complexity.IntegrationSystem.Description(childComplexity), true

	case "IntegrationSystem.id":
		if e.complexity.IntegrationSystem.ID == nil {
			break
		}

		return e.complexity.IntegrationSystem.ID(childComplexity), true

	case "IntegrationSystem.name":
		if e.complexity.IntegrationSystem.Name == nil {
			break
		}

		return e.complexity.IntegrationSystem.Name(childComplexity), true

	case "IntegrationSystemPage.data":
		if e.complexity.IntegrationSystemPage.Data == nil {
			break
		}

		return e.complexity.IntegrationSystemPage.Data(childComplexity), true

	case "IntegrationSystemPage.pageInfo":
		if e.complexity.IntegrationSystemPage.PageInfo == nil {
			break
		}

		return e.complexity.IntegrationSystemPage.PageInfo(childComplexity), true

	case "IntegrationSystemPage.totalCount":
		if e.complexity.IntegrationSystemPage.TotalCount == nil {
			break
		}

		return e.complexity.IntegrationSystemPage.TotalCount(childComplexity), true

	case "Label.key":
		if e.complexity.Label.Key == nil {
			break
		}

		return e.complexity.Label.Key(childComplexity), true

	case "Label.value":
		if e.complexity.Label.Value == nil {
			break
		}

		return e.complexity.Label.Value(childComplexity), true

	case "LabelDefinition.key":
		if e.complexity.LabelDefinition.Key == nil {
			break
		}

		return e.complexity.LabelDefinition.Key(childComplexity), true

	case "LabelDefinition.schema":
		if e.complexity.LabelDefinition.Schema == nil {
			break
		}

		return e.complexity.LabelDefinition.Schema(childComplexity), true

	case "Mutation.addAPIDefinitionToApplication":
		if e.complexity.Mutation.AddAPIDefinitionToApplication == nil {
			break
		}

		args, err := ec.field_Mutation_addAPIDefinitionToApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAPIDefinitionToApplication(childComplexity, args["appID"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.addAPIDefinitionToBundle":
		if e.complexity.Mutation.AddAPIDefinitionToBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addAPIDefinitionToBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAPIDefinitionToBundle(childComplexity, args["bundleID"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.addBundle":
		if e.complexity.Mutation.AddBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddBundle(childComplexity, args["applicationID"].(string), args["in"].(BundleCreateInput)), true

	case "Mutation.addDocumentToBundle":
		if e.complexity.Mutation.AddDocumentToBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addDocumentToBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddDocumentToBundle(childComplexity, args["bundleID"].(string), args["in"].(DocumentInput)), true

	case "Mutation.addEventDefinitionToApplication":
		if e.complexity.Mutation.AddEventDefinitionToApplication == nil {
			break
		}

		args, err := ec.field_Mutation_addEventDefinitionToApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventDefinitionToApplication(childComplexity, args["appID"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.addEventDefinitionToBundle":
		if e.complexity.Mutation.AddEventDefinitionToBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addEventDefinitionToBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventDefinitionToBundle(childComplexity, args["bundleID"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.addIntegrationDependencyToApplication":
		if e.complexity.Mutation.AddIntegrationDependencyToApplication == nil {
			break
		}

		args, err := ec.field_Mutation_addIntegrationDependencyToApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddIntegrationDependencyToApplication(childComplexity, args["appID"].(string), args["in"].(IntegrationDependencyInput)), true

	case "Mutation.addTenantAccess":
		if e.complexity.Mutation.AddTenantAccess == nil {
			break
		}

		args, err := ec.field_Mutation_addTenantAccess_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTenantAccess(childComplexity, args["in"].(TenantAccessInput)), true

	case "Mutation.addWebhook":
		if e.complexity.Mutation.AddWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_addWebhook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddWebhook(childComplexity, args["applicationID"].(*string), args["applicationTemplateID"].(*string), args["runtimeID"].(*string), args["formationTemplateID"].(*string), args["in"].(WebhookInput)), true

	case "Mutation.assignFormation":
		if e.complexity.Mutation.AssignFormation == nil {
			break
		}

		args, err := ec.field_Mutation_assignFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignFormation(childComplexity, args["objectID"].(string), args["objectType"].(FormationObjectType), args["formation"].(FormationInput)), true

	case "Mutation.attachConstraintToFormationTemplate":
		if e.complexity.Mutation.AttachConstraintToFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_attachConstraintToFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachConstraintToFormationTemplate(childComplexity, args["constraintID"].(string), args["formationTemplateID"].(string)), true

	case "Mutation.createApplicationTemplate":
		if e.complexity.Mutation.CreateApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_createApplicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApplicationTemplate(childComplexity, args["in"].(ApplicationTemplateInput)), true

	case "Mutation.createBundleInstanceAuth":
		if e.complexity.Mutation.CreateBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_createBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBundleInstanceAuth(childComplexity, args["bundleID"].(string), args["in"].(BundleInstanceAuthCreateInput)), true

	case "Mutation.createCertificateSubjectMapping":
		if e.complexity.Mutation.CreateCertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Mutation_createCertificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCertificateSubjectMapping(childComplexity, args["in"].(CertificateSubjectMappingInput)), true

	case "Mutation.createFormation":
		if e.complexity.Mutation.CreateFormation == nil {
			break
		}

		args, err := ec.field_Mutation_createFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFormation(childComplexity, args["formation"].(FormationInput)), true

	case "Mutation.createFormationConstraint":
		if e.complexity.Mutation.CreateFormationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_createFormationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFormationConstraint(childComplexity, args["formationConstraint"].(FormationConstraintInput)), true

	case "Mutation.createFormationTemplate":
		if e.complexity.Mutation.CreateFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_createFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFormationTemplate(childComplexity, args["in"].(FormationTemplateInput)), true

	case "Mutation.createLabelDefinition":
		if e.complexity.Mutation.CreateLabelDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_createLabelDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLabelDefinition(childComplexity, args["in"].(LabelDefinitionInput)), true

	case "Mutation.deleteAPIDefinition":
		if e.complexity.Mutation.DeleteAPIDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAPIDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAPIDefinition(childComplexity, args["id"].(string)), true

	case "Mutation.deleteApplicationLabel":
		if e.complexity.Mutation.DeleteApplicationLabel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApplicationLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplicationLabel(childComplexity, args["applicationID"].(string), args["key"].(string)), true

	case "Mutation.deleteApplicationTemplate":
		if e.complexity.Mutation.DeleteApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApplicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplicationTemplate(childComplexity, args["id"].(string)), true

	case "Mutation.deleteBundle":
		if e.complexity.Mutation.DeleteBundle == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBundle(childComplexity, args["id"].(string)), true

	case "Mutation.deleteBundleInstanceAuth":
		if e.complexity.Mutation.DeleteBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBundleInstanceAuth(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteCertificateSubjectMapping":
		if e.complexity.Mutation.DeleteCertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCertificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCertificateSubjectMapping(childComplexity, args["id"].(string)), true

	case "Mutation.deleteDefaultEventingForApplication":
		if e.complexity.Mutation.DeleteDefaultEventingForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDefaultEventingForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDefaultEventingForApplication(childComplexity, args["appID"].(string)), true

	case "Mutation.deleteDocument":
		if e.complexity.Mutation.DeleteDocument == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDocument_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDocument(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEventDefinition":
		if e.complexity.Mutation.DeleteEventDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventDefinition(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFormation":
		if e.complexity.Mutation.DeleteFormation == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFormation(childComplexity, args["formation"].(FormationInput)), true

	case "Mutation.deleteFormationConstraint":
		if e.complexity.Mutation.DeleteFormationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFormationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFormationConstraint(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFormationTemplate":
		if e.complexity.Mutation.DeleteFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFormationTemplate(childComplexity, args["id"].(string)), true

	case "Mutation.deleteIntegrationDependency":
		if e.complexity.Mutation.DeleteIntegrationDependency == nil {
			break
		}

		args, err := ec.field_Mutation_deleteIntegrationDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteIntegrationDependency(childComplexity, args["id"].(string)), true

	case "Mutation.deleteRuntimeLabel":
		if e.complexity.Mutation.DeleteRuntimeLabel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRuntimeLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRuntimeLabel(childComplexity, args["runtimeID"].(string), args["key"].(string)), true

	case "Mutation.deleteSystemAuthForApplication":
		if e.complexity.Mutation.DeleteSystemAuthForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSystemAuthForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSystemAuthForApplication(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteSystemAuthForIntegrationSystem":
		if e.complexity.Mutation.DeleteSystemAuthForIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSystemAuthForIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSystemAuthForIntegrationSystem(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteSystemAuthForRuntime":
		if e.complexity.Mutation.DeleteSystemAuthForRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSystemAuthForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSystemAuthForRuntime(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteTenants":
		if e.complexity.Mutation.DeleteTenants == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTenants(childComplexity, args["in"].([]string)), true

	case "Mutation.deleteWebhook":
		if e.complexity.Mutation.DeleteWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWebhook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWebhook(childComplexity, args["webhookID"].(string)), true

	case "Mutation.detachConstraintFromFormationTemplate":
		if e.complexity.Mutation.DetachConstraintFromFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_detachConstraintFromFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachConstraintFromFormationTemplate(childComplexity, args["constraintID"].(string), args["formationTemplateID"].(string)), true

	case "Mutation.finalizeDraftFormation":
		if e.complexity.Mutation.FinalizeDraftFormation == nil {
			break
		}

		args, err := ec.field_Mutation_finalizeDraftFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinalizeDraftFormation(childComplexity, args["formationID"].(string)), true

	case "Mutation.invalidateSystemAuthOneTimeToken":
		if e.complexity.Mutation.InvalidateSystemAuthOneTimeToken == nil {
			break
		}

		args, err := ec.field_Mutation_invalidateSystemAuthOneTimeToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InvalidateSystemAuthOneTimeToken(childComplexity, args["authID"].(string)), true

	case "Mutation.mergeApplications":
		if e.complexity.Mutation.MergeApplications == nil {
			break
		}

		args, err := ec.field_Mutation_mergeApplications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MergeApplications(childComplexity, args["destinationID"].(string), args["sourceID"].(string)), true

	case "Mutation.refetchAPISpec":
		if e.complexity.Mutation.RefetchAPISpec == nil {
			break
		}

		args, err := ec.field_Mutation_refetchAPISpec_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefetchAPISpec(childComplexity, args["apiID"].(string)), true

	case "Mutation.refetchEventDefinitionSpec":
		if e.complexity.Mutation.RefetchEventDefinitionSpec == nil {
			break
		}

		args, err := ec.field_Mutation_refetchEventDefinitionSpec_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefetchEventDefinitionSpec(childComplexity, args["eventID"].(string)), true

	case "Mutation.registerApplication":
		if e.complexity.Mutation.RegisterApplication == nil {
			break
		}

		args, err := ec.field_Mutation_registerApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterApplication(childComplexity, args["in"].(ApplicationRegisterInput), args["mode"].(*OperationMode)), true

	case "Mutation.registerApplicationFromTemplate":
		if e.complexity.Mutation.RegisterApplicationFromTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_registerApplicationFromTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterApplicationFromTemplate(childComplexity, args["in"].(ApplicationFromTemplateInput)), true

	case "Mutation.registerIntegrationSystem":
		if e.complexity.Mutation.RegisterIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_registerIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterIntegrationSystem(childComplexity, args["in"].(IntegrationSystemInput)), true

	case "Mutation.registerRuntime":
		if e.complexity.Mutation.RegisterRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_registerRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterRuntime(childComplexity, args["in"].(RuntimeRegisterInput)), true

	case "Mutation.registerRuntimeContext":
		if e.complexity.Mutation.RegisterRuntimeContext == nil {
			break
		}

		args, err := ec.field_Mutation_registerRuntimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterRuntimeContext(childComplexity, args["runtimeID"].(string), args["in"].(RuntimeContextInput)), true

	case "Mutation.removeTenantAccess":
		if e.complexity.Mutation.RemoveTenantAccess == nil {
			break
		}

		args, err := ec.field_Mutation_removeTenantAccess_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveTenantAccess(childComplexity, args["tenantID"].(string), args["resourceID"].(string), args["resourceType"].(TenantAccessObjectType)), true

	case "Mutation.requestBundleInstanceAuthCreation":
		if e.complexity.Mutation.RequestBundleInstanceAuthCreation == nil {
			break
		}

		args, err := ec.field_Mutation_requestBundleInstanceAuthCreation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestBundleInstanceAuthCreation(childComplexity, args["bundleID"].(string), args["in"].(BundleInstanceAuthRequestInput)), true

	case "Mutation.requestBundleInstanceAuthDeletion":
		if e.complexity.Mutation.RequestBundleInstanceAuthDeletion == nil {
			break
		}

		args, err := ec.field_Mutation_requestBundleInstanceAuthDeletion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestBundleInstanceAuthDeletion(childComplexity, args["authID"].(string)), true

	case "Mutation.requestClientCredentialsForApplication":
		if e.complexity.Mutation.RequestClientCredentialsForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_requestClientCredentialsForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestClientCredentialsForApplication(childComplexity, args["id"].(string)), true

	case "Mutation.requestClientCredentialsForIntegrationSystem":
		if e.complexity.Mutation.RequestClientCredentialsForIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_requestClientCredentialsForIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestClientCredentialsForIntegrationSystem(childComplexity, args["id"].(string)), true

	case "Mutation.requestClientCredentialsForRuntime":
		if e.complexity.Mutation.RequestClientCredentialsForRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_requestClientCredentialsForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestClientCredentialsForRuntime(childComplexity, args["id"].(string)), true

	case "Mutation.requestOneTimeTokenForApplication":
		if e.complexity.Mutation.RequestOneTimeTokenForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_requestOneTimeTokenForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestOneTimeTokenForApplication(childComplexity, args["id"].(string), args["systemAuthID"].(*string)), true

	case "Mutation.requestOneTimeTokenForRuntime":
		if e.complexity.Mutation.RequestOneTimeTokenForRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_requestOneTimeTokenForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestOneTimeTokenForRuntime(childComplexity, args["id"].(string), args["systemAuthID"].(*string)), true

	case "Mutation.resynchronizeFormationNotifications":
		if e.complexity.Mutation.ResynchronizeFormationNotifications == nil {
			break
		}

		args, err := ec.field_Mutation_resynchronizeFormationNotifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResynchronizeFormationNotifications(childComplexity, args["formationID"].(string), args["reset"].(*bool)), true

	case "Mutation.setApplicationLabel":
		if e.complexity.Mutation.SetApplicationLabel == nil {
			break
		}

		args, err := ec.field_Mutation_setApplicationLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetApplicationLabel(childComplexity, args["applicationID"].(string), args["key"].(string), args["value"].(interface{})), true

	case "Mutation.setBundleInstanceAuth":
		if e.complexity.Mutation.SetBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_setBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetBundleInstanceAuth(childComplexity, args["authID"].(string), args["in"].(BundleInstanceAuthSetInput)), true

	case "Mutation.setDefaultEventingForApplication":
		if e.complexity.Mutation.SetDefaultEventingForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_setDefaultEventingForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetDefaultEventingForApplication(childComplexity, args["appID"].(string), args["runtimeID"].(string)), true

	case "Mutation.setRuntimeLabel":
		if e.complexity.Mutation.SetRuntimeLabel == nil {
			break
		}

		args, err := ec.field_Mutation_setRuntimeLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetRuntimeLabel(childComplexity, args["runtimeID"].(string), args["key"].(string), args["value"].(interface{})), true

	case "Mutation.setTenantLabel":
		if e.complexity.Mutation.SetTenantLabel == nil {
			break
		}

		args, err := ec.field_Mutation_setTenantLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTenantLabel(childComplexity, args["tenantID"].(string), args["key"].(string), args["value"].(interface{})), true

	case "Mutation.subscribeTenant":
		if e.complexity.Mutation.SubscribeTenant == nil {
			break
		}

		args, err := ec.field_Mutation_subscribeTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SubscribeTenant(childComplexity, args["providerID"].(string), args["subaccountID"].(string), args["providerSubaccountID"].(string), args["consumerTenantID"].(string), args["region"].(string), args["subscriptionAppName"].(string), args["subscriptionPayload"].(string)), true

	case "Mutation.unassignFormation":
		if e.complexity.Mutation.UnassignFormation == nil {
			break
		}

		args, err := ec.field_Mutation_unassignFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignFormation(childComplexity, args["objectID"].(string), args["objectType"].(FormationObjectType), args["formation"].(FormationInput)), true

	case "Mutation.unassignFormationGlobal":
		if e.complexity.Mutation.UnassignFormationGlobal == nil {
			break
		}

		args, err := ec.field_Mutation_unassignFormationGlobal_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignFormationGlobal(childComplexity, args["objectID"].(string), args["objectType"].(FormationObjectType), args["formation"].(string)), true

	case "Mutation.unpairApplication":
		if e.complexity.Mutation.UnpairApplication == nil {
			break
		}

		args, err := ec.field_Mutation_unpairApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnpairApplication(childComplexity, args["id"].(string), args["mode"].(*OperationMode)), true

	case "Mutation.unregisterApplication":
		if e.complexity.Mutation.UnregisterApplication == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterApplication(childComplexity, args["id"].(string), args["mode"].(*OperationMode)), true

	case "Mutation.unregisterIntegrationSystem":
		if e.complexity.Mutation.UnregisterIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterIntegrationSystem(childComplexity, args["id"].(string)), true

	case "Mutation.unregisterRuntime":
		if e.complexity.Mutation.UnregisterRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterRuntime(childComplexity, args["id"].(string)), true

	case "Mutation.unregisterRuntimeContext":
		if e.complexity.Mutation.UnregisterRuntimeContext == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterRuntimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterRuntimeContext(childComplexity, args["id"].(string)), true

	case "Mutation.unsubscribeTenant":
		if e.complexity.Mutation.UnsubscribeTenant == nil {
			break
		}

		args, err := ec.field_Mutation_unsubscribeTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnsubscribeTenant(childComplexity, args["providerID"].(string), args["subaccountID"].(string), args["providerSubaccountID"].(string), args["consumerTenantID"].(string), args["region"].(string), args["subscriptionPayload"].(string)), true

	case "Mutation.updateAPIDefinition":
		if e.complexity.Mutation.UpdateAPIDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_updateAPIDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAPIDefinition(childComplexity, args["id"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.updateAPIDefinitionForApplication":
		if e.complexity.Mutation.UpdateAPIDefinitionForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_updateAPIDefinitionForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAPIDefinitionForApplication(childComplexity, args["id"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.updateApplication":
		if e.complexity.Mutation.UpdateApplication == nil {
			break
		}

		args, err := ec.field_Mutation_updateApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApplication(childComplexity, args["id"].(string), args["in"].(ApplicationUpdateInput)), true

	case "Mutation.updateApplicationTemplate":
		if e.complexity.Mutation.UpdateApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_updateApplicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApplicationTemplate(childComplexity, args["id"].(string), args["override"].(*bool), args["in"].(ApplicationTemplateUpdateInput)), true

	case "Mutation.updateBundle":
		if e.complexity.Mutation.UpdateBundle == nil {
			break
		}

		args, err := ec.field_Mutation_updateBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBundle(childComplexity, args["id"].(string), args["in"].(BundleUpdateInput)), true

	case "Mutation.updateBundleInstanceAuth":
		if e.complexity.Mutation.UpdateBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_updateBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBundleInstanceAuth(childComplexity, args["id"].(string), args["bundleID"].(string), args["in"].(BundleInstanceAuthUpdateInput)), true

	case "Mutation.updateCertificateSubjectMapping":
		if e.complexity.Mutation.UpdateCertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Mutation_updateCertificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCertificateSubjectMapping(childComplexity, args["id"].(string), args["in"].(CertificateSubjectMappingInput)), true

	case "Mutation.updateEventDefinition":
		if e.complexity.Mutation.UpdateEventDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventDefinition(childComplexity, args["id"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.updateEventDefinitionForApplication":
		if e.complexity.Mutation.UpdateEventDefinitionForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventDefinitionForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventDefinitionForApplication(childComplexity, args["id"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.updateFormationConstraint":
		if e.complexity.Mutation.UpdateFormationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_updateFormationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFormationConstraint(childComplexity, args["id"].(string), args["in"].(FormationConstraintUpdateInput)), true

	case "Mutation.updateFormationTemplate":
		if e.complexity.Mutation.UpdateFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_updateFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFormationTemplate(childComplexity, args["id"].(string), args["in"].(FormationTemplateInput)), true

	case "Mutation.updateIntegrationSystem":
		if e.complexity.Mutation.UpdateIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_updateIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateIntegrationSystem(childComplexity, args["id"].(string), args["in"].(IntegrationSystemInput)), true

	case "Mutation.updateLabelDefinition":
		if e.complexity.Mutation.UpdateLabelDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_updateLabelDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLabelDefinition(childComplexity, args["in"].(LabelDefinitionInput)), true

	case "Mutation.updateRuntime":
		if e.complexity.Mutation.UpdateRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_updateRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRuntime(childComplexity, args["id"].(string), args["in"].(RuntimeUpdateInput)), true

	case "Mutation.updateRuntimeContext":
		if e.complexity.Mutation.UpdateRuntimeContext == nil {
			break
		}

		args, err := ec.field_Mutation_updateRuntimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRuntimeContext(childComplexity, args["id"].(string), args["in"].(RuntimeContextInput)), true

	case "Mutation.updateSystemAuth":
		if e.complexity.Mutation.UpdateSystemAuth == nil {
			break
		}

		args, err := ec.field_Mutation_updateSystemAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSystemAuth(childComplexity, args["authID"].(string), args["in"].(AuthInput)), true

	case "Mutation.updateTenant":
		if e.complexity.Mutation.UpdateTenant == nil {
			break
		}

		args, err := ec.field_Mutation_updateTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTenant(childComplexity, args["id"].(string), args["in"].(BusinessTenantMappingInput)), true

	case "Mutation.updateWebhook":
		if e.complexity.Mutation.UpdateWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_updateWebhook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateWebhook(childComplexity, args["webhookID"].(string), args["in"].(WebhookInput)), true

	case "Mutation.writeTenant":
		if e.complexity.Mutation.WriteTenant == nil {
			break
		}

		args, err := ec.field_Mutation_writeTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.WriteTenant(childComplexity, args["in"].(BusinessTenantMappingInput)), true

	case "Mutation.writeTenants":
		if e.complexity.Mutation.WriteTenants == nil {
			break
		}

		args, err := ec.field_Mutation_writeTenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.WriteTenants(childComplexity, args["in"].([]*BusinessTenantMappingInput)), true

	case "OAuthCredentialData.clientId":
		if e.complexity.OAuthCredentialData.ClientID == nil {
			break
		}

		return e.complexity.OAuthCredentialData.ClientID(childComplexity), true

	case "OAuthCredentialData.clientSecret":
		if e.complexity.OAuthCredentialData.ClientSecret == nil {
			break
		}

		return e.complexity.OAuthCredentialData.ClientSecret(childComplexity), true

	case "OAuthCredentialData.url":
		if e.complexity.OAuthCredentialData.URL == nil {
			break
		}

		return e.complexity.OAuthCredentialData.URL(childComplexity), true

	case "OneTimeTokenForApplication.connectorURL":
		if e.complexity.OneTimeTokenForApplication.ConnectorURL == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.ConnectorURL(childComplexity), true

	case "OneTimeTokenForApplication.createdAt":
		if e.complexity.OneTimeTokenForApplication.CreatedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.CreatedAt(childComplexity), true

	case "OneTimeTokenForApplication.expiresAt":
		if e.complexity.OneTimeTokenForApplication.ExpiresAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.ExpiresAt(childComplexity), true

	case "OneTimeTokenForApplication.legacyConnectorURL":
		if e.complexity.OneTimeTokenForApplication.LegacyConnectorURL == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.LegacyConnectorURL(childComplexity), true

	case "OneTimeTokenForApplication.raw":
		if e.complexity.OneTimeTokenForApplication.Raw == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Raw(childComplexity), true

	case "OneTimeTokenForApplication.rawEncoded":
		if e.complexity.OneTimeTokenForApplication.RawEncoded == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.RawEncoded(childComplexity), true

	case "OneTimeTokenForApplication.scenarioGroups":
		if e.complexity.OneTimeTokenForApplication.ScenarioGroups == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.ScenarioGroups(childComplexity), true

	case "OneTimeTokenForApplication.token":
		if e.complexity.OneTimeTokenForApplication.Token == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Token(childComplexity), true

	case "OneTimeTokenForApplication.type":
		if e.complexity.OneTimeTokenForApplication.Type == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Type(childComplexity), true

	case "OneTimeTokenForApplication.used":
		if e.complexity.OneTimeTokenForApplication.Used == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Used(childComplexity), true

	case "OneTimeTokenForApplication.usedAt":
		if e.complexity.OneTimeTokenForApplication.UsedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.UsedAt(childComplexity), true

	case "OneTimeTokenForRuntime.connectorURL":
		if e.complexity.OneTimeTokenForRuntime.ConnectorURL == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.ConnectorURL(childComplexity), true

	case "OneTimeTokenForRuntime.createdAt":
		if e.complexity.OneTimeTokenForRuntime.CreatedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.CreatedAt(childComplexity), true

	case "OneTimeTokenForRuntime.expiresAt":
		if e.complexity.OneTimeTokenForRuntime.ExpiresAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.ExpiresAt(childComplexity), true

	case "OneTimeTokenForRuntime.raw":
		if e.complexity.OneTimeTokenForRuntime.Raw == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Raw(childComplexity), true

	case "OneTimeTokenForRuntime.rawEncoded":
		if e.complexity.OneTimeTokenForRuntime.RawEncoded == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.RawEncoded(childComplexity), true

	case "OneTimeTokenForRuntime.token":
		if e.complexity.OneTimeTokenForRuntime.Token == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Token(childComplexity), true

	case "OneTimeTokenForRuntime.type":
		if e.complexity.OneTimeTokenForRuntime.Type == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Type(childComplexity), true

	case "OneTimeTokenForRuntime.used":
		if e.complexity.OneTimeTokenForRuntime.Used == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Used(childComplexity), true

	case "OneTimeTokenForRuntime.usedAt":
		if e.complexity.OneTimeTokenForRuntime.UsedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.UsedAt(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PlaceholderDefinition.description":
		if e.complexity.PlaceholderDefinition.Description == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.Description(childComplexity), true

	case "PlaceholderDefinition.jsonPath":
		if e.complexity.PlaceholderDefinition.JSONPath == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.JSONPath(childComplexity), true

	case "PlaceholderDefinition.name":
		if e.complexity.PlaceholderDefinition.Name == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.Name(childComplexity), true

	case "PlaceholderDefinition.optional":
		if e.complexity.PlaceholderDefinition.Optional == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.Optional(childComplexity), true

	case "Query.apisForApplication":
		if e.complexity.Query.ApisForApplication == nil {
			break
		}

		args, err := ec.field_Query_apisForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApisForApplication(childComplexity, args["appID"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.application":
		if e.complexity.Query.Application == nil {
			break
		}

		args, err := ec.field_Query_application_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Application(childComplexity, args["id"].(string)), true

	case "Query.applicationByLocalTenantIDAndAppTemplateID":
		if e.complexity.Query.ApplicationByLocalTenantIDAndAppTemplateID == nil {
			break
		}

		args, err := ec.field_Query_applicationByLocalTenantIDAndAppTemplateID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationByLocalTenantIDAndAppTemplateID(childComplexity, args["localTenantID"].(string), args["applicationTemplateID"].(string)), true

	case "Query.applicationBySystemNumber":
		if e.complexity.Query.ApplicationBySystemNumber == nil {
			break
		}

		args, err := ec.field_Query_applicationBySystemNumber_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationBySystemNumber(childComplexity, args["systemNumber"].(string)), true

	case "Query.applicationTemplate":
		if e.complexity.Query.ApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Query_applicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationTemplate(childComplexity, args["id"].(string)), true

	case "Query.applicationTemplates":
		if e.complexity.Query.ApplicationTemplates == nil {
			break
		}

		args, err := ec.field_Query_applicationTemplates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationTemplates(childComplexity, args["filter"].([]*LabelFilter), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.applications":
		if e.complexity.Query.Applications == nil {
			break
		}

		args, err := ec.field_Query_applications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Applications(childComplexity, args["filter"].([]*LabelFilter), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.applicationsForRuntime":
		if e.complexity.Query.ApplicationsForRuntime == nil {
			break
		}

		args, err := ec.field_Query_applicationsForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationsForRuntime(childComplexity, args["runtimeID"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.automaticScenarioAssignmentForScenario":
		if e.complexity.Query.AutomaticScenarioAssignmentForScenario == nil {
			break
		}

		args, err := ec.field_Query_automaticScenarioAssignmentForScenario_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AutomaticScenarioAssignmentForScenario(childComplexity, args["scenarioName"].(string)), true

	case "Query.automaticScenarioAssignments":
		if e.complexity.Query.AutomaticScenarioAssignments == nil {
			break
		}

		args, err := ec.field_Query_automaticScenarioAssignments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AutomaticScenarioAssignments(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.automaticScenarioAssignmentsForSelector":
		if e.complexity.Query.AutomaticScenarioAssignmentsForSelector == nil {
			break
		}

		args, err := ec.field_Query_automaticScenarioAssignmentsForSelector_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AutomaticScenarioAssignmentsForSelector(childComplexity, args["selector"].(LabelSelectorInput)), true

	case "Query.bundleByInstanceAuth":
		if e.complexity.Query.BundleByInstanceAuth == nil {
			break
		}

		args, err := ec.field_Query_bundleByInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BundleByInstanceAuth(childComplexity, args["authID"].(string)), true

	case "Query.bundleInstanceAuth":
		if e.complexity.Query.BundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Query_bundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BundleInstanceAuth(childComplexity, args["id"].(string)), true

	case "Query.certificateSubjectMapping":
		if e.complexity.Query.CertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Query_certificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertificateSubjectMapping(childComplexity, args["id"].(string)), true

	case "Query.certificateSubjectMappings":
		if e.complexity.Query.CertificateSubjectMappings == nil {
			break
		}

		args, err := ec.field_Query_certificateSubjectMappings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertificateSubjectMappings(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.eventsForApplication":
		if e.complexity.Query.EventsForApplication == nil {
			break
		}

		args, err := ec.field_Query_eventsForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EventsForApplication(childComplexity, args["appID"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formation":
		if e.complexity.Query.Formation == nil {
			break
		}

		args, err := ec.field_Query_formation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Formation(childComplexity, args["id"].(string)), true

	case "Query.formationByName":
		if e.complexity.Query.FormationByName == nil {
			break
		}

		args, err := ec.field_Query_formationByName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationByName(childComplexity, args["name"].(string)), true

	case "Query.formationConstraint":
		if e.complexity.Query.FormationConstraint == nil {
			break
		}

		args, err := ec.field_Query_formationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationConstraint(childComplexity, args["id"].(string)), true

	case "Query.formationConstraints":
		if e.complexity.Query.FormationConstraints == nil {
			break
		}

		return e.complexity.Query.FormationConstraints(childComplexity), true

	case "Query.formationConstraintsByFormationType":
		if e.complexity.Query.FormationConstraintsByFormationType == nil {
			break
		}

		args, err := ec.field_Query_formationConstraintsByFormationType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationConstraintsByFormationType(childComplexity, args["formationTemplateID"].(string)), true

	case "Query.formationTemplate":
		if e.complexity.Query.FormationTemplate == nil {
			break
		}

		args, err := ec.field_Query_formationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationTemplate(childComplexity, args["id"].(string)), true

	case "Query.formationTemplates":
		if e.complexity.Query.FormationTemplates == nil {
			break
		}

		args, err := ec.field_Query_formationTemplates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationTemplates(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formationTemplatesByName":
		if e.complexity.Query.FormationTemplatesByName == nil {
			break
		}

		args, err := ec.field_Query_formationTemplatesByName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationTemplatesByName(childComplexity, args["name"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formations":
		if e.complexity.Query.Formations == nil {
			break
		}

		args, err := ec.field_Query_formations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Formations(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formationsForObject":
		if e.complexity.Query.FormationsForObject == nil {
			break
		}

		args, err := ec.field_Query_formationsForObject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationsForObject(childComplexity, args["objectID"].(string)), true

	case "Query.healthChecks":
		if e.complexity.Query.HealthChecks == nil {
			break
		}

		args, err := ec.field_Query_healthChecks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HealthChecks(childComplexity, args["types"].([]HealthCheckType), args["origin"].(*string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.integrationSystem":
		if e.complexity.Query.IntegrationSystem == nil {
			break
		}

		args, err := ec.field_Query_integrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IntegrationSystem(childComplexity, args["id"].(string)), true

	case "Query.integrationSystems":
		if e.complexity.Query.IntegrationSystems == nil {
			break
		}

		args, err := ec.field_Query_integrationSystems_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IntegrationSystems(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.labelDefinition":
		if e.complexity.Query.LabelDefinition == nil {
			break
		}

		args, err := ec.field_Query_labelDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LabelDefinition(childComplexity, args["key"].(string)), true

	case "Query.labelDefinitions":
		if e.complexity.Query.LabelDefinitions == nil {
			break
		}

		return e.complexity.Query.LabelDefinitions(childComplexity), true

	case "Query.rootTenants":
		if e.complexity.Query.RootTenants == nil {
			break
		}

		args, err := ec.field_Query_rootTenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RootTenants(childComplexity, args["externalTenant"].(string)), true

	case "Query.runtime":
		if e.complexity.Query.Runtime == nil {
			break
		}

		args, err := ec.field_Query_runtime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Runtime(childComplexity, args["id"].(string)), true

	case "Query.runtimeByTokenIssuer":
		if e.complexity.Query.RuntimeByTokenIssuer == nil {
			break
		}

		args, err := ec.field_Query_runtimeByTokenIssuer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RuntimeByTokenIssuer(childComplexity, args["issuer"].(string)), true

	case "Query.runtimes":
		if e.complexity.Query.Runtimes == nil {
			break
		}

		args, err := ec.field_Query_runtimes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Runtimes(childComplexity, args["filter"].([]*LabelFilter), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.systemAuth":
		if e.complexity.Query.SystemAuth == nil {
			break
		}

		args, err := ec.field_Query_systemAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SystemAuth(childComplexity, args["id"].(string)), true

	case "Query.systemAuthByToken":
		if e.complexity.Query.SystemAuthByToken == nil {
			break
		}

		args, err := ec.field_Query_systemAuthByToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SystemAuthByToken(childComplexity, args["token"].(string)), true

	case "Query.tenantByExternalID":
		if e.complexity.Query.TenantByExternalID == nil {
			break
		}

		args, err := ec.field_Query_tenantByExternalID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TenantByExternalID(childComplexity, args["id"].(string)), true

	case "Query.tenantByInternalID":
		if e.complexity.Query.TenantByInternalID == nil {
			break
		}

		args, err := ec.field_Query_tenantByInternalID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TenantByInternalID(childComplexity, args["id"].(string)), true

	case "Query.tenantByLowestOwnerForResource":
		if e.complexity.Query.TenantByLowestOwnerForResource == nil {
			break
		}

		args, err := ec.field_Query_tenantByLowestOwnerForResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TenantByLowestOwnerForResource(childComplexity, args["id"].(string), args["resource"].(string)), true

	case "Query.tenants":
		if e.complexity.Query.Tenants == nil {
			break
		}

		args, err := ec.field_Query_tenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tenants(childComplexity, args["first"].(*int), args["after"].(*PageCursor), args["searchTerm"].(*string)), true

	case "Query.viewer":
		if e.complexity.Query.Viewer == nil {
			break
		}

		return e.complexity.Query.Viewer(childComplexity), true

	case "Runtime.applicationNamespace":
		if e.complexity.Runtime.ApplicationNamespace == nil {
			break
		}

		return e.complexity.Runtime.ApplicationNamespace(childComplexity), true

	case "Runtime.auths":
		if e.complexity.Runtime.Auths == nil {
			break
		}

		return e.complexity.Runtime.Auths(childComplexity), true

	case "Runtime.description":
		if e.complexity.Runtime.Description == nil {
			break
		}

		return e.complexity.Runtime.Description(childComplexity), true

	case "Runtime.eventingConfiguration":
		if e.complexity.Runtime.EventingConfiguration == nil {
			break
		}

		return e.complexity.Runtime.EventingConfiguration(childComplexity), true

	case "Runtime.id":
		if e.complexity.Runtime.ID == nil {
			break
		}

		return e.complexity.Runtime.ID(childComplexity), true

	case "Runtime.labels":
		if e.complexity.Runtime.Labels == nil {
			break
		}

		args, err := ec.field_Runtime_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Runtime.Labels(childComplexity, args["key"].(*string)), true

	case "Runtime.metadata":
		if e.complexity.Runtime.Metadata == nil {
			break
		}

		return e.complexity.Runtime.Metadata(childComplexity), true

	case "Runtime.name":
		if e.complexity.Runtime.Name == nil {
			break
		}

		return e.complexity.Runtime.Name(childComplexity), true

	case "Runtime.runtimeContext":
		if e.complexity.Runtime.RuntimeContext == nil {
			break
		}

		args, err := ec.field_Runtime_runtimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Runtime.RuntimeContext(childComplexity, args["id"].(string)), true

	case "Runtime.runtimeContexts":
		if e.complexity.Runtime.RuntimeContexts == nil {
			break
		}

		args, err := ec.field_Runtime_runtimeContexts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Runtime.RuntimeContexts(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Runtime.status":
		if e.complexity.Runtime.Status == nil {
			break
		}

		return e.complexity.Runtime.Status(childComplexity), true

	case "Runtime.webhooks":
		if e.complexity.Runtime.Webhooks == nil {
			break
		}

		return e.complexity.Runtime.Webhooks(childComplexity), true

	case "RuntimeContext.id":
		if e.complexity.RuntimeContext.ID == nil {
			break
		}

		return e.complexity.RuntimeContext.ID(childComplexity), true

	case "RuntimeContext.key":
		if e.complexity.RuntimeContext.Key == nil {
			break
		}

		return e.complexity.RuntimeContext.Key(childComplexity), true

	case "RuntimeContext.labels":
		if e.complexity.RuntimeContext.Labels == nil {
			break
		}

		args, err := ec.field_RuntimeContext_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RuntimeContext.Labels(childComplexity, args["key"].(*string)), true

	case "RuntimeContext.value":
		if e.complexity.RuntimeContext.Value == nil {
			break
		}

		return e.complexity.RuntimeContext.Value(childComplexity), true

	case "RuntimeContextPage.data":
		if e.complexity.RuntimeContextPage.Data == nil {
			break
		}

		return e.complexity.RuntimeContextPage.Data(childComplexity), true

	case "RuntimeContextPage.pageInfo":
		if e.complexity.RuntimeContextPage.PageInfo == nil {
			break
		}

		return e.complexity.RuntimeContextPage.PageInfo(childComplexity), true

	case "RuntimeContextPage.totalCount":
		if e.complexity.RuntimeContextPage.TotalCount == nil {
			break
		}

		return e.complexity.RuntimeContextPage.TotalCount(childComplexity), true

	case "RuntimeEventingConfiguration.defaultURL":
		if e.complexity.RuntimeEventingConfiguration.DefaultURL == nil {
			break
		}

		return e.complexity.RuntimeEventingConfiguration.DefaultURL(childComplexity), true

	case "RuntimeMetadata.creationTimestamp":
		if e.complexity.RuntimeMetadata.CreationTimestamp == nil {
			break
		}

		return e.complexity.RuntimeMetadata.CreationTimestamp(childComplexity), true

	case "RuntimePage.data":
		if e.complexity.RuntimePage.Data == nil {
			break
		}

		return e.complexity.RuntimePage.Data(childComplexity), true

	case "RuntimePage.pageInfo":
		if e.complexity.RuntimePage.PageInfo == nil {
			break
		}

		return e.complexity.RuntimePage.PageInfo(childComplexity), true

	case "RuntimePage.totalCount":
		if e.complexity.RuntimePage.TotalCount == nil {
			break
		}

		return e.complexity.RuntimePage.TotalCount(childComplexity), true

	case "RuntimeStatus.condition":
		if e.complexity.RuntimeStatus.Condition == nil {
			break
		}

		return e.complexity.RuntimeStatus.Condition(childComplexity), true

	case "RuntimeStatus.timestamp":
		if e.complexity.RuntimeStatus.Timestamp == nil {
			break
		}

		return e.complexity.RuntimeStatus.Timestamp(childComplexity), true

	case "RuntimeSystemAuth.auth":
		if e.complexity.RuntimeSystemAuth.Auth == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.Auth(childComplexity), true

	case "RuntimeSystemAuth.id":
		if e.complexity.RuntimeSystemAuth.ID == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.ID(childComplexity), true

	case "RuntimeSystemAuth.referenceObjectId":
		if e.complexity.RuntimeSystemAuth.ReferenceObjectID == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.ReferenceObjectID(childComplexity), true

	case "RuntimeSystemAuth.tenantId":
		if e.complexity.RuntimeSystemAuth.TenantID == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.TenantID(childComplexity), true

	case "RuntimeSystemAuth.type":
		if e.complexity.RuntimeSystemAuth.Type == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.Type(childComplexity), true

	case "Tenant.id":
		if e.complexity.Tenant.ID == nil {
			break
		}

		return e.complexity.Tenant.ID(childComplexity), true

	case "Tenant.initialized":
		if e.complexity.Tenant.Initialized == nil {
			break
		}

		return e.complexity.Tenant.Initialized(childComplexity), true

	case "Tenant.internalID":
		if e.complexity.Tenant.InternalID == nil {
			break
		}

		return e.complexity.Tenant.InternalID(childComplexity), true

	case "Tenant.labels":
		if e.complexity.Tenant.Labels == nil {
			break
		}

		args, err := ec.field_Tenant_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tenant.Labels(childComplexity, args["key"].(*string)), true

	case "Tenant.name":
		if e.complexity.Tenant.Name == nil {
			break
		}

		return e.complexity.Tenant.Name(childComplexity), true

	case "Tenant.parents":
		if e.complexity.Tenant.Parents == nil {
			break
		}

		return e.complexity.Tenant.Parents(childComplexity), true

	case "Tenant.provider":
		if e.complexity.Tenant.Provider == nil {
			break
		}

		return e.complexity.Tenant.Provider(childComplexity), true

	case "Tenant.type":
		if e.complexity.Tenant.Type == nil {
			break
		}

		return e.complexity.Tenant.Type(childComplexity), true

	case "TenantAccess.owner":
		if e.complexity.TenantAccess.Owner == nil {
			break
		}

		return e.complexity.TenantAccess.Owner(childComplexity), true

	case "TenantAccess.resourceID":
		if e.complexity.TenantAccess.ResourceID == nil {
			break
		}

		return e.complexity.TenantAccess.ResourceID(childComplexity), true

	case "TenantAccess.resourceType":
		if e.complexity.TenantAccess.ResourceType == nil {
			break
		}

		return e.complexity.TenantAccess.ResourceType(childComplexity), true

	case "TenantAccess.tenantID":
		if e.complexity.TenantAccess.TenantID == nil {
			break
		}

		return e.complexity.TenantAccess.TenantID(childComplexity), true

	case "TenantPage.data":
		if e.complexity.TenantPage.Data == nil {
			break
		}

		return e.complexity.TenantPage.Data(childComplexity), true

	case "TenantPage.pageInfo":
		if e.complexity.TenantPage.PageInfo == nil {
			break
		}

		return e.complexity.TenantPage.PageInfo(childComplexity), true

	case "TenantPage.totalCount":
		if e.complexity.TenantPage.TotalCount == nil {
			break
		}

		return e.complexity.TenantPage.TotalCount(childComplexity), true

	case "Version.deprecated":
		if e.complexity.Version.Deprecated == nil {
			break
		}

		return e.complexity.Version.Deprecated(childComplexity), true

	case "Version.deprecatedSince":
		if e.complexity.Version.DeprecatedSince == nil {
			break
		}

		return e.complexity.Version.DeprecatedSince(childComplexity), true

	case "Version.forRemoval":
		if e.complexity.Version.ForRemoval == nil {
			break
		}

		return e.complexity.Version.ForRemoval(childComplexity), true

	case "Version.value":
		if e.complexity.Version.Value == nil {
			break
		}

		return e.complexity.Version.Value(childComplexity), true

	case "Viewer.id":
		if e.complexity.Viewer.ID == nil {
			break
		}

		return e.complexity.Viewer.ID(childComplexity), true

	case "Viewer.type":
		if e.complexity.Viewer.Type == nil {
			break
		}

		return e.complexity.Viewer.Type(childComplexity), true

	case "Webhook.applicationID":
		if e.complexity.Webhook.ApplicationID == nil {
			break
		}

		return e.complexity.Webhook.ApplicationID(childComplexity), true

	case "Webhook.applicationTemplateID":
		if e.complexity.Webhook.ApplicationTemplateID == nil {
			break
		}

		return e.complexity.Webhook.ApplicationTemplateID(childComplexity), true

	case "Webhook.auth":
		if e.complexity.Webhook.Auth == nil {
			break
		}

		return e.complexity.Webhook.Auth(childComplexity), true

	case "Webhook.correlationIdKey":
		if e.complexity.Webhook.CorrelationIDKey == nil {
			break
		}

		return e.complexity.Webhook.CorrelationIDKey(childComplexity), true

	case "Webhook.createdAt":
		if e.complexity.Webhook.CreatedAt == nil {
			break
		}

		return e.complexity.Webhook.CreatedAt(childComplexity), true

	case "Webhook.formationTemplateID":
		if e.complexity.Webhook.FormationTemplateID == nil {
			break
		}

		return e.complexity.Webhook.FormationTemplateID(childComplexity), true

	case "Webhook.headerTemplate":
		if e.complexity.Webhook.HeaderTemplate == nil {
			break
		}

		return e.complexity.Webhook.HeaderTemplate(childComplexity), true

	case "Webhook.id":
		if e.complexity.Webhook.ID == nil {
			break
		}

		return e.complexity.Webhook.ID(childComplexity), true

	case "Webhook.inputTemplate":
		if e.complexity.Webhook.InputTemplate == nil {
			break
		}

		return e.complexity.Webhook.InputTemplate(childComplexity), true

	case "Webhook.integrationSystemID":
		if e.complexity.Webhook.IntegrationSystemID == nil {
			break
		}

		return e.complexity.Webhook.IntegrationSystemID(childComplexity), true

	case "Webhook.mode":
		if e.complexity.Webhook.Mode == nil {
			break
		}

		return e.complexity.Webhook.Mode(childComplexity), true

	case "Webhook.outputTemplate":
		if e.complexity.Webhook.OutputTemplate == nil {
			break
		}

		return e.complexity.Webhook.OutputTemplate(childComplexity), true

	case "Webhook.retryInterval":
		if e.complexity.Webhook.RetryInterval == nil {
			break
		}

		return e.complexity.Webhook.RetryInterval(childComplexity), true

	case "Webhook.runtimeID":
		if e.complexity.Webhook.RuntimeID == nil {
			break
		}

		return e.complexity.Webhook.RuntimeID(childComplexity), true

	case "Webhook.statusTemplate":
		if e.complexity.Webhook.StatusTemplate == nil {
			break
		}

		return e.complexity.Webhook.StatusTemplate(childComplexity), true

	case "Webhook.timeout":
		if e.complexity.Webhook.Timeout == nil {
			break
		}

		return e.complexity.Webhook.Timeout(childComplexity), true

	case "Webhook.type":
		if e.complexity.Webhook.Type == nil {
			break
		}

		return e.complexity.Webhook.Type(childComplexity), true

	case "Webhook.url":
		if e.complexity.Webhook.URL == nil {
			break
		}

		return e.complexity.Webhook.URL(childComplexity), true

	case "Webhook.urlTemplate":
		if e.complexity.Webhook.URLTemplate == nil {
			break
		}

		return e.complexity.Webhook.URLTemplate(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAPIDefinitionInput,
		ec.unmarshalInputAPISpecInput,
		ec.unmarshalInputApplicationFromTemplateInput,
		ec.unmarshalInputApplicationJSONInput,
		ec.unmarshalInputApplicationRegisterInput,
		ec.unmarshalInputApplicationTemplateInput,
		ec.unmarshalInputApplicationTemplateUpdateInput,
		ec.unmarshalInputApplicationUpdateInput,
		ec.unmarshalInputAspectAPIDefinitionInput,
		ec.unmarshalInputAspectEventDefinitionInput,
		ec.unmarshalInputAspectEventDefinitionSubsetInput,
		ec.unmarshalInputAspectInput,
		ec.unmarshalInputAuthInput,
		ec.unmarshalInputBasicCredentialDataInput,
		ec.unmarshalInputBundleCreateInput,
		ec.unmarshalInputBundleInstanceAuthCreateInput,
		ec.unmarshalInputBundleInstanceAuthRequestInput,
		ec.unmarshalInputBundleInstanceAuthSetInput,
		ec.unmarshalInputBundleInstanceAuthStatusInput,
		ec.unmarshalInputBundleInstanceAuthUpdateInput,
		ec.unmarshalInputBundleUpdateInput,
		ec.unmarshalInputBusinessTenantMappingInput,
		ec.unmarshalInputCSRFTokenCredentialRequestAuthInput,
		ec.unmarshalInputCertificateOAuthCredentialDataInput,
		ec.unmarshalInputCertificateSubjectMappingInput,
		ec.unmarshalInputCredentialDataInput,
		ec.unmarshalInputCredentialRequestAuthInput,
		ec.unmarshalInputDocumentInput,
		ec.unmarshalInputEventDefinitionInput,
		ec.unmarshalInputEventSpecInput,
		ec.unmarshalInputFetchRequestInput,
		ec.unmarshalInputFormationConstraintInput,
		ec.unmarshalInputFormationConstraintUpdateInput,
		ec.unmarshalInputFormationInput,
		ec.unmarshalInputFormationTemplateInput,
		ec.unmarshalInputIntegrationDependencyInput,
		ec.unmarshalInputIntegrationSystemInput,
		ec.unmarshalInputLabelDefinitionInput,
		ec.unmarshalInputLabelFilter,
		ec.unmarshalInputLabelInput,
		ec.unmarshalInputLabelSelectorInput,
		ec.unmarshalInputOAuthCredentialDataInput,
		ec.unmarshalInputOneTimeTokenInput,
		ec.unmarshalInputPlaceholderDefinitionInput,
		ec.unmarshalInputRuntimeContextInput,
		ec.unmarshalInputRuntimeRegisterInput,
		ec.unmarshalInputRuntimeUpdateInput,
		ec.unmarshalInputSystemAuthUpdateInput,
		ec.unmarshalInputTemplateValueInput,
		ec.unmarshalInputTenantAccessInput,
		ec.unmarshalInputVersionInput,
		ec.unmarshalInputWebhookInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphql", Input: sourceData("schema.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_async_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 OperationType
	if tmp, ok := rawArgs["operationType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operationType"))
		arg0, err = ec.unmarshalNOperationType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg0
	var arg1 *WebhookType
	if tmp, ok := rawArgs["webhookType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookType"))
		arg1, err = ec.unmarshalOWebhookType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["webhookType"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["idField"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idField"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["idField"] = arg2
	return args, nil
}

func (ec *executionContext) dir_hasScenario_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationProvider"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationProvider"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationProvider"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["idField"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idField"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["idField"] = arg1
	return args, nil
}

func (ec *executionContext) dir_hasScopes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) dir_sanitize_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) dir_synchronizeApplicationTenancy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 EventType
	if tmp, ok := rawArgs["eventType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventType"))
		arg0, err = ec.unmarshalNEventType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["eventType"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationTemplate_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_apiDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_bundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_bundles_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Application_eventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_integrationDependencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Application_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_apiDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_apiDefinitions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["group"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["group"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Bundle_document_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_documents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Bundle_eventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_eventDefinitions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["group"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["group"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Bundle_instanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Formation_formationAssignment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Formation_formationAssignments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addAPIDefinitionToApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addAPIDefinitionToBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 BundleCreateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleCreateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleCreateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleCreateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleCreateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addDocumentToBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 DocumentInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNDocumentInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(DocumentInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.DocumentInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addEventDefinitionToApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addEventDefinitionToBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addIntegrationDependencyToApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 IntegrationDependencyInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNIntegrationDependencyInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependencyInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(IntegrationDependencyInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationDependencyInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addTenantAccess_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 TenantAccessInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalNTenantAccessInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccessInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addWebhook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["applicationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationTemplateID"))
		arg1, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationTemplateID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg2, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg3, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg3
	var arg4 WebhookInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNWebhookInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(WebhookInput); ok {
			arg4 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.WebhookInput`, tmp))
		}
	}
	args["in"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_assignFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	var arg1 FormationObjectType
	if tmp, ok := rawArgs["objectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectType"))
		arg1, err = ec.unmarshalNFormationObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectType"] = arg1
	var arg2 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg2, err = ec.unmarshalNFormationInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_attachConstraintToFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["constraintID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["constraintID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createApplicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ApplicationTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationTemplateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationTemplateInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplateInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 BundleInstanceAuthCreateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleInstanceAuthCreateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthCreateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleInstanceAuthCreateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuthCreateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createCertificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CertificateSubjectMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCertificateSubjectMappingInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(CertificateSubjectMappingInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMappingInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFormationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationConstraintInput
	if tmp, ok := rawArgs["formationConstraint"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationConstraint"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNFormationConstraintInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(FormationConstraintInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraintInput`, tmp))
		}
	}
	args["formationConstraint"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNFormationTemplateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(FormationTemplateInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplateInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg0, err = ec.unmarshalNFormationInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLabelDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 LabelDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNLabelDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(LabelDefinitionInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinitionInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAPIDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteApplicationLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteApplicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCertificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDefaultEventingForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDocument_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFormationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg0, err = ec.unmarshalNFormationInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteIntegrationDependency_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRuntimeLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSystemAuthForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSystemAuthForIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSystemAuthForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWebhook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["webhookID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["webhookID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_detachConstraintFromFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["constraintID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["constraintID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_finalizeDraftFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["formationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_invalidateSystemAuthOneTimeToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_mergeApplications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["destinationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("destinationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["destinationID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["sourceID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sourceID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_refetchAPISpec_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["apiID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["apiID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refetchEventDefinitionSpec_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["eventID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["eventID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerApplicationFromTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ApplicationFromTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationFromTemplateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationFromTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationFromTemplateInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationFromTemplateInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ApplicationRegisterInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationRegisterInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationRegisterInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationRegisterInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationRegisterInput`, tmp))
		}
	}
	args["in"] = arg0
	var arg1 *OperationMode
	if tmp, ok := rawArgs["mode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
		arg1, err = ec.unmarshalOOperationMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationMode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_registerIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 IntegrationSystemInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNIntegrationSystemInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(IntegrationSystemInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystemInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerRuntimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 RuntimeContextInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeContextInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContextInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeContextInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContextInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_registerRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 RuntimeRegisterInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeRegisterInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeRegisterInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeRegisterInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeRegisterInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeTenantAccess_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tenantID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceID"] = arg1
	var arg2 TenantAccessObjectType
	if tmp, ok := rawArgs["resourceType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
		arg2, err = ec.unmarshalNTenantAccessObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccessObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceType"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_requestBundleInstanceAuthCreation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 BundleInstanceAuthRequestInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleInstanceAuthRequestInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthRequestInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleInstanceAuthRequestInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuthRequestInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_requestBundleInstanceAuthDeletion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestClientCredentialsForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestClientCredentialsForIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestClientCredentialsForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestOneTimeTokenForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["systemAuthID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemAuthID"))
		arg1, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["systemAuthID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_requestOneTimeTokenForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["systemAuthID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemAuthID"))
		arg1, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["systemAuthID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_resynchronizeFormationNotifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["formationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationID"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["reset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reset"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reset"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setApplicationLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	var arg2 interface{}
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg2, err = ec.unmarshalNAny2interface(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_setBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	var arg1 BundleInstanceAuthSetInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleInstanceAuthSetInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthSetInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleInstanceAuthSetInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuthSetInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setDefaultEventingForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setRuntimeLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	var arg2 interface{}
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg2, err = ec.unmarshalNAny2interface(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_setTenantLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tenantID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	var arg2 interface{}
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg2, err = ec.unmarshalNAny2interface(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_subscribeTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["providerID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["subaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subaccountID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subaccountID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["providerSubaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSubaccountID"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerSubaccountID"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["consumerTenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consumerTenantID"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["consumerTenantID"] = arg3
	var arg4 string
	if tmp, ok := rawArgs["region"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
		arg4, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["region"] = arg4
	var arg5 string
	if tmp, ok := rawArgs["subscriptionAppName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionAppName"))
		arg5, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscriptionAppName"] = arg5
	var arg6 string
	if tmp, ok := rawArgs["subscriptionPayload"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionPayload"))
		arg6, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscriptionPayload"] = arg6
	return args, nil
}

func (ec *executionContext) field_Mutation_unassignFormationGlobal_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	var arg1 FormationObjectType
	if tmp, ok := rawArgs["objectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectType"))
		arg1, err = ec.unmarshalNFormationObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectType"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_unassignFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	var arg1 FormationObjectType
	if tmp, ok := rawArgs["objectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectType"))
		arg1, err = ec.unmarshalNFormationObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectType"] = arg1
	var arg2 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg2, err = ec.unmarshalNFormationInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_unpairApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *OperationMode
	if tmp, ok := rawArgs["mode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
		arg1, err = ec.unmarshalOOperationMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationMode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *OperationMode
	if tmp, ok := rawArgs["mode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
		arg1, err = ec.unmarshalOOperationMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationMode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterRuntimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unsubscribeTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["providerID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["subaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subaccountID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subaccountID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["providerSubaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSubaccountID"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerSubaccountID"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["consumerTenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consumerTenantID"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["consumerTenantID"] = arg3
	var arg4 string
	if tmp, ok := rawArgs["region"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
		arg4, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["region"] = arg4
	var arg5 string
	if tmp, ok := rawArgs["subscriptionPayload"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionPayload"))
		arg5, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscriptionPayload"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAPIDefinitionForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAPIDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateApplicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["override"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("override"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["override"] = arg1
	var arg2 ApplicationTemplateUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationTemplateUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationTemplateUpdateInput); ok {
			arg2 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplateUpdateInput`, tmp))
		}
	}
	args["in"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ApplicationUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationUpdateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationUpdateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg1
	var arg2 BundleInstanceAuthUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg2, err = ec.unmarshalNBundleInstanceAuthUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 BundleUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleUpdateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleUpdateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCertificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 CertificateSubjectMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCertificateSubjectMappingInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(CertificateSubjectMappingInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMappingInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEventDefinitionForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFormationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 FormationConstraintUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg1, err = ec.unmarshalNFormationConstraintUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 FormationTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNFormationTemplateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(FormationTemplateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 IntegrationSystemInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNIntegrationSystemInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(IntegrationSystemInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystemInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLabelDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 LabelDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNLabelDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(LabelDefinitionInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinitionInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRuntimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 RuntimeContextInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeContextInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContextInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeContextInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContextInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 RuntimeUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeUpdateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeUpdateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSystemAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	var arg1 AuthInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg1, err = ec.unmarshalNAuthInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 BusinessTenantMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg1, err = ec.unmarshalNBusinessTenantMappingInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBusinessTenantMappingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateWebhook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["webhookID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["webhookID"] = arg0
	var arg1 WebhookInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNWebhookInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(WebhookInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.WebhookInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_writeTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 BusinessTenantMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalNBusinessTenantMappingInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBusinessTenantMappingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_writeTenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*BusinessTenantMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalOBusinessTenantMappingInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBusinessTenantMappingInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_apisForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_applicationByLocalTenantIDAndAppTemplateID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["localTenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["localTenantID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["applicationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationTemplateID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationTemplateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_applicationBySystemNumber_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["systemNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemNumber"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["systemNumber"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_applicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_applicationTemplates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*LabelFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLabelFilter2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelFilterᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_application_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_applicationsForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_applications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*LabelFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLabelFilter2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelFilterᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_automaticScenarioAssignmentForScenario_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["scenarioName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scenarioName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scenarioName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_automaticScenarioAssignmentsForSelector_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 LabelSelectorInput
	if tmp, ok := rawArgs["selector"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selector"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNLabelSelectorInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelSelectorInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(LabelSelectorInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelSelectorInput`, tmp))
		}
	}
	args["selector"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_automaticScenarioAssignments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_bundleByInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_certificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_certificateSubjectMappings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_eventsForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_formationByName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationConstraintsByFormationType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationTemplatesByName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_formationTemplates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_formation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationsForObject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_healthChecks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []HealthCheckType
	if tmp, ok := rawArgs["types"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
		arg0, err = ec.unmarshalOHealthCheckType2ᚕgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckTypeᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["types"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["origin"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("origin"))
		arg1, err = ec.unmarshalOID2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["origin"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg3, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_integrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_integrationSystems_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_labelDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_rootTenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["externalTenant"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalTenant"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["externalTenant"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runtimeByTokenIssuer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["issuer"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuer"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["issuer"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runtime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runtimes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*LabelFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLabelFilter2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelFilterᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_systemAuthByToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["token"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_systemAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tenantByExternalID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tenantByInternalID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tenantByLowestOwnerForResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resource"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resource"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resource"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_tenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["searchTerm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchTerm"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["searchTerm"] = arg2
	return args, nil
}

func (ec *executionContext) field_RuntimeContext_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Runtime_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Runtime_runtimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Runtime_runtimeContexts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Tenant_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _APIDefinition_id(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_name(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_description(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_spec(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.APIDefinition().Spec(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APISpec)
	fc.Result = res
	return ec.marshalOAPISpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APISpec_id(ctx, field)
			case "data":
				return ec.fieldContext_APISpec_data(ctx, field)
			case "format":
				return ec.fieldContext_APISpec_format(ctx, field)
			case "type":
				return ec.fieldContext_APISpec_type(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_APISpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APISpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_targetURL(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_targetURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_targetURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_group(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_version(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_Version_value(ctx, field)
			case "deprecated":
				return ec.fieldContext_Version_deprecated(ctx, field)
			case "deprecatedSince":
				return ec.fieldContext_Version_deprecatedSince(ctx, field)
			case "forRemoval":
				return ec.fieldContext_Version_forRemoval(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_created_at(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_updated_at(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_deleted_at(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_error(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinitionPage_data(ctx context.Context, field graphql.CollectedField, obj *APIDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinitionPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinitionPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *APIDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinitionPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *APIDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinitionPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_id(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_data(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CLOB)
	fc.Result = res
	return ec.marshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CLOB does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_format(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SpecFormat)
	fc.Result = res
	return ec.marshalNSpecFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSpecFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SpecFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_type(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(APISpecType)
	fc.Result = res
	return ec.marshalNAPISpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpecType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type APISpecType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_fetchRequest(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_fetchRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.APISpec().FetchRequest(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.api_spec.fetch_request")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FetchRequest); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FetchRequest`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FetchRequest)
	fc.Result = res
	return ec.marshalOFetchRequest2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_fetchRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FetchRequest_url(ctx, field)
			case "auth":
				return ec.fieldContext_FetchRequest_auth(ctx, field)
			case "mode":
				return ec.fieldContext_FetchRequest_mode(ctx, field)
			case "filter":
				return ec.fieldContext_FetchRequest_filter(ctx, field)
			case "status":
				return ec.fieldContext_FetchRequest_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_id(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_auth(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application.auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_type(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SystemAuthReferenceType)
	fc.Result = res
	return ec.marshalOSystemAuthReferenceType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuthReferenceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SystemAuthReferenceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_referenceObjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReferenceObjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_id(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_name(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_systemNumber(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_systemNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_systemNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_localTenantID(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_localTenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocalTenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_localTenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_baseUrl(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_providerName(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_providerName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_providerName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_description(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_integrationSystemID(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_integrationSystemID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntegrationSystemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_integrationSystemID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_applicationTemplateID(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_applicationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_applicationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_applicationTemplate(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_applicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Application().ApplicationTemplate(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application.application_template")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalOApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_applicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_labels(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_status(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationStatus)
	fc.Result = res
	return ec.marshalNApplicationStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_ApplicationStatus_condition(ctx, field)
			case "timestamp":
				return ec.fieldContext_ApplicationStatus_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_webhooks(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Application().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_healthCheckURL(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_healthCheckURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthCheckURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_healthCheckURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_bundles(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_bundles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Bundles(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BundlePage)
	fc.Result = res
	return ec.marshalOBundlePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundlePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_bundles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_BundlePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BundlePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BundlePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundlePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_bundles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_bundle(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_bundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Bundle(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalOBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_bundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_bundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_apiDefinition(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_apiDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().APIDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalOAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_apiDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_apiDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_eventDefinition(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_eventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().EventDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalOEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_eventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_eventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_integrationDependencies(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_integrationDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().IntegrationDependencies(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IntegrationDependencyPage)
	fc.Result = res
	return ec.marshalOIntegrationDependencyPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependencyPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_integrationDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_IntegrationDependencyPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_IntegrationDependencyPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_IntegrationDependencyPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependencyPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_integrationDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_auths(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_auths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Auths(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AppSystemAuth)
	fc.Result = res
	return ec.marshalOAppSystemAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAppSystemAuthᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_auths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AppSystemAuth_id(ctx, field)
			case "auth":
				return ec.fieldContext_AppSystemAuth_auth(ctx, field)
			case "type":
				return ec.fieldContext_AppSystemAuth_type(ctx, field)
			case "tenantId":
				return ec.fieldContext_AppSystemAuth_tenantId(ctx, field)
			case "referenceObjectId":
				return ec.fieldContext_AppSystemAuth_referenceObjectId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AppSystemAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_eventingConfiguration(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_eventingConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().EventingConfiguration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationEventingConfiguration)
	fc.Result = res
	return ec.marshalOApplicationEventingConfiguration2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_eventingConfiguration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEventingConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_applicationNamespace(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_applicationNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_applicationNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_createdAt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_deletedAt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_systemStatus(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_systemStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_systemStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_error(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField, obj *ApplicationEventingConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEventingConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPage_data(ctx context.Context, field graphql.CollectedField, obj *ApplicationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ApplicationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *ApplicationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationStatus_condition(ctx context.Context, field graphql.CollectedField, obj *ApplicationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationStatusCondition)
	fc.Result = res
	return ec.marshalNApplicationStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *ApplicationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_id(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_name(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_description(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_webhooks(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.ApplicationTemplate().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application_template.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_applicationInput(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_applicationInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_placeholders(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Placeholders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*PlaceholderDefinition)
	fc.Result = res
	return ec.marshalNPlaceholderDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_placeholders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_PlaceholderDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_PlaceholderDefinition_description(ctx, field)
			case "jsonPath":
				return ec.fieldContext_PlaceholderDefinition_jsonPath(ctx, field)
			case "optional":
				return ec.fieldContext_PlaceholderDefinition_optional(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaceholderDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_labels(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationTemplate().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationTemplate_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_accessLevel(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationTemplateAccessLevel)
	fc.Result = res
	return ec.marshalNApplicationTemplateAccessLevel2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateAccessLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_accessLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationTemplateAccessLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_applicationNamespace(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_applicationNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_createdAt(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplatePage_data(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplatePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplatePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplatePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplatePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_id(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_name(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_description(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_mandatory(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_mandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_mandatory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_apiResources(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_apiResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIResources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AspectAPIDefinition)
	fc.Result = res
	return ec.marshalOAspectAPIDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_apiResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ordID":
				return ec.fieldContext_AspectAPIDefinition_ordID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AspectAPIDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_eventResources(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_eventResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventResources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AspectEventDefinition)
	fc.Result = res
	return ec.marshalOAspectEventDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_eventResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ordID":
				return ec.fieldContext_AspectEventDefinition_ordID(ctx, field)
			case "subset":
				return ec.fieldContext_AspectEventDefinition_subset(ctx, field)
			case "created_at":
				return ec.fieldContext_AspectEventDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_AspectEventDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_AspectEventDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_AspectEventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AspectEventDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_created_at(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_updated_at(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_deleted_at(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_error(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectAPIDefinition_ordID(ctx context.Context, field graphql.CollectedField, obj *AspectAPIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectAPIDefinition_ordID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectAPIDefinition_ordID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectAPIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_ordID(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_ordID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_ordID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_subset(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_subset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AspectEventDefinitionSubset)
	fc.Result = res
	return ec.marshalOAspectEventDefinitionSubset2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubsetᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_subset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventType":
				return ec.fieldContext_AspectEventDefinitionSubset_eventType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AspectEventDefinitionSubset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_created_at(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_updated_at(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_deleted_at(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_error(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinitionSubset_eventType(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinitionSubset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinitionSubset_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinitionSubset_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinitionSubset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_credential(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_credential(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Credential, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(CredentialData)
	fc.Result = res
	return ec.marshalOCredentialData2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_credential(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialData does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_accessStrategy(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_accessStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessStrategy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_accessStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalHeaders(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalHeaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeaders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(HTTPHeaders)
	fc.Result = res
	return ec.marshalOHttpHeaders2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeaders(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalHeaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeaders does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeadersSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HTTPHeadersSerialized)
	fc.Result = res
	return ec.marshalOHttpHeadersSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeadersSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeadersSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalQueryParams(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalQueryParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(QueryParams)
	fc.Result = res
	return ec.marshalOQueryParams2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalQueryParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParams does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParamsSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*QueryParamsSerialized)
	fc.Result = res
	return ec.marshalOQueryParamsSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParamsSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParamsSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_requestAuth(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_requestAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestAuth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CredentialRequestAuth)
	fc.Result = res
	return ec.marshalOCredentialRequestAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialRequestAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_requestAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "csrf":
				return ec.fieldContext_CredentialRequestAuth_csrf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialRequestAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_oneTimeToken(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_oneTimeToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OneTimeToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(OneTimeToken)
	fc.Result = res
	return ec.marshalOOneTimeToken2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_oneTimeToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_certCommonName(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_certCommonName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CertCommonName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_certCommonName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignment_scenarioName(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScenarioName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignment_scenarioName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignment_selector(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignment_selector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignmentPage_data(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignmentPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AutomaticScenarioAssignment)
	fc.Result = res
	return ec.marshalNAutomaticScenarioAssignment2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignmentPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenarioName":
				return ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
			case "selector":
				return ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignmentPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignmentPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BasicCredentialData_username(ctx context.Context, field graphql.CollectedField, obj *BasicCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BasicCredentialData_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BasicCredentialData_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BasicCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BasicCredentialData_password(ctx context.Context, field graphql.CollectedField, obj *BasicCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BasicCredentialData_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BasicCredentialData_password(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BasicCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_id(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_name(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_description(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_instanceAuthRequestInputSchema(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceAuthRequestInputSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSONSchema)
	fc.Result = res
	return ec.marshalOJSONSchema2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSONSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_instanceAuthRequestInputSchema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSONSchema does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_instanceAuth(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_instanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Bundle().InstanceAuth(rctx, obj, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.bundle.instance_auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalOBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_instanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_instanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_instanceAuths(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_instanceAuths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Bundle().InstanceAuths(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.bundle.instance_auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalOBundleInstanceAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_instanceAuths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_defaultInstanceAuth(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DefaultInstanceAuth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.bundle.default_instance_auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_defaultInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_apiDefinitions(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_apiDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().APIDefinitions(rctx, obj, fc.Args["group"].(*string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinitionPage)
	fc.Result = res
	return ec.marshalOAPIDefinitionPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_apiDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_APIDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_APIDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_APIDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_apiDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_eventDefinitions(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_eventDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().EventDefinitions(rctx, obj, fc.Args["group"].(*string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinitionPage)
	fc.Result = res
	return ec.marshalOEventDefinitionPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_eventDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_EventDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_eventDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_documents(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_documents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().Documents(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DocumentPage)
	fc.Result = res
	return ec.marshalODocumentPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_documents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_DocumentPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DocumentPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_DocumentPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_documents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_apiDefinition(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_apiDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().APIDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalOAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_apiDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_apiDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_eventDefinition(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_eventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().EventDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalOEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_eventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_eventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_correlationIDs(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_correlationIDs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorrelationIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_correlationIDs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_document(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_document(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().Document(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Document)
	fc.Result = res
	return ec.marshalODocument2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocument(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_document(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_document_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_createdAt(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_deletedAt(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_error(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_id(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_context(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_context(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_context(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_inputParams(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_inputParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_auth(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Auth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_status(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuthStatus)
	fc.Result = res
	return ec.marshalNBundleInstanceAuthStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_BundleInstanceAuthStatus_condition(ctx, field)
			case "timestamp":
				return ec.fieldContext_BundleInstanceAuthStatus_timestamp(ctx, field)
			case "message":
				return ec.fieldContext_BundleInstanceAuthStatus_message(ctx, field)
			case "reason":
				return ec.fieldContext_BundleInstanceAuthStatus_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuthStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_runtimeID(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_runtimeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_runtimeContextID(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeContextID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_runtimeContextID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_condition(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BundleInstanceAuthStatusCondition)
	fc.Result = res
	return ec.marshalNBundleInstanceAuthStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BundleInstanceAuthStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_message(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_reason(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundlePage_data(ctx context.Context, field graphql.CollectedField, obj *BundlePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundlePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Bundle)
	fc.Result = res
	return ec.marshalNBundle2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundlePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundlePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundlePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *BundlePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundlePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundlePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundlePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundlePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *BundlePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundlePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundlePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundlePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_credential(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_credential(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Credential, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(CredentialData)
	fc.Result = res
	return ec.marshalOCredentialData2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_credential(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialData does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalHeaders(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeaders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(HTTPHeaders)
	fc.Result = res
	return ec.marshalOHttpHeaders2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeaders(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalHeaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeaders does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeadersSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HTTPHeadersSerialized)
	fc.Result = res
	return ec.marshalOHttpHeadersSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeadersSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeadersSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(QueryParams)
	fc.Result = res
	return ec.marshalOQueryParams2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParams does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParamsSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*QueryParamsSerialized)
	fc.Result = res
	return ec.marshalOQueryParamsSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParamsSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParamsSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateOAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField, obj *CertificateOAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateOAuthCredentialData_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateOAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateOAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateOAuthCredentialData_certificate(ctx context.Context, field graphql.CollectedField, obj *CertificateOAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateOAuthCredentialData_certificate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Certificate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateOAuthCredentialData_certificate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateOAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateOAuthCredentialData_url(ctx context.Context, field graphql.CollectedField, obj *CertificateOAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateOAuthCredentialData_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateOAuthCredentialData_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateOAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_id(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_subject(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_consumerType(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsumerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_consumerType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_internalConsumerID(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InternalConsumerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_internalConsumerID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_tenantAccessLevels(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantAccessLevels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMappingPage_data(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMappingPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMappingPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalNCertificateSubjectMapping2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMappingPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMappingPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMappingPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMappingPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMappingPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMappingPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMappingPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMappingPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMappingPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMappingPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMappingPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMappingPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConstraintReference_constraintID(ctx context.Context, field graphql.CollectedField, obj *ConstraintReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConstraintReference_constraintID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConstraintID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConstraintReference_constraintID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConstraintReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConstraintReference_formationTemplateID(ctx context.Context, field graphql.CollectedField, obj *ConstraintReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConstraintReference_formationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConstraintReference_formationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConstraintReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialRequestAuth_csrf(ctx context.Context, field graphql.CollectedField, obj *CredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialRequestAuth_csrf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csrf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CSRFTokenCredentialRequestAuth)
	fc.Result = res
	return ec.marshalOCSRFTokenCredentialRequestAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCSRFTokenCredentialRequestAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialRequestAuth_csrf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tokenEndpointURL":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx, field)
			case "credential":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_credential(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CSRFTokenCredentialRequestAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_id(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_title(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_displayName(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_description(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_format(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DocumentFormat)
	fc.Result = res
	return ec.marshalNDocumentFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DocumentFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_kind(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_data(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CLOB)
	fc.Result = res
	return ec.marshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CLOB does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_fetchRequest(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_fetchRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Document().FetchRequest(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.document.fetch_request")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FetchRequest); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FetchRequest`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FetchRequest)
	fc.Result = res
	return ec.marshalOFetchRequest2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_fetchRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FetchRequest_url(ctx, field)
			case "auth":
				return ec.fieldContext_FetchRequest_auth(ctx, field)
			case "mode":
				return ec.fieldContext_FetchRequest_mode(ctx, field)
			case "filter":
				return ec.fieldContext_FetchRequest_filter(ctx, field)
			case "status":
				return ec.fieldContext_FetchRequest_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_createdAt(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_deletedAt(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_error(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentPage_data(ctx context.Context, field graphql.CollectedField, obj *DocumentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Document)
	fc.Result = res
	return ec.marshalNDocument2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *DocumentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *DocumentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_id(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_name(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_description(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_group(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_spec(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EventDefinition().Spec(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventSpec)
	fc.Result = res
	return ec.marshalOEventSpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventSpec_id(ctx, field)
			case "data":
				return ec.fieldContext_EventSpec_data(ctx, field)
			case "type":
				return ec.fieldContext_EventSpec_type(ctx, field)
			case "format":
				return ec.fieldContext_EventSpec_format(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_EventSpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_version(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_Version_value(ctx, field)
			case "deprecated":
				return ec.fieldContext_Version_deprecated(ctx, field)
			case "deprecatedSince":
				return ec.fieldContext_Version_deprecatedSince(ctx, field)
			case "forRemoval":
				return ec.fieldContext_Version_forRemoval(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_createdAt(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_updatedAt(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_deletedAt(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_error(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinitionPage_data(ctx context.Context, field graphql.CollectedField, obj *EventDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinitionPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinitionPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *EventDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinitionPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *EventDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinitionPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_id(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_data(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CLOB)
	fc.Result = res
	return ec.marshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CLOB does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_type(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(EventSpecType)
	fc.Result = res
	return ec.marshalNEventSpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpecType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventSpecType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_format(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SpecFormat)
	fc.Result = res
	return ec.marshalNSpecFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSpecFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SpecFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_fetchRequest(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_fetchRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EventSpec().FetchRequest(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.event_spec.fetch_request")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FetchRequest); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FetchRequest`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FetchRequest)
	fc.Result = res
	return ec.marshalOFetchRequest2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_fetchRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FetchRequest_url(ctx, field)
			case "auth":
				return ec.fieldContext_FetchRequest_auth(ctx, field)
			case "mode":
				return ec.fieldContext_FetchRequest_mode(ctx, field)
			case "filter":
				return ec.fieldContext_FetchRequest_filter(ctx, field)
			case "status":
				return ec.fieldContext_FetchRequest_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_url(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_auth(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.fetch_request.auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_mode(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FetchMode)
	fc.Result = res
	return ec.marshalNFetchMode2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FetchMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_filter(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_filter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_filter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_status(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FetchRequestStatus)
	fc.Result = res
	return ec.marshalNFetchRequestStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_FetchRequestStatus_condition(ctx, field)
			case "message":
				return ec.fieldContext_FetchRequestStatus_message(ctx, field)
			case "timestamp":
				return ec.fieldContext_FetchRequestStatus_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequestStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequestStatus_condition(ctx context.Context, field graphql.CollectedField, obj *FetchRequestStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequestStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FetchRequestStatusCondition)
	fc.Result = res
	return ec.marshalNFetchRequestStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequestStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequestStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FetchRequestStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequestStatus_message(ctx context.Context, field graphql.CollectedField, obj *FetchRequestStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequestStatus_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequestStatus_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequestStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequestStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *FetchRequestStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequestStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequestStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequestStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_id(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_name(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_formationTemplateId(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_formationTemplateId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_formationTemplateId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_tenantID(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_tenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TenantID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.formation.tenant_id")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_tenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_state(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_error(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(FormationError)
	fc.Result = res
	return ec.marshalOFormationError2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_FormationError_message(ctx, field)
			case "errorCode":
				return ec.fieldContext_FormationError_errorCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_formationAssignment(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_formationAssignment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Formation().FormationAssignment(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationAssignment)
	fc.Result = res
	return ec.marshalOFormationAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_formationAssignment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationAssignment_id(ctx, field)
			case "source":
				return ec.fieldContext_FormationAssignment_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_FormationAssignment_sourceType(ctx, field)
			case "sourceEntity":
				return ec.fieldContext_FormationAssignment_sourceEntity(ctx, field)
			case "target":
				return ec.fieldContext_FormationAssignment_target(ctx, field)
			case "targetType":
				return ec.fieldContext_FormationAssignment_targetType(ctx, field)
			case "targetEntity":
				return ec.fieldContext_FormationAssignment_targetEntity(ctx, field)
			case "state":
				return ec.fieldContext_FormationAssignment_state(ctx, field)
			case "value":
				return ec.fieldContext_FormationAssignment_value(ctx, field)
			case "configuration":
				return ec.fieldContext_FormationAssignment_configuration(ctx, field)
			case "error":
				return ec.fieldContext_FormationAssignment_error(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationAssignment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Formation_formationAssignment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Formation_formationAssignments(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_formationAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Formation().FormationAssignments(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationAssignmentPage)
	fc.Result = res
	return ec.marshalOFormationAssignmentPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_formationAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationAssignmentPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationAssignmentPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationAssignmentPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationAssignmentPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Formation_formationAssignments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Formation_status(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Formation().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationStatus)
	fc.Result = res
	return ec.marshalNFormationStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_FormationStatus_condition(ctx, field)
			case "errors":
				return ec.fieldContext_FormationStatus_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastStateChangeTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastNotificationSentTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_id(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_source(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_sourceType(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_sourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FormationAssignmentType)
	fc.Result = res
	return ec.marshalNFormationAssignmentType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_sourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationAssignmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_sourceEntity(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_sourceEntity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FormationAssignment().SourceEntity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(FormationParticipant)
	fc.Result = res
	return ec.marshalOFormationParticipant2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationParticipant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_sourceEntity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationParticipant does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_target(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_targetType(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_targetType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FormationAssignmentType)
	fc.Result = res
	return ec.marshalNFormationAssignmentType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_targetType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationAssignmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_targetEntity(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_targetEntity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FormationAssignment().TargetEntity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(FormationParticipant)
	fc.Result = res
	return ec.marshalOFormationParticipant2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationParticipant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_targetEntity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationParticipant does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_state(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_value(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_configuration(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_error(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastStateChangeTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastNotificationSentTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignmentPage_data(ctx context.Context, field graphql.CollectedField, obj *FormationAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignmentPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationAssignment)
	fc.Result = res
	return ec.marshalNFormationAssignment2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignmentPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationAssignment_id(ctx, field)
			case "source":
				return ec.fieldContext_FormationAssignment_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_FormationAssignment_sourceType(ctx, field)
			case "sourceEntity":
				return ec.fieldContext_FormationAssignment_sourceEntity(ctx, field)
			case "target":
				return ec.fieldContext_FormationAssignment_target(ctx, field)
			case "targetType":
				return ec.fieldContext_FormationAssignment_targetType(ctx, field)
			case "targetEntity":
				return ec.fieldContext_FormationAssignment_targetEntity(ctx, field)
			case "state":
				return ec.fieldContext_FormationAssignment_state(ctx, field)
			case "value":
				return ec.fieldContext_FormationAssignment_value(ctx, field)
			case "configuration":
				return ec.fieldContext_FormationAssignment_configuration(ctx, field)
			case "error":
				return ec.fieldContext_FormationAssignment_error(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *FormationAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignmentPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *FormationAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignmentPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_id(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_name(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_description(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_constraintType(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_constraintType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConstraintType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_constraintType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_targetOperation(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetOperation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_targetOperation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_operator(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_resourceType(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_resourceSubtype(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceSubtype, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_resourceSubtype(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_inputTemplate(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_inputTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_constraintScope(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConstraintScope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_constraintScope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_priority(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_createdAt(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationError_message(ctx context.Context, field graphql.CollectedField, obj *FormationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationError_errorCode(ctx context.Context, field graphql.CollectedField, obj *FormationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationError_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationError_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationPage_data(ctx context.Context, field graphql.CollectedField, obj *FormationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *FormationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *FormationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatus_condition(ctx context.Context, field graphql.CollectedField, obj *FormationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FormationStatusCondition)
	fc.Result = res
	return ec.marshalNFormationStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatus_errors(ctx context.Context, field graphql.CollectedField, obj *FormationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatus_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FormationStatusError)
	fc.Result = res
	return ec.marshalOFormationStatusError2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatusErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatus_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentID":
				return ec.fieldContext_FormationStatusError_assignmentID(ctx, field)
			case "message":
				return ec.fieldContext_FormationStatusError_message(ctx, field)
			case "errorCode":
				return ec.fieldContext_FormationStatusError_errorCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationStatusError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatusError_assignmentID(ctx context.Context, field graphql.CollectedField, obj *FormationStatusError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatusError_assignmentID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatusError_assignmentID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatusError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatusError_message(ctx context.Context, field graphql.CollectedField, obj *FormationStatusError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatusError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatusError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatusError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatusError_errorCode(ctx context.Context, field graphql.CollectedField, obj *FormationStatusError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatusError_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatusError_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatusError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_id(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_name(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_applicationTypes(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_applicationTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_runtimeTypes(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_runtimeTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_runtimeTypeDisplayName(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeTypeDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_runtimeArtifactKind(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeArtifactKind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ArtifactType)
	fc.Result = res
	return ec.marshalOArtifactType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐArtifactType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_runtimeArtifactKind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArtifactType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_webhooks(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.FormationTemplate().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.formation_template.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_leadingProductIDs(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LeadingProductIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_leadingProductIDs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_formationConstraints(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FormationTemplate().FormationConstraints(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FormationConstraint)
	fc.Result = res
	return ec.marshalOFormationConstraint2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_formationConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_supportsReset(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsReset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_supportsReset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_discoveryConsumers(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscoveryConsumers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_discoveryConsumers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplatePage_data(ctx context.Context, field graphql.CollectedField, obj *FormationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplatePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationTemplate)
	fc.Result = res
	return ec.marshalNFormationTemplate2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplatePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *FormationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplatePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *FormationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplatePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_type(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(HealthCheckType)
	fc.Result = res
	return ec.marshalNHealthCheckType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HealthCheckType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_condition(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(HealthCheckStatusCondition)
	fc.Result = res
	return ec.marshalNHealthCheckStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HealthCheckStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_origin(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_origin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_origin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_message(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_timestamp(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckPage_data(ctx context.Context, field graphql.CollectedField, obj *HealthCheckPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*HealthCheck)
	fc.Result = res
	return ec.marshalNHealthCheck2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_HealthCheck_type(ctx, field)
			case "condition":
				return ec.fieldContext_HealthCheck_condition(ctx, field)
			case "origin":
				return ec.fieldContext_HealthCheck_origin(ctx, field)
			case "message":
				return ec.fieldContext_HealthCheck_message(ctx, field)
			case "timestamp":
				return ec.fieldContext_HealthCheck_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheck", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *HealthCheckPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *HealthCheckPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_id(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_auth(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.integration_system.auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_type(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SystemAuthReferenceType)
	fc.Result = res
	return ec.marshalOSystemAuthReferenceType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuthReferenceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SystemAuthReferenceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_referenceObjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReferenceObjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_id(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_name(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_description(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_ordID(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_ordID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_ordID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_partOfPackage(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartOfPackage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_partOfPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_visibility(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_releaseStatus(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleaseStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_releaseStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_mandatory(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_mandatory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_aspects(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_aspects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aspects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Aspect)
	fc.Result = res
	return ec.marshalOAspect2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_aspects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Aspect_id(ctx, field)
			case "name":
				return ec.fieldContext_Aspect_name(ctx, field)
			case "description":
				return ec.fieldContext_Aspect_description(ctx, field)
			case "mandatory":
				return ec.fieldContext_Aspect_mandatory(ctx, field)
			case "apiResources":
				return ec.fieldContext_Aspect_apiResources(ctx, field)
			case "eventResources":
				return ec.fieldContext_Aspect_eventResources(ctx, field)
			case "created_at":
				return ec.fieldContext_Aspect_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_Aspect_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_Aspect_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_Aspect_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Aspect", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_version(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_Version_value(ctx, field)
			case "deprecated":
				return ec.fieldContext_Version_deprecated(ctx, field)
			case "deprecatedSince":
				return ec.fieldContext_Version_deprecatedSince(ctx, field)
			case "forRemoval":
				return ec.fieldContext_Version_forRemoval(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_labels(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Labels)
	fc.Result = res
	return ec.marshalOLabels2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_created_at(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_updated_at(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_deleted_at(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_error(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependencyPage_data(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependencyPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependencyPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*IntegrationDependency)
	fc.Result = res
	return ec.marshalNIntegrationDependency2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependencyPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependencyPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationDependency_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationDependency_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationDependency_description(ctx, field)
			case "ordID":
				return ec.fieldContext_IntegrationDependency_ordID(ctx, field)
			case "partOfPackage":
				return ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
			case "visibility":
				return ec.fieldContext_IntegrationDependency_visibility(ctx, field)
			case "releaseStatus":
				return ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
			case "mandatory":
				return ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
			case "aspects":
				return ec.fieldContext_IntegrationDependency_aspects(ctx, field)
			case "version":
				return ec.fieldContext_IntegrationDependency_version(ctx, field)
			case "labels":
				return ec.fieldContext_IntegrationDependency_labels(ctx, field)
			case "created_at":
				return ec.fieldContext_IntegrationDependency_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_IntegrationDependency_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependencyPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependencyPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependencyPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependencyPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependencyPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependencyPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependencyPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependencyPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependencyPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependencyPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_id(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_name(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_description(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_auths(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_auths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IntegrationSystem().Auths(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*IntSysSystemAuth)
	fc.Result = res
	return ec.marshalOIntSysSystemAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntSysSystemAuthᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_auths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntSysSystemAuth_id(ctx, field)
			case "auth":
				return ec.fieldContext_IntSysSystemAuth_auth(ctx, field)
			case "type":
				return ec.fieldContext_IntSysSystemAuth_type(ctx, field)
			case "tenantId":
				return ec.fieldContext_IntSysSystemAuth_tenantId(ctx, field)
			case "referenceObjectId":
				return ec.fieldContext_IntSysSystemAuth_referenceObjectId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntSysSystemAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystemPage_data(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystemPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystemPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystemPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystemPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystemPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystemPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystemPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystemPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystemPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystemPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystemPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystemPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystemPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystemPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_key(ctx context.Context, field graphql.CollectedField, obj *Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_value(ctx context.Context, field graphql.CollectedField, obj *Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalNAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelDefinition_key(ctx context.Context, field graphql.CollectedField, obj *LabelDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelDefinition_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelDefinition_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelDefinition_schema(ctx context.Context, field graphql.CollectedField, obj *LabelDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelDefinition_schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSONSchema)
	fc.Result = res
	return ec.marshalOJSONSchema2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSONSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelDefinition_schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSONSchema does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterApplication(rctx, fc.Args["in"].(ApplicationRegisterInput), fc.Args["mode"].(*OperationMode))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationType(ctx, "CREATE")
			if err != nil {
				return nil, err
			}
			webhookType, err := ec.unmarshalOWebhookType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx, "REGISTER_APPLICATION")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, webhookType, nil)
		}
		directive3 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventType(ctx, "NEW_APPLICATION")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive2, eventType)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateApplication(rctx, fc.Args["id"].(string), fc.Args["in"].(ApplicationUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationType(ctx, "UPDATE")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalOString2ᚖstring(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, nil, idField)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterApplication(rctx, fc.Args["id"].(string), fc.Args["mode"].(*OperationMode))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationType(ctx, "DELETE")
			if err != nil {
				return nil, err
			}
			webhookType, err := ec.unmarshalOWebhookType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx, "UNREGISTER_APPLICATION")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalOString2ᚖstring(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, webhookType, idField)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unpairApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unpairApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnpairApplication(rctx, fc.Args["id"].(string), fc.Args["mode"].(*OperationMode))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unpairApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationType(ctx, "UPDATE")
			if err != nil {
				return nil, err
			}
			webhookType, err := ec.unmarshalOWebhookType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx, "UNREGISTER_APPLICATION")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalOString2ᚖstring(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, webhookType, idField)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unpairApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unpairApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createApplicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createApplicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateApplicationTemplate(rctx, fc.Args["in"].(ApplicationTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createApplicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createApplicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createApplicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerApplicationFromTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerApplicationFromTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterApplicationFromTemplate(rctx, fc.Args["in"].(ApplicationFromTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerApplicationFromTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventType(ctx, "NEW_APPLICATION")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive1, eventType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerApplicationFromTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerApplicationFromTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateApplicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateApplicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateApplicationTemplate(rctx, fc.Args["id"].(string), fc.Args["override"].(*bool), fc.Args["in"].(ApplicationTemplateUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateApplicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateApplicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateApplicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApplicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApplicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteApplicationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteApplicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApplicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApplicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_mergeApplications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_mergeApplications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MergeApplications(rctx, fc.Args["destinationID"].(string), fc.Args["sourceID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.mergeApplications")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_mergeApplications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_mergeApplications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterRuntime(rctx, fc.Args["in"].(RuntimeRegisterInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRuntime(rctx, fc.Args["id"].(string), fc.Args["in"].(RuntimeUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterRuntime(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerRuntimeContext(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerRuntimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterRuntimeContext(rctx, fc.Args["runtimeID"].(string), fc.Args["in"].(RuntimeContextInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerRuntimeContext")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimeContext); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContext`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerRuntimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerRuntimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRuntimeContext(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRuntimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRuntimeContext(rctx, fc.Args["id"].(string), fc.Args["in"].(RuntimeContextInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateRuntimeContext")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimeContext); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContext`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRuntimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRuntimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterRuntimeContext(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterRuntimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterRuntimeContext(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterRuntimeContext")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimeContext); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContext`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterRuntimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterRuntimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterIntegrationSystem(rctx, fc.Args["in"].(IntegrationSystemInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateIntegrationSystem(rctx, fc.Args["id"].(string), fc.Args["in"].(IntegrationSystemInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterIntegrationSystem(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddWebhook(rctx, fc.Args["applicationID"].(*string), fc.Args["applicationTemplateID"].(*string), fc.Args["runtimeID"].(*string), fc.Args["formationTemplateID"].(*string), fc.Args["in"].(WebhookInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addWebhook")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Webhook)
	fc.Result = res
	return ec.marshalNWebhook2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateWebhook(rctx, fc.Args["webhookID"].(string), fc.Args["in"].(WebhookInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateWebhook")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Webhook)
	fc.Result = res
	return ec.marshalNWebhook2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteWebhook(rctx, fc.Args["webhookID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteWebhook")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Webhook)
	fc.Result = res
	return ec.marshalNWebhook2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAPIDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addAPIDefinitionToBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddAPIDefinitionToBundle(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addAPIDefinitionToBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addAPIDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAPIDefinitionToBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAPIDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addAPIDefinitionToApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddAPIDefinitionToApplication(rctx, fc.Args["appID"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addAPIDefinitionToApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addAPIDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAPIDefinitionToApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAPIDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAPIDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAPIDefinition(rctx, fc.Args["id"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateAPIDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAPIDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAPIDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAPIDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAPIDefinitionForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAPIDefinitionForApplication(rctx, fc.Args["id"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateAPIDefinitionForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAPIDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAPIDefinitionForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAPIDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAPIDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteAPIDefinition(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteAPIDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAPIDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAPIDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refetchAPISpec(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refetchAPISpec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RefetchAPISpec(rctx, fc.Args["apiID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.refetchAPISpec")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APISpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APISpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APISpec)
	fc.Result = res
	return ec.marshalNAPISpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refetchAPISpec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APISpec_id(ctx, field)
			case "data":
				return ec.fieldContext_APISpec_data(ctx, field)
			case "format":
				return ec.fieldContext_APISpec_format(ctx, field)
			case "type":
				return ec.fieldContext_APISpec_type(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_APISpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APISpec", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refetchAPISpec_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addIntegrationDependencyToApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addIntegrationDependencyToApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddIntegrationDependencyToApplication(rctx, fc.Args["appID"].(string), fc.Args["in"].(IntegrationDependencyInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addIntegrationDependencyToApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationDependency); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationDependency`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationDependency)
	fc.Result = res
	return ec.marshalNIntegrationDependency2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addIntegrationDependencyToApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationDependency_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationDependency_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationDependency_description(ctx, field)
			case "ordID":
				return ec.fieldContext_IntegrationDependency_ordID(ctx, field)
			case "partOfPackage":
				return ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
			case "visibility":
				return ec.fieldContext_IntegrationDependency_visibility(ctx, field)
			case "releaseStatus":
				return ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
			case "mandatory":
				return ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
			case "aspects":
				return ec.fieldContext_IntegrationDependency_aspects(ctx, field)
			case "version":
				return ec.fieldContext_IntegrationDependency_version(ctx, field)
			case "labels":
				return ec.fieldContext_IntegrationDependency_labels(ctx, field)
			case "created_at":
				return ec.fieldContext_IntegrationDependency_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_IntegrationDependency_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addIntegrationDependencyToApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteIntegrationDependency(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteIntegrationDependency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteIntegrationDependency(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteIntegrationDependency")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationDependency); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationDependency`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationDependency)
	fc.Result = res
	return ec.marshalNIntegrationDependency2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteIntegrationDependency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationDependency_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationDependency_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationDependency_description(ctx, field)
			case "ordID":
				return ec.fieldContext_IntegrationDependency_ordID(ctx, field)
			case "partOfPackage":
				return ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
			case "visibility":
				return ec.fieldContext_IntegrationDependency_visibility(ctx, field)
			case "releaseStatus":
				return ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
			case "mandatory":
				return ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
			case "aspects":
				return ec.fieldContext_IntegrationDependency_aspects(ctx, field)
			case "version":
				return ec.fieldContext_IntegrationDependency_version(ctx, field)
			case "labels":
				return ec.fieldContext_IntegrationDependency_labels(ctx, field)
			case "created_at":
				return ec.fieldContext_IntegrationDependency_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_IntegrationDependency_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteIntegrationDependency_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestOneTimeTokenForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestOneTimeTokenForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestOneTimeTokenForRuntime(rctx, fc.Args["id"].(string), fc.Args["systemAuthID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestOneTimeTokenForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*OneTimeTokenForRuntime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.OneTimeTokenForRuntime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OneTimeTokenForRuntime)
	fc.Result = res
	return ec.marshalNOneTimeTokenForRuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenForRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestOneTimeTokenForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_OneTimeTokenForRuntime_token(ctx, field)
			case "connectorURL":
				return ec.fieldContext_OneTimeTokenForRuntime_connectorURL(ctx, field)
			case "used":
				return ec.fieldContext_OneTimeTokenForRuntime_used(ctx, field)
			case "expiresAt":
				return ec.fieldContext_OneTimeTokenForRuntime_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_OneTimeTokenForRuntime_createdAt(ctx, field)
			case "usedAt":
				return ec.fieldContext_OneTimeTokenForRuntime_usedAt(ctx, field)
			case "raw":
				return ec.fieldContext_OneTimeTokenForRuntime_raw(ctx, field)
			case "rawEncoded":
				return ec.fieldContext_OneTimeTokenForRuntime_rawEncoded(ctx, field)
			case "type":
				return ec.fieldContext_OneTimeTokenForRuntime_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OneTimeTokenForRuntime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestOneTimeTokenForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestOneTimeTokenForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestOneTimeTokenForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestOneTimeTokenForApplication(rctx, fc.Args["id"].(string), fc.Args["systemAuthID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestOneTimeTokenForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*OneTimeTokenForApplication); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.OneTimeTokenForApplication`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OneTimeTokenForApplication)
	fc.Result = res
	return ec.marshalNOneTimeTokenForApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenForApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestOneTimeTokenForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_OneTimeTokenForApplication_token(ctx, field)
			case "connectorURL":
				return ec.fieldContext_OneTimeTokenForApplication_connectorURL(ctx, field)
			case "legacyConnectorURL":
				return ec.fieldContext_OneTimeTokenForApplication_legacyConnectorURL(ctx, field)
			case "used":
				return ec.fieldContext_OneTimeTokenForApplication_used(ctx, field)
			case "expiresAt":
				return ec.fieldContext_OneTimeTokenForApplication_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_OneTimeTokenForApplication_createdAt(ctx, field)
			case "usedAt":
				return ec.fieldContext_OneTimeTokenForApplication_usedAt(ctx, field)
			case "raw":
				return ec.fieldContext_OneTimeTokenForApplication_raw(ctx, field)
			case "rawEncoded":
				return ec.fieldContext_OneTimeTokenForApplication_rawEncoded(ctx, field)
			case "type":
				return ec.fieldContext_OneTimeTokenForApplication_type(ctx, field)
			case "scenarioGroups":
				return ec.fieldContext_OneTimeTokenForApplication_scenarioGroups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OneTimeTokenForApplication", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestOneTimeTokenForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestClientCredentialsForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestClientCredentialsForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestClientCredentialsForRuntime(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestClientCredentialsForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestClientCredentialsForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestClientCredentialsForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestClientCredentialsForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestClientCredentialsForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestClientCredentialsForApplication(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestClientCredentialsForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestClientCredentialsForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestClientCredentialsForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestClientCredentialsForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestClientCredentialsForIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestClientCredentialsForIntegrationSystem(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestClientCredentialsForIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestClientCredentialsForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestClientCredentialsForIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSystemAuthForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSystemAuthForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSystemAuthForRuntime(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteSystemAuthForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSystemAuthForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSystemAuthForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSystemAuthForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSystemAuthForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSystemAuthForApplication(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteSystemAuthForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSystemAuthForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSystemAuthForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSystemAuthForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSystemAuthForIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSystemAuthForIntegrationSystem(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteSystemAuthForIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSystemAuthForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSystemAuthForIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSystemAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSystemAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSystemAuth(rctx, fc.Args["authID"].(string), fc.Args["in"].(AuthInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateSystemAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSystemAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSystemAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_invalidateSystemAuthOneTimeToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_invalidateSystemAuthOneTimeToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InvalidateSystemAuthOneTimeToken(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.invalidateSystemAuthOneTimeToken")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_invalidateSystemAuthOneTimeToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_invalidateSystemAuthOneTimeToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addEventDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addEventDefinitionToBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddEventDefinitionToBundle(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addEventDefinitionToBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addEventDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addEventDefinitionToBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addEventDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addEventDefinitionToApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddEventDefinitionToApplication(rctx, fc.Args["appID"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addEventDefinitionToApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addEventDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addEventDefinitionToApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEventDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventDefinition(rctx, fc.Args["id"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateEventDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEventDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEventDefinitionForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventDefinitionForApplication(rctx, fc.Args["id"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateEventDefinitionForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEventDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEventDefinitionForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEventDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEventDefinition(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteEventDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refetchEventDefinitionSpec(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refetchEventDefinitionSpec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RefetchEventDefinitionSpec(rctx, fc.Args["eventID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.refetchEventDefinitionSpec")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventSpec)
	fc.Result = res
	return ec.marshalNEventSpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refetchEventDefinitionSpec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventSpec_id(ctx, field)
			case "data":
				return ec.fieldContext_EventSpec_data(ctx, field)
			case "type":
				return ec.fieldContext_EventSpec_type(ctx, field)
			case "format":
				return ec.fieldContext_EventSpec_format(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_EventSpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventSpec", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refetchEventDefinitionSpec_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addDocumentToBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addDocumentToBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddDocumentToBundle(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(DocumentInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addDocumentToBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Document); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Document`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Document)
	fc.Result = res
	return ec.marshalNDocument2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocument(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addDocumentToBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addDocumentToBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDocument(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDocument(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDocument(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteDocument")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Document); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Document`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Document)
	fc.Result = res
	return ec.marshalNDocument2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocument(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDocument(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDocument_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateFormation(rctx, fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resynchronizeFormationNotifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resynchronizeFormationNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ResynchronizeFormationNotifications(rctx, fc.Args["formationID"].(string), fc.Args["reset"].(*bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.resynchronizeFormationNotifications")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resynchronizeFormationNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resynchronizeFormationNotifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finalizeDraftFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finalizeDraftFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FinalizeDraftFormation(rctx, fc.Args["formationID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.finalizeDraftFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finalizeDraftFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finalizeDraftFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteFormation(rctx, fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assignFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assignFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AssignFormation(rctx, fc.Args["objectID"].(string), fc.Args["objectType"].(FormationObjectType), fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.assignFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assignFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assignFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnassignFormation(rctx, fc.Args["objectID"].(string), fc.Args["objectType"].(FormationObjectType), fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unassignFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignFormationGlobal(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignFormationGlobal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnassignFormationGlobal(rctx, fc.Args["objectID"].(string), fc.Args["objectType"].(FormationObjectType), fc.Args["formation"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unassignFormationGlobal")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignFormationGlobal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignFormationGlobal_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFormationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFormationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateFormationConstraint(rctx, fc.Args["formationConstraint"].(FormationConstraintInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createFormationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFormationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFormationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFormationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFormationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteFormationConstraint(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteFormationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFormationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFormationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFormationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateFormationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateFormationConstraint(rctx, fc.Args["id"].(string), fc.Args["in"].(FormationConstraintUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateFormationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateFormationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFormationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachConstraintToFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachConstraintToFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AttachConstraintToFormationTemplate(rctx, fc.Args["constraintID"].(string), fc.Args["formationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.attachConstraintToFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ConstraintReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ConstraintReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ConstraintReference)
	fc.Result = res
	return ec.marshalNConstraintReference2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachConstraintToFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "constraintID":
				return ec.fieldContext_ConstraintReference_constraintID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_ConstraintReference_formationTemplateID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConstraintReference", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachConstraintToFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachConstraintFromFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachConstraintFromFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DetachConstraintFromFormationTemplate(rctx, fc.Args["constraintID"].(string), fc.Args["formationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.detachConstraintFromFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ConstraintReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ConstraintReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ConstraintReference)
	fc.Result = res
	return ec.marshalNConstraintReference2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachConstraintFromFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "constraintID":
				return ec.fieldContext_ConstraintReference_constraintID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_ConstraintReference_formationTemplateID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConstraintReference", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachConstraintFromFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLabelDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLabelDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateLabelDefinition(rctx, fc.Args["in"].(LabelDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createLabelDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LabelDefinition)
	fc.Result = res
	return ec.marshalNLabelDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLabelDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLabelDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLabelDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLabelDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateLabelDefinition(rctx, fc.Args["in"].(LabelDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateLabelDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LabelDefinition)
	fc.Result = res
	return ec.marshalNLabelDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLabelDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLabelDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setApplicationLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setApplicationLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetApplicationLabel(rctx, fc.Args["applicationID"].(string), fc.Args["key"].(string),
				func() interface{} {
					if fc.Args["value"] == nil {
						return nil
					}
					return fc.Args["value"].(interface{})
				}())
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setApplicationLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setApplicationLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setApplicationLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTenantLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTenantLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetTenantLabel(rctx, fc.Args["tenantID"].(string), fc.Args["key"].(string),
				func() interface{} {
					if fc.Args["value"] == nil {
						return nil
					}
					return fc.Args["value"].(interface{})
				}())
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setTenantLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTenantLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTenantLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApplicationLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApplicationLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteApplicationLabel(rctx, fc.Args["applicationID"].(string), fc.Args["key"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteApplicationLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApplicationLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApplicationLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setRuntimeLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setRuntimeLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetRuntimeLabel(rctx, fc.Args["runtimeID"].(string), fc.Args["key"].(string),
				func() interface{} {
					if fc.Args["value"] == nil {
						return nil
					}
					return fc.Args["value"].(interface{})
				}())
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setRuntimeLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setRuntimeLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setRuntimeLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRuntimeLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRuntimeLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteRuntimeLabel(rctx, fc.Args["runtimeID"].(string), fc.Args["key"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteRuntimeLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRuntimeLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRuntimeLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setDefaultEventingForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetDefaultEventingForApplication(rctx, fc.Args["appID"].(string), fc.Args["runtimeID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setDefaultEventingForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationEventingConfiguration); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationEventingConfiguration`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationEventingConfiguration)
	fc.Result = res
	return ec.marshalNApplicationEventingConfiguration2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEventingConfiguration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setDefaultEventingForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDefaultEventingForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDefaultEventingForApplication(rctx, fc.Args["appID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteDefaultEventingForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationEventingConfiguration); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationEventingConfiguration`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationEventingConfiguration)
	fc.Result = res
	return ec.marshalNApplicationEventingConfiguration2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEventingConfiguration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDefaultEventingForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetBundleInstanceAuth(rctx, fc.Args["authID"].(string), fc.Args["in"].(BundleInstanceAuthSetInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBundleInstanceAuth(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestBundleInstanceAuthCreation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestBundleInstanceAuthCreation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestBundleInstanceAuthCreation(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(BundleInstanceAuthRequestInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			applicationProvider, err := ec.unmarshalNString2string(ctx, "GetApplicationIDByBundle")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalNString2string(ctx, "bundleID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScenario == nil {
				return nil, errors.New("directive hasScenario is not implemented")
			}
			return ec.directives.HasScenario(ctx, nil, directive0, applicationProvider, idField)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestBundleInstanceAuthCreation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive1, path)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestBundleInstanceAuthCreation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestBundleInstanceAuthCreation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestBundleInstanceAuthDeletion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestBundleInstanceAuthDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestBundleInstanceAuthDeletion(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			applicationProvider, err := ec.unmarshalNString2string(ctx, "GetApplicationIDByBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalNString2string(ctx, "authID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScenario == nil {
				return nil, errors.New("directive hasScenario is not implemented")
			}
			return ec.directives.HasScenario(ctx, nil, directive0, applicationProvider, idField)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestBundleInstanceAuthDeletion")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive1, path)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestBundleInstanceAuthDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestBundleInstanceAuthDeletion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBundleInstanceAuth(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(BundleInstanceAuthCreateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateBundleInstanceAuth(rctx, fc.Args["id"].(string), fc.Args["bundleID"].(string), fc.Args["in"].(BundleInstanceAuthUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddBundle(rctx, fc.Args["applicationID"].(string), fc.Args["in"].(BundleCreateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalNBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateBundle(rctx, fc.Args["id"].(string), fc.Args["in"].(BundleUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalNBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBundle(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalNBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_writeTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_writeTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().WriteTenants(rctx, fc.Args["in"].([]*BusinessTenantMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.writeTenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventType(ctx, "NEW_MULTIPLE_TENANTS")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive1, eventType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_writeTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_writeTenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_writeTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_writeTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().WriteTenant(rctx, fc.Args["in"].(BusinessTenantMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.writeTenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventType(ctx, "NEW_SINGLE_TENANT")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive1, eventType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_writeTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_writeTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTenants(rctx, fc.Args["in"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteTenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTenant(rctx, fc.Args["id"].(string), fc.Args["in"].(BusinessTenantMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalNTenant2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_subscribeTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_subscribeTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SubscribeTenant(rctx, fc.Args["providerID"].(string), fc.Args["subaccountID"].(string), fc.Args["providerSubaccountID"].(string), fc.Args["consumerTenantID"].(string), fc.Args["region"].(string), fc.Args["subscriptionAppName"].(string), fc.Args["subscriptionPayload"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.subscribeTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_subscribeTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_subscribeTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unsubscribeTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unsubscribeTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnsubscribeTenant(rctx, fc.Args["providerID"].(string), fc.Args["subaccountID"].(string), fc.Args["providerSubaccountID"].(string), fc.Args["consumerTenantID"].(string), fc.Args["region"].(string), fc.Args["subscriptionPayload"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unsubscribeTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unsubscribeTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unsubscribeTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateFormationTemplate(rctx, fc.Args["in"].(FormationTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteFormationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateFormationTemplate(rctx, fc.Args["id"].(string), fc.Args["in"].(FormationTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCertificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateCertificateSubjectMapping(rctx, fc.Args["in"].(CertificateSubjectMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createCertificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalOCertificateSubjectMapping2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCertificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCertificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateCertificateSubjectMapping(rctx, fc.Args["id"].(string), fc.Args["in"].(CertificateSubjectMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateCertificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalOCertificateSubjectMapping2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCertificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteCertificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteCertificateSubjectMapping(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteCertificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalOCertificateSubjectMapping2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCertificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addTenantAccess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addTenantAccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddTenantAccess(rctx, fc.Args["in"].(TenantAccessInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addTenantAccess")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TenantAccess); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.TenantAccess`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TenantAccess)
	fc.Result = res
	return ec.marshalOTenantAccess2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addTenantAccess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tenantID":
				return ec.fieldContext_TenantAccess_tenantID(ctx, field)
			case "resourceType":
				return ec.fieldContext_TenantAccess_resourceType(ctx, field)
			case "resourceID":
				return ec.fieldContext_TenantAccess_resourceID(ctx, field)
			case "owner":
				return ec.fieldContext_TenantAccess_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TenantAccess", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addTenantAccess_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeTenantAccess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeTenantAccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveTenantAccess(rctx, fc.Args["tenantID"].(string), fc.Args["resourceID"].(string), fc.Args["resourceType"].(TenantAccessObjectType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.removeTenantAccess")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TenantAccess); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.TenantAccess`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TenantAccess)
	fc.Result = res
	return ec.marshalOTenantAccess2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeTenantAccess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tenantID":
				return ec.fieldContext_TenantAccess_tenantID(ctx, field)
			case "resourceType":
				return ec.fieldContext_TenantAccess_resourceType(ctx, field)
			case "resourceID":
				return ec.fieldContext_TenantAccess_resourceID(ctx, field)
			case "owner":
				return ec.fieldContext_TenantAccess_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TenantAccess", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeTenantAccess_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _OAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField, obj *OAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthCredentialData_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthCredentialData_clientSecret(ctx context.Context, field graphql.CollectedField, obj *OAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthCredentialData_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthCredentialData_clientSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthCredentialData_url(ctx context.Context, field graphql.CollectedField, obj *OAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthCredentialData_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthCredentialData_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_token(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_connectorURL(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_connectorURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_connectorURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_legacyConnectorURL(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_legacyConnectorURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LegacyConnectorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_legacyConnectorURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_used(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_expiresAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_createdAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_usedAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_usedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_usedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_raw(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForApplication().Raw(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_rawEncoded(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_rawEncoded(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForApplication().RawEncoded(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_rawEncoded(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_type(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(OneTimeTokenType)
	fc.Result = res
	return ec.marshalOOneTimeTokenType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OneTimeTokenType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_scenarioGroups(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_scenarioGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScenarioGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_scenarioGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_token(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_connectorURL(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_connectorURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_connectorURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_used(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_expiresAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_createdAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_usedAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_usedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_usedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_raw(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForRuntime().Raw(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_rawEncoded(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_rawEncoded(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForRuntime().RawEncoded(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_rawEncoded(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_type(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(OneTimeTokenType)
	fc.Result = res
	return ec.marshalOOneTimeTokenType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OneTimeTokenType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PageCursor)
	fc.Result = res
	return ec.marshalNPageCursor2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PageCursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PageCursor)
	fc.Result = res
	return ec.marshalNPageCursor2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PageCursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_name(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_description(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_jsonPath(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_jsonPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_jsonPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_optional(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Optional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_optional(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_apisForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_apisForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApisForApplication(rctx, fc.Args["appID"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.apisForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinitionPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinitionPage)
	fc.Result = res
	return ec.marshalOAPIDefinitionPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_apisForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_APIDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_APIDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_APIDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_apisForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_eventsForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_eventsForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().EventsForApplication(rctx, fc.Args["appID"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.eventsForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinitionPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinitionPage)
	fc.Result = res
	return ec.marshalOEventDefinitionPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_eventsForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_EventDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_eventsForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Applications(rctx, fc.Args["filter"].([]*LabelFilter), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applications")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationPage)
	fc.Result = res
	return ec.marshalNApplicationPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ApplicationPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ApplicationPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ApplicationPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Application(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			applicationProvider, err := ec.unmarshalNString2string(ctx, "GetApplicationID")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalNString2string(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScenario == nil {
				return nil, errors.New("directive hasScenario is not implemented")
			}
			return ec.directives.HasScenario(ctx, nil, directive0, applicationProvider, idField)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.application")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive1, path)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalOApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_application_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationBySystemNumber(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationBySystemNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationBySystemNumber(rctx, fc.Args["systemNumber"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationBySystemNumber")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalOApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationBySystemNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationBySystemNumber_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationByLocalTenantIDAndAppTemplateID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationByLocalTenantIDAndAppTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationByLocalTenantIDAndAppTemplateID(rctx, fc.Args["localTenantID"].(string), fc.Args["applicationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationByLocalTenantIDAndAppTemplateID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalOApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationByLocalTenantIDAndAppTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationByLocalTenantIDAndAppTemplateID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationsForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationsForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationsForRuntime(rctx, fc.Args["runtimeID"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationsForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationPage)
	fc.Result = res
	return ec.marshalNApplicationPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationsForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ApplicationPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ApplicationPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ApplicationPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationsForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationTemplates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationTemplates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationTemplates(rctx, fc.Args["filter"].([]*LabelFilter), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationTemplates")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplatePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplatePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplatePage)
	fc.Result = res
	return ec.marshalNApplicationTemplatePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplatePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationTemplates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ApplicationTemplatePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ApplicationTemplatePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ApplicationTemplatePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplatePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationTemplates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalOApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_runtimes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtimes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Runtimes(rctx, fc.Args["filter"].([]*LabelFilter), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.runtimes")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimePage)
	fc.Result = res
	return ec.marshalNRuntimePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtimes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_RuntimePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RuntimePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RuntimePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runtimes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_runtime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Runtime(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.runtime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalORuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runtime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_runtimeByTokenIssuer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtimeByTokenIssuer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RuntimeByTokenIssuer(rctx, fc.Args["issuer"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalORuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtimeByTokenIssuer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runtimeByTokenIssuer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_labelDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_labelDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().LabelDefinitions(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.labelDefinitions")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*LabelDefinition)
	fc.Result = res
	return ec.marshalNLabelDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_labelDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_labelDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_labelDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().LabelDefinition(rctx, fc.Args["key"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.labelDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LabelDefinition)
	fc.Result = res
	return ec.marshalOLabelDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_labelDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_labelDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bundleByInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bundleByInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BundleByInstanceAuth(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.bundleByInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalOBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bundleByInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bundleByInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BundleInstanceAuth(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.bundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalOBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_healthChecks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_healthChecks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().HealthChecks(rctx, fc.Args["types"].([]HealthCheckType), fc.Args["origin"].(*string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.healthChecks")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*HealthCheckPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.HealthCheckPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HealthCheckPage)
	fc.Result = res
	return ec.marshalNHealthCheckPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_healthChecks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_HealthCheckPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_HealthCheckPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_HealthCheckPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_healthChecks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_integrationSystems(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_integrationSystems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IntegrationSystems(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.integrationSystems")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystemPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystemPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystemPage)
	fc.Result = res
	return ec.marshalNIntegrationSystemPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_integrationSystems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_IntegrationSystemPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_IntegrationSystemPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_IntegrationSystemPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystemPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_integrationSystems_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_integrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_integrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IntegrationSystem(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.integrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalOIntegrationSystem2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_integrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_integrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Viewer(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.viewer")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Viewer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Viewer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Viewer)
	fc.Result = res
	return ec.marshalNViewer2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "type":
				return ec.fieldContext_Viewer_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Tenants(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor), fc.Args["searchTerm"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TenantPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.TenantPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TenantPage)
	fc.Result = res
	return ec.marshalNTenantPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_TenantPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TenantPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TenantPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TenantPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenantByExternalID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenantByExternalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TenantByExternalID(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalOTenant2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenantByExternalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenantByExternalID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenantByInternalID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenantByInternalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TenantByInternalID(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenantByInternalID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalOTenant2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenantByInternalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenantByInternalID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenantByLowestOwnerForResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenantByLowestOwnerForResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TenantByLowestOwnerForResource(rctx, fc.Args["id"].(string), fc.Args["resource"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenantByLowestOwnerForResource")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenantByLowestOwnerForResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenantByLowestOwnerForResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_rootTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_rootTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().RootTenants(rctx, fc.Args["externalTenant"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.rootTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tenant)
	fc.Result = res
	return ec.marshalOTenant2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_rootTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_rootTenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_automaticScenarioAssignmentForScenario(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_automaticScenarioAssignmentForScenario(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AutomaticScenarioAssignmentForScenario(rctx, fc.Args["scenarioName"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.automaticScenarioAssignmentForScenario")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AutomaticScenarioAssignment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.AutomaticScenarioAssignment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AutomaticScenarioAssignment)
	fc.Result = res
	return ec.marshalOAutomaticScenarioAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_automaticScenarioAssignmentForScenario(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenarioName":
				return ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
			case "selector":
				return ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_automaticScenarioAssignmentForScenario_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_automaticScenarioAssignmentsForSelector(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_automaticScenarioAssignmentsForSelector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AutomaticScenarioAssignmentsForSelector(rctx, fc.Args["selector"].(LabelSelectorInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.automaticScenarioAssignmentsForSelector")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AutomaticScenarioAssignment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.AutomaticScenarioAssignment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AutomaticScenarioAssignment)
	fc.Result = res
	return ec.marshalNAutomaticScenarioAssignment2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_automaticScenarioAssignmentsForSelector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenarioName":
				return ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
			case "selector":
				return ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_automaticScenarioAssignmentsForSelector_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_automaticScenarioAssignments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_automaticScenarioAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AutomaticScenarioAssignments(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.automaticScenarioAssignments")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AutomaticScenarioAssignmentPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.AutomaticScenarioAssignmentPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AutomaticScenarioAssignmentPage)
	fc.Result = res
	return ec.marshalOAutomaticScenarioAssignmentPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignmentPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_automaticScenarioAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_AutomaticScenarioAssignmentPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AutomaticScenarioAssignmentPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_AutomaticScenarioAssignmentPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignmentPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_automaticScenarioAssignments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_systemAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_systemAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SystemAuth(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.systemAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalOSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_systemAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_systemAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_systemAuthByToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_systemAuthByToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SystemAuthByToken(rctx, fc.Args["token"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.systemAuthByToken")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalOSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_systemAuthByToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_systemAuthByToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Formation(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalOFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationByName(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationByName")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalOFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationByName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Formations(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formations")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationPage)
	fc.Result = res
	return ec.marshalNFormationPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationsForObject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationsForObject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationsForObject(rctx, fc.Args["objectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationsForObject")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Formation)
	fc.Result = res
	return ec.marshalNFormation2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationsForObject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationsForObject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationConstraints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationConstraints(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationConstraints")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationConstraint(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationConstraintsByFormationType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationConstraintsByFormationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationConstraintsByFormationType(rctx, fc.Args["formationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationConstraints")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationConstraintsByFormationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationConstraintsByFormationType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationTemplates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationTemplates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationTemplates(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationTemplates")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplatePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplatePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationTemplatePage)
	fc.Result = res
	return ec.marshalNFormationTemplatePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplatePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationTemplates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationTemplatePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationTemplatePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationTemplatePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplatePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationTemplates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationTemplatesByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationTemplatesByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationTemplatesByName(rctx, fc.Args["name"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationTemplates")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplatePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplatePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationTemplatePage)
	fc.Result = res
	return ec.marshalNFormationTemplatePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplatePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationTemplatesByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationTemplatePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationTemplatePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationTemplatePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplatePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationTemplatesByName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_certificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_certificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CertificateSubjectMapping(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.certificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalNCertificateSubjectMapping2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_certificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_certificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_certificateSubjectMappings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_certificateSubjectMappings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CertificateSubjectMappings(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.certificateSubjectMappings")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMappingPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMappingPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMappingPage)
	fc.Result = res
	return ec.marshalNCertificateSubjectMappingPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_certificateSubjectMappings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_CertificateSubjectMappingPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CertificateSubjectMappingPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_CertificateSubjectMappingPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMappingPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_certificateSubjectMappings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_id(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_metadata(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeMetadata)
	fc.Result = res
	return ec.marshalNRuntimeMetadata2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "creationTimestamp":
				return ec.fieldContext_RuntimeMetadata_creationTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_name(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_description(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_labels(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Runtime_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_webhooks(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Runtime().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.runtime.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_status(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeStatus)
	fc.Result = res
	return ec.marshalNRuntimeStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_RuntimeStatus_condition(ctx, field)
			case "timestamp":
				return ec.fieldContext_RuntimeStatus_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_auths(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_auths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().Auths(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*RuntimeSystemAuth)
	fc.Result = res
	return ec.marshalORuntimeSystemAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeSystemAuthᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_auths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeSystemAuth_id(ctx, field)
			case "auth":
				return ec.fieldContext_RuntimeSystemAuth_auth(ctx, field)
			case "type":
				return ec.fieldContext_RuntimeSystemAuth_type(ctx, field)
			case "tenantId":
				return ec.fieldContext_RuntimeSystemAuth_tenantId(ctx, field)
			case "referenceObjectId":
				return ec.fieldContext_RuntimeSystemAuth_referenceObjectId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeSystemAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_eventingConfiguration(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().EventingConfiguration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RuntimeEventingConfiguration)
	fc.Result = res
	return ec.marshalORuntimeEventingConfiguration2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_eventingConfiguration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_RuntimeEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeEventingConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_runtimeContext(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_runtimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().RuntimeContext(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalORuntimeContext2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_runtimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Runtime_runtimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_runtimeContexts(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_runtimeContexts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().RuntimeContexts(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RuntimeContextPage)
	fc.Result = res
	return ec.marshalORuntimeContextPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContextPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_runtimeContexts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_RuntimeContextPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RuntimeContextPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RuntimeContextPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContextPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Runtime_runtimeContexts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_applicationNamespace(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_applicationNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_applicationNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_id(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_key(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_value(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_labels(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RuntimeContext().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RuntimeContext_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContextPage_data(ctx context.Context, field graphql.CollectedField, obj *RuntimeContextPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContextPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContextᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContextPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContextPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContextPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *RuntimeContextPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContextPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContextPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContextPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContextPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *RuntimeContextPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContextPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContextPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContextPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField, obj *RuntimeEventingConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeEventingConfiguration_defaultURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeEventingConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *RuntimeMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetadata_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimePage_data(ctx context.Context, field graphql.CollectedField, obj *RuntimePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *RuntimePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *RuntimePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeStatus_condition(ctx context.Context, field graphql.CollectedField, obj *RuntimeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(RuntimeStatusCondition)
	fc.Result = res
	return ec.marshalNRuntimeStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RuntimeStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *RuntimeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_id(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_auth(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.runtime.auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_type(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SystemAuthReferenceType)
	fc.Result = res
	return ec.marshalOSystemAuthReferenceType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuthReferenceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SystemAuthReferenceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_referenceObjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReferenceObjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_id(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_internalID(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_internalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_internalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_name(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_type(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_parents(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_parents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOID2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_parents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_initialized(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_initialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Initialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_initialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_labels(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tenant().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Tenant_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_provider(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_tenantID(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_tenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_tenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_resourceType(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TenantAccessObjectType)
	fc.Result = res
	return ec.marshalNTenantAccessObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccessObjectType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TenantAccessObjectType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_resourceID(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_resourceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_resourceID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_owner(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantPage_data(ctx context.Context, field graphql.CollectedField, obj *TenantPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tenant)
	fc.Result = res
	return ec.marshalNTenant2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *TenantPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *TenantPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_value(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_deprecated(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_deprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deprecated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_deprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_deprecatedSince(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_deprecatedSince(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecatedSince, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_deprecatedSince(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_forRemoval(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_forRemoval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForRemoval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_forRemoval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_id(ctx context.Context, field graphql.CollectedField, obj *Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_type(ctx context.Context, field graphql.CollectedField, obj *Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ViewerType)
	fc.Result = res
	return ec.marshalNViewerType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐViewerType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewerType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_id(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_applicationID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_applicationID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_applicationID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_applicationTemplateID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_applicationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_runtimeID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_runtimeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_runtimeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_integrationSystemID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_integrationSystemID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntegrationSystemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_integrationSystemID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_formationTemplateID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_formationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_formationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_type(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(WebhookType)
	fc.Result = res
	return ec.marshalNWebhookType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WebhookType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_mode(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*WebhookMode)
	fc.Result = res
	return ec.marshalOWebhookMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WebhookMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_correlationIdKey(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_correlationIdKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorrelationIDKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_correlationIdKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_retryInterval(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_retryInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetryInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_retryInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_timeout(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_url(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_auth(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.webhooks.auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_urlTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_urlTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_urlTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_inputTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_inputTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_inputTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_headerTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_headerTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeaderTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_headerTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_outputTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_outputTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutputTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_outputTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_statusTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_statusTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StatusTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_statusTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_createdAt(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAPIDefinitionInput(ctx context.Context, obj interface{}) (APIDefinitionInput, error) {
	var it APIDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "targetURL", "group", "spec", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "targetURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetURL = data
		case "group":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Group = data
		case "spec":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spec"))
			data, err := ec.unmarshalOAPISpecInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpecInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Spec = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOVersionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAPISpecInput(ctx context.Context, obj interface{}) (APISpecInput, error) {
	var it APISpecInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type", "format", "fetchRequest"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNAPISpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpecType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNSpecFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSpecFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "fetchRequest":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetchRequest"))
			data, err := ec.unmarshalOFetchRequestInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchRequest = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationFromTemplateInput(ctx context.Context, obj interface{}) (ApplicationFromTemplateInput, error) {
	var it ApplicationFromTemplateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "templateName", "values", "placeholdersPayload", "labels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "templateName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("templateName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TemplateName = data
		case "values":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalOTemplateValueInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTemplateValueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		case "placeholdersPayload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholdersPayload"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlaceholdersPayload = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationJSONInput(ctx context.Context, obj interface{}) (ApplicationJSONInput, error) {
	var it ApplicationJSONInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "providerName", "description", "labels", "webhooks", "healthCheckURL", "baseUrl", "applicationNamespace", "integrationSystemID", "statusCondition", "localTenantID", "bundles"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "providerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "healthCheckURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("healthCheckURL"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HealthCheckURL = data
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		case "integrationSystemID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("integrationSystemID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntegrationSystemID = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalOApplicationStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "localTenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocalTenantID = data
		case "bundles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundles"))
			data, err := ec.unmarshalOBundleCreateInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleCreateInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bundles = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationRegisterInput(ctx context.Context, obj interface{}) (ApplicationRegisterInput, error) {
	var it ApplicationRegisterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "providerName", "description", "labels", "webhooks", "healthCheckURL", "baseUrl", "applicationNamespace", "integrationSystemID", "statusCondition", "localTenantID", "bundles"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "providerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "healthCheckURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("healthCheckURL"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HealthCheckURL = data
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		case "integrationSystemID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("integrationSystemID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntegrationSystemID = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalOApplicationStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "localTenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.application.localTenantID")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.LocalTenantID = data
			} else if tmp == nil {
				it.LocalTenantID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "bundles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundles"))
			data, err := ec.unmarshalOBundleCreateInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleCreateInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bundles = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationTemplateInput(ctx context.Context, obj interface{}) (ApplicationTemplateInput, error) {
	var it ApplicationTemplateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "webhooks", "description", "labels", "applicationInput", "placeholders", "accessLevel", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "applicationInput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationInput"))
			data, err := ec.unmarshalNApplicationJSONInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationJSONInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationInput = data
		case "placeholders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholders"))
			data, err := ec.unmarshalOPlaceholderDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinitionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Placeholders = data
		case "accessLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessLevel"))
			data, err := ec.unmarshalNApplicationTemplateAccessLevel2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateAccessLevel(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessLevel = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationTemplateUpdateInput(ctx context.Context, obj interface{}) (ApplicationTemplateUpdateInput, error) {
	var it ApplicationTemplateUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "webhooks", "description", "applicationInput", "placeholders", "labels", "accessLevel", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "applicationInput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationInput"))
			data, err := ec.unmarshalNApplicationJSONInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationJSONInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationInput = data
		case "placeholders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholders"))
			data, err := ec.unmarshalOPlaceholderDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinitionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Placeholders = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.application_template.labels")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(Labels); ok {
				it.Labels = data
			} else if tmp == nil {
				it.Labels = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.Labels`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "accessLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessLevel"))
			data, err := ec.unmarshalNApplicationTemplateAccessLevel2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateAccessLevel(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessLevel = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationUpdateInput(ctx context.Context, obj interface{}) (ApplicationUpdateInput, error) {
	var it ApplicationUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"providerName", "description", "healthCheckURL", "baseUrl", "applicationNamespace", "integrationSystemID", "statusCondition", "localTenantID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "providerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "healthCheckURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("healthCheckURL"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HealthCheckURL = data
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		case "integrationSystemID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("integrationSystemID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntegrationSystemID = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalOApplicationStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "localTenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.application.localTenantID")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.LocalTenantID = data
			} else if tmp == nil {
				it.LocalTenantID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectAPIDefinitionInput(ctx context.Context, obj interface{}) (AspectAPIDefinitionInput, error) {
	var it AspectAPIDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ordId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ordId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrdID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectEventDefinitionInput(ctx context.Context, obj interface{}) (AspectEventDefinitionInput, error) {
	var it AspectEventDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ordId", "subset"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ordId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrdID = data
		case "subset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subset"))
			data, err := ec.unmarshalOAspectEventDefinitionSubsetInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubsetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subset = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectEventDefinitionSubsetInput(ctx context.Context, obj interface{}) (AspectEventDefinitionSubsetInput, error) {
	var it AspectEventDefinitionSubsetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eventType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eventType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectInput(ctx context.Context, obj interface{}) (AspectInput, error) {
	var it AspectInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "mandatory", "apiResources", "eventResources"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "mandatory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mandatory"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mandatory = data
		case "apiResources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiResources"))
			data, err := ec.unmarshalOAspectAPIDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinitionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIResources = data
		case "eventResources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventResources"))
			data, err := ec.unmarshalOAspectEventDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventResources = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthInput(ctx context.Context, obj interface{}) (AuthInput, error) {
	var it AuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"credential", "accessStrategy", "additionalHeaders", "additionalHeadersSerialized", "additionalQueryParams", "additionalQueryParamsSerialized", "requestAuth", "certCommonName", "oneTimeToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "credential":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credential"))
			data, err := ec.unmarshalOCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Credential = data
		case "accessStrategy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessStrategy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessStrategy = data
		case "additionalHeaders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeaders"))
			data, err := ec.unmarshalOHttpHeaders2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeaders(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeaders = data
		case "additionalHeadersSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeadersSerialized"))
			data, err := ec.unmarshalOHttpHeadersSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeadersSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeadersSerialized = data
		case "additionalQueryParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParams"))
			data, err := ec.unmarshalOQueryParams2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParams = data
		case "additionalQueryParamsSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParamsSerialized"))
			data, err := ec.unmarshalOQueryParamsSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParamsSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParamsSerialized = data
		case "requestAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestAuth"))
			data, err := ec.unmarshalOCredentialRequestAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialRequestAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestAuth = data
		case "certCommonName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certCommonName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CertCommonName = data
		case "oneTimeToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oneTimeToken"))
			data, err := ec.unmarshalOOneTimeTokenInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.OneTimeToken = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBasicCredentialDataInput(ctx context.Context, obj interface{}) (BasicCredentialDataInput, error) {
	var it BasicCredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleCreateInput(ctx context.Context, obj interface{}) (BundleCreateInput, error) {
	var it BundleCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "instanceAuthRequestInputSchema", "defaultInstanceAuth", "apiDefinitions", "eventDefinitions", "documents", "correlationIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "instanceAuthRequestInputSchema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceAuthRequestInputSchema"))
			data, err := ec.unmarshalOJSONSchema2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSONSchema(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceAuthRequestInputSchema = data
		case "defaultInstanceAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultInstanceAuth"))
			data, err := ec.unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultInstanceAuth = data
		case "apiDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiDefinitions"))
			data, err := ec.unmarshalOAPIDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIDefinitions = data
		case "eventDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventDefinitions"))
			data, err := ec.unmarshalOEventDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventDefinitions = data
		case "documents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("documents"))
			data, err := ec.unmarshalODocumentInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Documents = data
		case "correlationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("correlationIDs"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CorrelationIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthCreateInput(ctx context.Context, obj interface{}) (BundleInstanceAuthCreateInput, error) {
	var it BundleInstanceAuthCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"context", "inputParams", "auth", "runtimeID", "runtimeContextID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "context":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
			data, err := ec.unmarshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Context = data
		case "inputParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputParams"))
			data, err := ec.unmarshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputParams = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalNAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "runtimeID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeID = data
		case "runtimeContextID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeContextID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeContextID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthRequestInput(ctx context.Context, obj interface{}) (BundleInstanceAuthRequestInput, error) {
	var it BundleInstanceAuthRequestInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "context", "inputParams"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "context":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
			data, err := ec.unmarshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Context = data
		case "inputParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputParams"))
			data, err := ec.unmarshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputParams = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthSetInput(ctx context.Context, obj interface{}) (BundleInstanceAuthSetInput, error) {
	var it BundleInstanceAuthSetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"auth", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBundleInstanceAuthStatusInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthStatusInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthStatusInput(ctx context.Context, obj interface{}) (BundleInstanceAuthStatusInput, error) {
	var it BundleInstanceAuthStatusInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["condition"]; !present {
		asMap["condition"] = "SUCCEEDED"
	}

	fieldsInOrder := [...]string{"condition", "message", "reason"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "condition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("condition"))
			data, err := ec.unmarshalNBundleInstanceAuthSetStatusConditionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthSetStatusConditionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Condition = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "reason":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reason"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Reason = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthUpdateInput(ctx context.Context, obj interface{}) (BundleInstanceAuthUpdateInput, error) {
	var it BundleInstanceAuthUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"context", "inputParams", "auth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "context":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
			data, err := ec.unmarshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Context = data
		case "inputParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputParams"))
			data, err := ec.unmarshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputParams = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleUpdateInput(ctx context.Context, obj interface{}) (BundleUpdateInput, error) {
	var it BundleUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "instanceAuthRequestInputSchema", "defaultInstanceAuth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "instanceAuthRequestInputSchema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceAuthRequestInputSchema"))
			data, err := ec.unmarshalOJSONSchema2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSONSchema(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceAuthRequestInputSchema = data
		case "defaultInstanceAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultInstanceAuth"))
			data, err := ec.unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultInstanceAuth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBusinessTenantMappingInput(ctx context.Context, obj interface{}) (BusinessTenantMappingInput, error) {
	var it BusinessTenantMappingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "externalTenant", "parents", "subdomain", "region", "type", "provider", "licenseType", "customerId", "costObjectId", "costObjectType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "externalTenant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalTenant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalTenant = data
		case "parents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parents"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parents = data
		case "subdomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subdomain"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subdomain = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "licenseType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenseType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenseType = data
		case "customerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customerId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomerID = data
		case "costObjectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costObjectId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CostObjectID = data
		case "costObjectType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costObjectType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CostObjectType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCSRFTokenCredentialRequestAuthInput(ctx context.Context, obj interface{}) (CSRFTokenCredentialRequestAuthInput, error) {
	var it CSRFTokenCredentialRequestAuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tokenEndpointURL", "credential", "additionalHeaders", "additionalHeadersSerialized", "additionalQueryParams", "additionalQueryParamsSerialized"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tokenEndpointURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenEndpointURL = data
		case "credential":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credential"))
			data, err := ec.unmarshalOCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Credential = data
		case "additionalHeaders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeaders"))
			data, err := ec.unmarshalOHttpHeaders2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeaders(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeaders = data
		case "additionalHeadersSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeadersSerialized"))
			data, err := ec.unmarshalOHttpHeadersSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeadersSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeadersSerialized = data
		case "additionalQueryParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParams"))
			data, err := ec.unmarshalOQueryParams2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParams = data
		case "additionalQueryParamsSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParamsSerialized"))
			data, err := ec.unmarshalOQueryParamsSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParamsSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParamsSerialized = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCertificateOAuthCredentialDataInput(ctx context.Context, obj interface{}) (CertificateOAuthCredentialDataInput, error) {
	var it CertificateOAuthCredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientId", "certificate", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "certificate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certificate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Certificate = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCertificateSubjectMappingInput(ctx context.Context, obj interface{}) (CertificateSubjectMappingInput, error) {
	var it CertificateSubjectMappingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subject", "consumerType", "internalConsumerID", "tenantAccessLevels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subject"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subject = data
		case "consumerType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consumerType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConsumerType = data
		case "internalConsumerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("internalConsumerID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.InternalConsumerID = data
		case "tenantAccessLevels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantAccessLevels"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TenantAccessLevels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialDataInput(ctx context.Context, obj interface{}) (CredentialDataInput, error) {
	var it CredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"basic", "oauth", "certificateOAuth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "basic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basic"))
			data, err := ec.unmarshalOBasicCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBasicCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Basic = data
		case "oauth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth"))
			data, err := ec.unmarshalOOAuthCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOAuthCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Oauth = data
		case "certificateOAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certificateOAuth"))
			data, err := ec.unmarshalOCertificateOAuthCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateOAuthCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CertificateOAuth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialRequestAuthInput(ctx context.Context, obj interface{}) (CredentialRequestAuthInput, error) {
	var it CredentialRequestAuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"csrf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "csrf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("csrf"))
			data, err := ec.unmarshalOCSRFTokenCredentialRequestAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCSRFTokenCredentialRequestAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Csrf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDocumentInput(ctx context.Context, obj interface{}) (DocumentInput, error) {
	var it DocumentInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "displayName", "description", "format", "kind", "data", "fetchRequest"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNDocumentFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "kind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Kind = data
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "fetchRequest":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetchRequest"))
			data, err := ec.unmarshalOFetchRequestInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchRequest = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventDefinitionInput(ctx context.Context, obj interface{}) (EventDefinitionInput, error) {
	var it EventDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "spec", "group", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "spec":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spec"))
			data, err := ec.unmarshalOEventSpecInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpecInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Spec = data
		case "group":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Group = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOVersionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventSpecInput(ctx context.Context, obj interface{}) (EventSpecInput, error) {
	var it EventSpecInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type", "format", "fetchRequest"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNEventSpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpecType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNSpecFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSpecFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "fetchRequest":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetchRequest"))
			data, err := ec.unmarshalOFetchRequestInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchRequest = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFetchRequestInput(ctx context.Context, obj interface{}) (FetchRequestInput, error) {
	var it FetchRequestInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["mode"]; !present {
		asMap["mode"] = "SINGLE"
	}

	fieldsInOrder := [...]string{"url", "auth", "mode", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOFetchMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "filter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationConstraintInput(ctx context.Context, obj interface{}) (FormationConstraintInput, error) {
	var it FormationConstraintInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "constraintType", "targetOperation", "operator", "resourceType", "resourceSubtype", "inputTemplate", "constraintScope", "priority"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "constraintType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintType"))
			data, err := ec.unmarshalNConstraintType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConstraintType = data
		case "targetOperation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetOperation"))
			data, err := ec.unmarshalNTargetOperation2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTargetOperation(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetOperation = data
		case "operator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operator"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operator = data
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalNResourceType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐResourceType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "resourceSubtype":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceSubtype"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceSubtype = data
		case "inputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputTemplate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputTemplate = data
		case "constraintScope":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintScope"))
			data, err := ec.unmarshalNConstraintScope2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintScope(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConstraintScope = data
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Priority = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationConstraintUpdateInput(ctx context.Context, obj interface{}) (FormationConstraintUpdateInput, error) {
	var it FormationConstraintUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"inputTemplate", "priority", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "inputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputTemplate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputTemplate = data
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Priority = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationInput(ctx context.Context, obj interface{}) (FormationInput, error) {
	var it FormationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "templateName", "state"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "templateName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("templateName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TemplateName = data
		case "state":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.formation.state")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.State = data
			} else if tmp == nil {
				it.State = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationTemplateInput(ctx context.Context, obj interface{}) (FormationTemplateInput, error) {
	var it FormationTemplateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "applicationTypes", "runtimeTypes", "runtimeTypeDisplayName", "runtimeArtifactKind", "webhooks", "leadingProductIDs", "supportsReset", "discoveryConsumers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "applicationTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationTypes"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationTypes = data
		case "runtimeTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeTypes"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeTypes = data
		case "runtimeTypeDisplayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeTypeDisplayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeTypeDisplayName = data
		case "runtimeArtifactKind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeArtifactKind"))
			data, err := ec.unmarshalOArtifactType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐArtifactType(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeArtifactKind = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "leadingProductIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("leadingProductIDs"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LeadingProductIDs = data
		case "supportsReset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("supportsReset"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SupportsReset = data
		case "discoveryConsumers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discoveryConsumers"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DiscoveryConsumers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntegrationDependencyInput(ctx context.Context, obj interface{}) (IntegrationDependencyInput, error) {
	var it IntegrationDependencyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "ordID", "partOfPackage", "visibility", "releaseStatus", "mandatory", "aspects", "version", "labels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "ordID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrdID = data
		case "partOfPackage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("partOfPackage"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PartOfPackage = data
		case "visibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibility"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Visibility = data
		case "releaseStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseStatus"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReleaseStatus = data
		case "mandatory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mandatory"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mandatory = data
		case "aspects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aspects"))
			data, err := ec.unmarshalOAspectInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aspects = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOVersionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntegrationSystemInput(ctx context.Context, obj interface{}) (IntegrationSystemInput, error) {
	var it IntegrationSystemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelDefinitionInput(ctx context.Context, obj interface{}) (LabelDefinitionInput, error) {
	var it LabelDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "schema"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "schema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schema"))
			data, err := ec.unmarshalOJSONSchema2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSONSchema(ctx, v)
			if err != nil {
				return it, err
			}
			it.Schema = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelFilter(ctx context.Context, obj interface{}) (LabelFilter, error) {
	var it LabelFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "query"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "query":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelInput(ctx context.Context, obj interface{}) (LabelInput, error) {
	var it LabelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelSelectorInput(ctx context.Context, obj interface{}) (LabelSelectorInput, error) {
	var it LabelSelectorInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOAuthCredentialDataInput(ctx context.Context, obj interface{}) (OAuthCredentialDataInput, error) {
	var it OAuthCredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientId", "clientSecret", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecret = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOneTimeTokenInput(ctx context.Context, obj interface{}) (OneTimeTokenInput, error) {
	var it OneTimeTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token", "connectorURL", "used", "expiresAt", "createdAt", "usedAt", "raw", "rawEncoded", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		case "connectorURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorURL"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorURL = data
		case "used":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("used"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Used = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "usedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usedAt"))
			data, err := ec.unmarshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsedAt = data
		case "raw":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("raw"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Raw = data
		case "rawEncoded":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawEncoded"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RawEncoded = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOOneTimeTokenType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaceholderDefinitionInput(ctx context.Context, obj interface{}) (PlaceholderDefinitionInput, error) {
	var it PlaceholderDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["optional"]; !present {
		asMap["optional"] = false
	}

	fieldsInOrder := [...]string{"name", "description", "jsonPath", "optional"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "jsonPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jsonPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.JSONPath = data
		case "optional":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("optional"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Optional = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeContextInput(ctx context.Context, obj interface{}) (RuntimeContextInput, error) {
	var it RuntimeContextInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeRegisterInput(ctx context.Context, obj interface{}) (RuntimeRegisterInput, error) {
	var it RuntimeRegisterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "labels", "webhooks", "statusCondition", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalORuntimeStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeUpdateInput(ctx context.Context, obj interface{}) (RuntimeUpdateInput, error) {
	var it RuntimeUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "labels", "statusCondition", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalORuntimeStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSystemAuthUpdateInput(ctx context.Context, obj interface{}) (SystemAuthUpdateInput, error) {
	var it SystemAuthUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"auth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTemplateValueInput(ctx context.Context, obj interface{}) (TemplateValueInput, error) {
	var it TemplateValueInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"placeholder", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "placeholder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholder"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Placeholder = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTenantAccessInput(ctx context.Context, obj interface{}) (TenantAccessInput, error) {
	var it TenantAccessInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tenantID", "resourceType", "resourceID", "owner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TenantID = data
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalNTenantAccessObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccessObjectType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "resourceID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceID = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVersionInput(ctx context.Context, obj interface{}) (VersionInput, error) {
	var it VersionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["deprecated"]; !present {
		asMap["deprecated"] = false
	}
	if _, present := asMap["forRemoval"]; !present {
		asMap["forRemoval"] = false
	}

	fieldsInOrder := [...]string{"value", "deprecated", "deprecatedSince", "forRemoval"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "deprecated":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deprecated"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deprecated = data
		case "deprecatedSince":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deprecatedSince"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeprecatedSince = data
		case "forRemoval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forRemoval"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ForRemoval = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookInput(ctx context.Context, obj interface{}) (WebhookInput, error) {
	var it WebhookInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "url", "auth", "mode", "version", "correlationIdKey", "retryInterval", "timeout", "urlTemplate", "inputTemplate", "headerTemplate", "outputTemplate", "statusTemplate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNWebhookType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOWebhookMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "correlationIdKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("correlationIdKey"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CorrelationIDKey = data
		case "retryInterval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryInterval"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RetryInterval = data
		case "timeout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeout"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timeout = data
		case "urlTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlTemplate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URLTemplate = data
		case "inputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputTemplate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputTemplate = data
		case "headerTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headerTemplate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HeaderTemplate = data
		case "outputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("outputTemplate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OutputTemplate = data
		case "statusTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusTemplate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusTemplate = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _CredentialData(ctx context.Context, sel ast.SelectionSet, obj CredentialData) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case BasicCredentialData:
		return ec._BasicCredentialData(ctx, sel, &obj)
	case *BasicCredentialData:
		if obj == nil {
			return graphql.Null
		}
		return ec._BasicCredentialData(ctx, sel, obj)
	case OAuthCredentialData:
		return ec._OAuthCredentialData(ctx, sel, &obj)
	case *OAuthCredentialData:
		if obj == nil {
			return graphql.Null
		}
		return ec._OAuthCredentialData(ctx, sel, obj)
	case CertificateOAuthCredentialData:
		return ec._CertificateOAuthCredentialData(ctx, sel, &obj)
	case *CertificateOAuthCredentialData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CertificateOAuthCredentialData(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _FormationParticipant(ctx context.Context, sel ast.SelectionSet, obj FormationParticipant) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	case *Runtime:
		if obj == nil {
			return graphql.Null
		}
		return ec._Runtime(ctx, sel, obj)
	case *RuntimeContext:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimeContext(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _OneTimeToken(ctx context.Context, sel ast.SelectionSet, obj OneTimeToken) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *OneTimeTokenForApplication:
		if obj == nil {
			return graphql.Null
		}
		return ec._OneTimeTokenForApplication(ctx, sel, obj)
	case *OneTimeTokenForRuntime:
		if obj == nil {
			return graphql.Null
		}
		return ec._OneTimeTokenForRuntime(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Pageable(ctx context.Context, sel ast.SelectionSet, obj Pageable) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case APIDefinitionPage:
		return ec._APIDefinitionPage(ctx, sel, &obj)
	case *APIDefinitionPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._APIDefinitionPage(ctx, sel, obj)
	case ApplicationPage:
		return ec._ApplicationPage(ctx, sel, &obj)
	case *ApplicationPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationPage(ctx, sel, obj)
	case ApplicationTemplatePage:
		return ec._ApplicationTemplatePage(ctx, sel, &obj)
	case *ApplicationTemplatePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationTemplatePage(ctx, sel, obj)
	case AutomaticScenarioAssignmentPage:
		return ec._AutomaticScenarioAssignmentPage(ctx, sel, &obj)
	case *AutomaticScenarioAssignmentPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._AutomaticScenarioAssignmentPage(ctx, sel, obj)
	case BundlePage:
		return ec._BundlePage(ctx, sel, &obj)
	case *BundlePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._BundlePage(ctx, sel, obj)
	case CertificateSubjectMappingPage:
		return ec._CertificateSubjectMappingPage(ctx, sel, &obj)
	case *CertificateSubjectMappingPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._CertificateSubjectMappingPage(ctx, sel, obj)
	case DocumentPage:
		return ec._DocumentPage(ctx, sel, &obj)
	case *DocumentPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._DocumentPage(ctx, sel, obj)
	case EventDefinitionPage:
		return ec._EventDefinitionPage(ctx, sel, &obj)
	case *EventDefinitionPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._EventDefinitionPage(ctx, sel, obj)
	case FormationAssignmentPage:
		return ec._FormationAssignmentPage(ctx, sel, &obj)
	case *FormationAssignmentPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._FormationAssignmentPage(ctx, sel, obj)
	case FormationPage:
		return ec._FormationPage(ctx, sel, &obj)
	case *FormationPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._FormationPage(ctx, sel, obj)
	case FormationTemplatePage:
		return ec._FormationTemplatePage(ctx, sel, &obj)
	case *FormationTemplatePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._FormationTemplatePage(ctx, sel, obj)
	case HealthCheckPage:
		return ec._HealthCheckPage(ctx, sel, &obj)
	case *HealthCheckPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._HealthCheckPage(ctx, sel, obj)
	case IntegrationDependencyPage:
		return ec._IntegrationDependencyPage(ctx, sel, &obj)
	case *IntegrationDependencyPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._IntegrationDependencyPage(ctx, sel, obj)
	case IntegrationSystemPage:
		return ec._IntegrationSystemPage(ctx, sel, &obj)
	case *IntegrationSystemPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._IntegrationSystemPage(ctx, sel, obj)
	case RuntimeContextPage:
		return ec._RuntimeContextPage(ctx, sel, &obj)
	case *RuntimeContextPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimeContextPage(ctx, sel, obj)
	case RuntimePage:
		return ec._RuntimePage(ctx, sel, &obj)
	case *RuntimePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimePage(ctx, sel, obj)
	case TenantPage:
		return ec._TenantPage(ctx, sel, &obj)
	case *TenantPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._TenantPage(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SystemAuth(ctx context.Context, sel ast.SelectionSet, obj SystemAuth) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case AppSystemAuth:
		return ec._AppSystemAuth(ctx, sel, &obj)
	case *AppSystemAuth:
		if obj == nil {
			return graphql.Null
		}
		return ec._AppSystemAuth(ctx, sel, obj)
	case IntSysSystemAuth:
		return ec._IntSysSystemAuth(ctx, sel, &obj)
	case *IntSysSystemAuth:
		if obj == nil {
			return graphql.Null
		}
		return ec._IntSysSystemAuth(ctx, sel, obj)
	case RuntimeSystemAuth:
		return ec._RuntimeSystemAuth(ctx, sel, &obj)
	case *RuntimeSystemAuth:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimeSystemAuth(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aPIDefinitionImplementors = []string{"APIDefinition"}

func (ec *executionContext) _APIDefinition(ctx context.Context, sel ast.SelectionSet, obj *APIDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPIDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIDefinition")
		case "id":
			out.Values[i] = ec._APIDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._APIDefinition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._APIDefinition_description(ctx, field, obj)
		case "spec":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._APIDefinition_spec(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "targetURL":
			out.Values[i] = ec._APIDefinition_targetURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "group":
			out.Values[i] = ec._APIDefinition_group(ctx, field, obj)
		case "version":
			out.Values[i] = ec._APIDefinition_version(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._APIDefinition_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._APIDefinition_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._APIDefinition_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._APIDefinition_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aPIDefinitionPageImplementors = []string{"APIDefinitionPage", "Pageable"}

func (ec *executionContext) _APIDefinitionPage(ctx context.Context, sel ast.SelectionSet, obj *APIDefinitionPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPIDefinitionPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIDefinitionPage")
		case "data":
			out.Values[i] = ec._APIDefinitionPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._APIDefinitionPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._APIDefinitionPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aPISpecImplementors = []string{"APISpec"}

func (ec *executionContext) _APISpec(ctx context.Context, sel ast.SelectionSet, obj *APISpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPISpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APISpec")
		case "id":
			out.Values[i] = ec._APISpec_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._APISpec_data(ctx, field, obj)
		case "format":
			out.Values[i] = ec._APISpec_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._APISpec_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fetchRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._APISpec_fetchRequest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var appSystemAuthImplementors = []string{"AppSystemAuth", "SystemAuth"}

func (ec *executionContext) _AppSystemAuth(ctx context.Context, sel ast.SelectionSet, obj *AppSystemAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, appSystemAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AppSystemAuth")
		case "id":
			out.Values[i] = ec._AppSystemAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._AppSystemAuth_auth(ctx, field, obj)
		case "type":
			out.Values[i] = ec._AppSystemAuth_type(ctx, field, obj)
		case "tenantId":
			out.Values[i] = ec._AppSystemAuth_tenantId(ctx, field, obj)
		case "referenceObjectId":
			out.Values[i] = ec._AppSystemAuth_referenceObjectId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationImplementors = []string{"Application", "FormationParticipant"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "id":
			out.Values[i] = ec._Application_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Application_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "systemNumber":
			out.Values[i] = ec._Application_systemNumber(ctx, field, obj)
		case "localTenantID":
			out.Values[i] = ec._Application_localTenantID(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._Application_baseUrl(ctx, field, obj)
		case "providerName":
			out.Values[i] = ec._Application_providerName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Application_description(ctx, field, obj)
		case "integrationSystemID":
			out.Values[i] = ec._Application_integrationSystemID(ctx, field, obj)
		case "applicationTemplateID":
			out.Values[i] = ec._Application_applicationTemplateID(ctx, field, obj)
		case "applicationTemplate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_applicationTemplate(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Application_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "healthCheckURL":
			out.Values[i] = ec._Application_healthCheckURL(ctx, field, obj)
		case "bundles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_bundles(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bundle":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_bundle(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "apiDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_apiDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_eventDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "integrationDependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_integrationDependencies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "auths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_auths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventingConfiguration":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_eventingConfiguration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applicationNamespace":
			out.Values[i] = ec._Application_applicationNamespace(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Application_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Application_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Application_deletedAt(ctx, field, obj)
		case "systemStatus":
			out.Values[i] = ec._Application_systemStatus(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Application_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationEventingConfigurationImplementors = []string{"ApplicationEventingConfiguration"}

func (ec *executionContext) _ApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, obj *ApplicationEventingConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationEventingConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEventingConfiguration")
		case "defaultURL":
			out.Values[i] = ec._ApplicationEventingConfiguration_defaultURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationPageImplementors = []string{"ApplicationPage", "Pageable"}

func (ec *executionContext) _ApplicationPage(ctx context.Context, sel ast.SelectionSet, obj *ApplicationPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationPage")
		case "data":
			out.Values[i] = ec._ApplicationPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ApplicationPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ApplicationPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationStatusImplementors = []string{"ApplicationStatus"}

func (ec *executionContext) _ApplicationStatus(ctx context.Context, sel ast.SelectionSet, obj *ApplicationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationStatus")
		case "condition":
			out.Values[i] = ec._ApplicationStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ApplicationStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationTemplateImplementors = []string{"ApplicationTemplate"}

func (ec *executionContext) _ApplicationTemplate(ctx context.Context, sel ast.SelectionSet, obj *ApplicationTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationTemplate")
		case "id":
			out.Values[i] = ec._ApplicationTemplate_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ApplicationTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._ApplicationTemplate_description(ctx, field, obj)
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationTemplate_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applicationInput":
			out.Values[i] = ec._ApplicationTemplate_applicationInput(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "placeholders":
			out.Values[i] = ec._ApplicationTemplate_placeholders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationTemplate_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accessLevel":
			out.Values[i] = ec._ApplicationTemplate_accessLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "applicationNamespace":
			out.Values[i] = ec._ApplicationTemplate_applicationNamespace(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ApplicationTemplate_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._ApplicationTemplate_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationTemplatePageImplementors = []string{"ApplicationTemplatePage", "Pageable"}

func (ec *executionContext) _ApplicationTemplatePage(ctx context.Context, sel ast.SelectionSet, obj *ApplicationTemplatePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationTemplatePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationTemplatePage")
		case "data":
			out.Values[i] = ec._ApplicationTemplatePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ApplicationTemplatePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ApplicationTemplatePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectImplementors = []string{"Aspect"}

func (ec *executionContext) _Aspect(ctx context.Context, sel ast.SelectionSet, obj *Aspect) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Aspect")
		case "id":
			out.Values[i] = ec._Aspect_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Aspect_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Aspect_description(ctx, field, obj)
		case "mandatory":
			out.Values[i] = ec._Aspect_mandatory(ctx, field, obj)
		case "apiResources":
			out.Values[i] = ec._Aspect_apiResources(ctx, field, obj)
		case "eventResources":
			out.Values[i] = ec._Aspect_eventResources(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._Aspect_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._Aspect_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._Aspect_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Aspect_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectAPIDefinitionImplementors = []string{"AspectAPIDefinition"}

func (ec *executionContext) _AspectAPIDefinition(ctx context.Context, sel ast.SelectionSet, obj *AspectAPIDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectAPIDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AspectAPIDefinition")
		case "ordID":
			out.Values[i] = ec._AspectAPIDefinition_ordID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectEventDefinitionImplementors = []string{"AspectEventDefinition"}

func (ec *executionContext) _AspectEventDefinition(ctx context.Context, sel ast.SelectionSet, obj *AspectEventDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectEventDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AspectEventDefinition")
		case "ordID":
			out.Values[i] = ec._AspectEventDefinition_ordID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subset":
			out.Values[i] = ec._AspectEventDefinition_subset(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._AspectEventDefinition_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._AspectEventDefinition_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._AspectEventDefinition_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._AspectEventDefinition_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectEventDefinitionSubsetImplementors = []string{"AspectEventDefinitionSubset"}

func (ec *executionContext) _AspectEventDefinitionSubset(ctx context.Context, sel ast.SelectionSet, obj *AspectEventDefinitionSubset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectEventDefinitionSubsetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AspectEventDefinitionSubset")
		case "eventType":
			out.Values[i] = ec._AspectEventDefinitionSubset_eventType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authImplementors = []string{"Auth"}

func (ec *executionContext) _Auth(ctx context.Context, sel ast.SelectionSet, obj *Auth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Auth")
		case "credential":
			out.Values[i] = ec._Auth_credential(ctx, field, obj)
		case "accessStrategy":
			out.Values[i] = ec._Auth_accessStrategy(ctx, field, obj)
		case "additionalHeaders":
			out.Values[i] = ec._Auth_additionalHeaders(ctx, field, obj)
		case "additionalHeadersSerialized":
			out.Values[i] = ec._Auth_additionalHeadersSerialized(ctx, field, obj)
		case "additionalQueryParams":
			out.Values[i] = ec._Auth_additionalQueryParams(ctx, field, obj)
		case "additionalQueryParamsSerialized":
			out.Values[i] = ec._Auth_additionalQueryParamsSerialized(ctx, field, obj)
		case "requestAuth":
			out.Values[i] = ec._Auth_requestAuth(ctx, field, obj)
		case "oneTimeToken":
			out.Values[i] = ec._Auth_oneTimeToken(ctx, field, obj)
		case "certCommonName":
			out.Values[i] = ec._Auth_certCommonName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var automaticScenarioAssignmentImplementors = []string{"AutomaticScenarioAssignment"}

func (ec *executionContext) _AutomaticScenarioAssignment(ctx context.Context, sel ast.SelectionSet, obj *AutomaticScenarioAssignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, automaticScenarioAssignmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AutomaticScenarioAssignment")
		case "scenarioName":
			out.Values[i] = ec._AutomaticScenarioAssignment_scenarioName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selector":
			out.Values[i] = ec._AutomaticScenarioAssignment_selector(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var automaticScenarioAssignmentPageImplementors = []string{"AutomaticScenarioAssignmentPage", "Pageable"}

func (ec *executionContext) _AutomaticScenarioAssignmentPage(ctx context.Context, sel ast.SelectionSet, obj *AutomaticScenarioAssignmentPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, automaticScenarioAssignmentPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AutomaticScenarioAssignmentPage")
		case "data":
			out.Values[i] = ec._AutomaticScenarioAssignmentPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._AutomaticScenarioAssignmentPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._AutomaticScenarioAssignmentPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var basicCredentialDataImplementors = []string{"BasicCredentialData", "CredentialData"}

func (ec *executionContext) _BasicCredentialData(ctx context.Context, sel ast.SelectionSet, obj *BasicCredentialData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, basicCredentialDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BasicCredentialData")
		case "username":
			out.Values[i] = ec._BasicCredentialData_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "password":
			out.Values[i] = ec._BasicCredentialData_password(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundleImplementors = []string{"Bundle"}

func (ec *executionContext) _Bundle(ctx context.Context, sel ast.SelectionSet, obj *Bundle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bundle")
		case "id":
			out.Values[i] = ec._Bundle_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Bundle_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Bundle_description(ctx, field, obj)
		case "instanceAuthRequestInputSchema":
			out.Values[i] = ec._Bundle_instanceAuthRequestInputSchema(ctx, field, obj)
		case "instanceAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_instanceAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "instanceAuths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_instanceAuths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "defaultInstanceAuth":
			out.Values[i] = ec._Bundle_defaultInstanceAuth(ctx, field, obj)
		case "apiDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_apiDefinitions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_eventDefinitions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "documents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_documents(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "apiDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_apiDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_eventDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "correlationIDs":
			out.Values[i] = ec._Bundle_correlationIDs(ctx, field, obj)
		case "document":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_document(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Bundle_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Bundle_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Bundle_deletedAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Bundle_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundleInstanceAuthImplementors = []string{"BundleInstanceAuth"}

func (ec *executionContext) _BundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, obj *BundleInstanceAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundleInstanceAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BundleInstanceAuth")
		case "id":
			out.Values[i] = ec._BundleInstanceAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "context":
			out.Values[i] = ec._BundleInstanceAuth_context(ctx, field, obj)
		case "inputParams":
			out.Values[i] = ec._BundleInstanceAuth_inputParams(ctx, field, obj)
		case "auth":
			out.Values[i] = ec._BundleInstanceAuth_auth(ctx, field, obj)
		case "status":
			out.Values[i] = ec._BundleInstanceAuth_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runtimeID":
			out.Values[i] = ec._BundleInstanceAuth_runtimeID(ctx, field, obj)
		case "runtimeContextID":
			out.Values[i] = ec._BundleInstanceAuth_runtimeContextID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundleInstanceAuthStatusImplementors = []string{"BundleInstanceAuthStatus"}

func (ec *executionContext) _BundleInstanceAuthStatus(ctx context.Context, sel ast.SelectionSet, obj *BundleInstanceAuthStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundleInstanceAuthStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BundleInstanceAuthStatus")
		case "condition":
			out.Values[i] = ec._BundleInstanceAuthStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._BundleInstanceAuthStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._BundleInstanceAuthStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._BundleInstanceAuthStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundlePageImplementors = []string{"BundlePage", "Pageable"}

func (ec *executionContext) _BundlePage(ctx context.Context, sel ast.SelectionSet, obj *BundlePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundlePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BundlePage")
		case "data":
			out.Values[i] = ec._BundlePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._BundlePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._BundlePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cSRFTokenCredentialRequestAuthImplementors = []string{"CSRFTokenCredentialRequestAuth"}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, obj *CSRFTokenCredentialRequestAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cSRFTokenCredentialRequestAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CSRFTokenCredentialRequestAuth")
		case "tokenEndpointURL":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "credential":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_credential(ctx, field, obj)
		case "additionalHeaders":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalHeaders(ctx, field, obj)
		case "additionalHeadersSerialized":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx, field, obj)
		case "additionalQueryParams":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx, field, obj)
		case "additionalQueryParamsSerialized":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var certificateOAuthCredentialDataImplementors = []string{"CertificateOAuthCredentialData", "CredentialData"}

func (ec *executionContext) _CertificateOAuthCredentialData(ctx context.Context, sel ast.SelectionSet, obj *CertificateOAuthCredentialData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, certificateOAuthCredentialDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CertificateOAuthCredentialData")
		case "clientId":
			out.Values[i] = ec._CertificateOAuthCredentialData_clientId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "certificate":
			out.Values[i] = ec._CertificateOAuthCredentialData_certificate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._CertificateOAuthCredentialData_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var certificateSubjectMappingImplementors = []string{"CertificateSubjectMapping"}

func (ec *executionContext) _CertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, obj *CertificateSubjectMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, certificateSubjectMappingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CertificateSubjectMapping")
		case "id":
			out.Values[i] = ec._CertificateSubjectMapping_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subject":
			out.Values[i] = ec._CertificateSubjectMapping_subject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consumerType":
			out.Values[i] = ec._CertificateSubjectMapping_consumerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "internalConsumerID":
			out.Values[i] = ec._CertificateSubjectMapping_internalConsumerID(ctx, field, obj)
		case "tenantAccessLevels":
			out.Values[i] = ec._CertificateSubjectMapping_tenantAccessLevels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var certificateSubjectMappingPageImplementors = []string{"CertificateSubjectMappingPage", "Pageable"}

func (ec *executionContext) _CertificateSubjectMappingPage(ctx context.Context, sel ast.SelectionSet, obj *CertificateSubjectMappingPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, certificateSubjectMappingPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CertificateSubjectMappingPage")
		case "data":
			out.Values[i] = ec._CertificateSubjectMappingPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._CertificateSubjectMappingPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._CertificateSubjectMappingPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var constraintReferenceImplementors = []string{"ConstraintReference"}

func (ec *executionContext) _ConstraintReference(ctx context.Context, sel ast.SelectionSet, obj *ConstraintReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, constraintReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConstraintReference")
		case "constraintID":
			out.Values[i] = ec._ConstraintReference_constraintID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "formationTemplateID":
			out.Values[i] = ec._ConstraintReference_formationTemplateID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var credentialRequestAuthImplementors = []string{"CredentialRequestAuth"}

func (ec *executionContext) _CredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, obj *CredentialRequestAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialRequestAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialRequestAuth")
		case "csrf":
			out.Values[i] = ec._CredentialRequestAuth_csrf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var documentImplementors = []string{"Document"}

func (ec *executionContext) _Document(ctx context.Context, sel ast.SelectionSet, obj *Document) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Document")
		case "id":
			out.Values[i] = ec._Document_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Document_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._Document_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Document_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "format":
			out.Values[i] = ec._Document_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._Document_kind(ctx, field, obj)
		case "data":
			out.Values[i] = ec._Document_data(ctx, field, obj)
		case "fetchRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Document_fetchRequest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Document_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Document_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Document_deletedAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Document_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var documentPageImplementors = []string{"DocumentPage", "Pageable"}

func (ec *executionContext) _DocumentPage(ctx context.Context, sel ast.SelectionSet, obj *DocumentPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocumentPage")
		case "data":
			out.Values[i] = ec._DocumentPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._DocumentPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._DocumentPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventDefinitionImplementors = []string{"EventDefinition"}

func (ec *executionContext) _EventDefinition(ctx context.Context, sel ast.SelectionSet, obj *EventDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventDefinition")
		case "id":
			out.Values[i] = ec._EventDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._EventDefinition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._EventDefinition_description(ctx, field, obj)
		case "group":
			out.Values[i] = ec._EventDefinition_group(ctx, field, obj)
		case "spec":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventDefinition_spec(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			out.Values[i] = ec._EventDefinition_version(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._EventDefinition_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._EventDefinition_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._EventDefinition_deletedAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._EventDefinition_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventDefinitionPageImplementors = []string{"EventDefinitionPage", "Pageable"}

func (ec *executionContext) _EventDefinitionPage(ctx context.Context, sel ast.SelectionSet, obj *EventDefinitionPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventDefinitionPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventDefinitionPage")
		case "data":
			out.Values[i] = ec._EventDefinitionPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._EventDefinitionPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._EventDefinitionPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventSpecImplementors = []string{"EventSpec"}

func (ec *executionContext) _EventSpec(ctx context.Context, sel ast.SelectionSet, obj *EventSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventSpec")
		case "id":
			out.Values[i] = ec._EventSpec_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._EventSpec_data(ctx, field, obj)
		case "type":
			out.Values[i] = ec._EventSpec_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "format":
			out.Values[i] = ec._EventSpec_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fetchRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventSpec_fetchRequest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fetchRequestImplementors = []string{"FetchRequest"}

func (ec *executionContext) _FetchRequest(ctx context.Context, sel ast.SelectionSet, obj *FetchRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fetchRequestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FetchRequest")
		case "url":
			out.Values[i] = ec._FetchRequest_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._FetchRequest_auth(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._FetchRequest_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filter":
			out.Values[i] = ec._FetchRequest_filter(ctx, field, obj)
		case "status":
			out.Values[i] = ec._FetchRequest_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fetchRequestStatusImplementors = []string{"FetchRequestStatus"}

func (ec *executionContext) _FetchRequestStatus(ctx context.Context, sel ast.SelectionSet, obj *FetchRequestStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fetchRequestStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FetchRequestStatus")
		case "condition":
			out.Values[i] = ec._FetchRequestStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._FetchRequestStatus_message(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._FetchRequestStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationImplementors = []string{"Formation"}

func (ec *executionContext) _Formation(ctx context.Context, sel ast.SelectionSet, obj *Formation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Formation")
		case "id":
			out.Values[i] = ec._Formation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Formation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "formationTemplateId":
			out.Values[i] = ec._Formation_formationTemplateId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tenantID":
			out.Values[i] = ec._Formation_tenantID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "state":
			out.Values[i] = ec._Formation_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			out.Values[i] = ec._Formation_error(ctx, field, obj)
		case "formationAssignment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Formation_formationAssignment(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "formationAssignments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Formation_formationAssignments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Formation_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastStateChangeTimestamp":
			out.Values[i] = ec._Formation_lastStateChangeTimestamp(ctx, field, obj)
		case "lastNotificationSentTimestamp":
			out.Values[i] = ec._Formation_lastNotificationSentTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationAssignmentImplementors = []string{"FormationAssignment"}

func (ec *executionContext) _FormationAssignment(ctx context.Context, sel ast.SelectionSet, obj *FormationAssignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationAssignmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationAssignment")
		case "id":
			out.Values[i] = ec._FormationAssignment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source":
			out.Values[i] = ec._FormationAssignment_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sourceType":
			out.Values[i] = ec._FormationAssignment_sourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sourceEntity":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationAssignment_sourceEntity(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "target":
			out.Values[i] = ec._FormationAssignment_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetType":
			out.Values[i] = ec._FormationAssignment_targetType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetEntity":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationAssignment_targetEntity(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "state":
			out.Values[i] = ec._FormationAssignment_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "value":
			out.Values[i] = ec._FormationAssignment_value(ctx, field, obj)
		case "configuration":
			out.Values[i] = ec._FormationAssignment_configuration(ctx, field, obj)
		case "error":
			out.Values[i] = ec._FormationAssignment_error(ctx, field, obj)
		case "lastStateChangeTimestamp":
			out.Values[i] = ec._FormationAssignment_lastStateChangeTimestamp(ctx, field, obj)
		case "lastNotificationSentTimestamp":
			out.Values[i] = ec._FormationAssignment_lastNotificationSentTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationAssignmentPageImplementors = []string{"FormationAssignmentPage", "Pageable"}

func (ec *executionContext) _FormationAssignmentPage(ctx context.Context, sel ast.SelectionSet, obj *FormationAssignmentPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationAssignmentPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationAssignmentPage")
		case "data":
			out.Values[i] = ec._FormationAssignmentPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._FormationAssignmentPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._FormationAssignmentPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationConstraintImplementors = []string{"FormationConstraint"}

func (ec *executionContext) _FormationConstraint(ctx context.Context, sel ast.SelectionSet, obj *FormationConstraint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationConstraintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationConstraint")
		case "id":
			out.Values[i] = ec._FormationConstraint_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FormationConstraint_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._FormationConstraint_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "constraintType":
			out.Values[i] = ec._FormationConstraint_constraintType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "targetOperation":
			out.Values[i] = ec._FormationConstraint_targetOperation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operator":
			out.Values[i] = ec._FormationConstraint_operator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._FormationConstraint_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceSubtype":
			out.Values[i] = ec._FormationConstraint_resourceSubtype(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "inputTemplate":
			out.Values[i] = ec._FormationConstraint_inputTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "constraintScope":
			out.Values[i] = ec._FormationConstraint_constraintScope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._FormationConstraint_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._FormationConstraint_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationErrorImplementors = []string{"FormationError"}

func (ec *executionContext) _FormationError(ctx context.Context, sel ast.SelectionSet, obj *FormationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationError")
		case "message":
			out.Values[i] = ec._FormationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCode":
			out.Values[i] = ec._FormationError_errorCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationPageImplementors = []string{"FormationPage", "Pageable"}

func (ec *executionContext) _FormationPage(ctx context.Context, sel ast.SelectionSet, obj *FormationPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationPage")
		case "data":
			out.Values[i] = ec._FormationPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._FormationPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._FormationPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationStatusImplementors = []string{"FormationStatus"}

func (ec *executionContext) _FormationStatus(ctx context.Context, sel ast.SelectionSet, obj *FormationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationStatus")
		case "condition":
			out.Values[i] = ec._FormationStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._FormationStatus_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationStatusErrorImplementors = []string{"FormationStatusError"}

func (ec *executionContext) _FormationStatusError(ctx context.Context, sel ast.SelectionSet, obj *FormationStatusError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationStatusErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationStatusError")
		case "assignmentID":
			out.Values[i] = ec._FormationStatusError_assignmentID(ctx, field, obj)
		case "message":
			out.Values[i] = ec._FormationStatusError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCode":
			out.Values[i] = ec._FormationStatusError_errorCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationTemplateImplementors = []string{"FormationTemplate"}

func (ec *executionContext) _FormationTemplate(ctx context.Context, sel ast.SelectionSet, obj *FormationTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationTemplate")
		case "id":
			out.Values[i] = ec._FormationTemplate_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._FormationTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "applicationTypes":
			out.Values[i] = ec._FormationTemplate_applicationTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "runtimeTypes":
			out.Values[i] = ec._FormationTemplate_runtimeTypes(ctx, field, obj)
		case "runtimeTypeDisplayName":
			out.Values[i] = ec._FormationTemplate_runtimeTypeDisplayName(ctx, field, obj)
		case "runtimeArtifactKind":
			out.Values[i] = ec._FormationTemplate_runtimeArtifactKind(ctx, field, obj)
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationTemplate_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "leadingProductIDs":
			out.Values[i] = ec._FormationTemplate_leadingProductIDs(ctx, field, obj)
		case "formationConstraints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationTemplate_formationConstraints(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "supportsReset":
			out.Values[i] = ec._FormationTemplate_supportsReset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "discoveryConsumers":
			out.Values[i] = ec._FormationTemplate_discoveryConsumers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationTemplatePageImplementors = []string{"FormationTemplatePage", "Pageable"}

func (ec *executionContext) _FormationTemplatePage(ctx context.Context, sel ast.SelectionSet, obj *FormationTemplatePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationTemplatePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationTemplatePage")
		case "data":
			out.Values[i] = ec._FormationTemplatePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._FormationTemplatePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._FormationTemplatePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthCheckImplementors = []string{"HealthCheck"}

func (ec *executionContext) _HealthCheck(ctx context.Context, sel ast.SelectionSet, obj *HealthCheck) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthCheck")
		case "type":
			out.Values[i] = ec._HealthCheck_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "condition":
			out.Values[i] = ec._HealthCheck_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "origin":
			out.Values[i] = ec._HealthCheck_origin(ctx, field, obj)
		case "message":
			out.Values[i] = ec._HealthCheck_message(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._HealthCheck_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthCheckPageImplementors = []string{"HealthCheckPage", "Pageable"}

func (ec *executionContext) _HealthCheckPage(ctx context.Context, sel ast.SelectionSet, obj *HealthCheckPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthCheckPage")
		case "data":
			out.Values[i] = ec._HealthCheckPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._HealthCheckPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._HealthCheckPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var intSysSystemAuthImplementors = []string{"IntSysSystemAuth", "SystemAuth"}

func (ec *executionContext) _IntSysSystemAuth(ctx context.Context, sel ast.SelectionSet, obj *IntSysSystemAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, intSysSystemAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntSysSystemAuth")
		case "id":
			out.Values[i] = ec._IntSysSystemAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._IntSysSystemAuth_auth(ctx, field, obj)
		case "type":
			out.Values[i] = ec._IntSysSystemAuth_type(ctx, field, obj)
		case "tenantId":
			out.Values[i] = ec._IntSysSystemAuth_tenantId(ctx, field, obj)
		case "referenceObjectId":
			out.Values[i] = ec._IntSysSystemAuth_referenceObjectId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationDependencyImplementors = []string{"IntegrationDependency"}

func (ec *executionContext) _IntegrationDependency(ctx context.Context, sel ast.SelectionSet, obj *IntegrationDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationDependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationDependency")
		case "id":
			out.Values[i] = ec._IntegrationDependency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._IntegrationDependency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._IntegrationDependency_description(ctx, field, obj)
		case "ordID":
			out.Values[i] = ec._IntegrationDependency_ordID(ctx, field, obj)
		case "partOfPackage":
			out.Values[i] = ec._IntegrationDependency_partOfPackage(ctx, field, obj)
		case "visibility":
			out.Values[i] = ec._IntegrationDependency_visibility(ctx, field, obj)
		case "releaseStatus":
			out.Values[i] = ec._IntegrationDependency_releaseStatus(ctx, field, obj)
		case "mandatory":
			out.Values[i] = ec._IntegrationDependency_mandatory(ctx, field, obj)
		case "aspects":
			out.Values[i] = ec._IntegrationDependency_aspects(ctx, field, obj)
		case "version":
			out.Values[i] = ec._IntegrationDependency_version(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._IntegrationDependency_labels(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._IntegrationDependency_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._IntegrationDependency_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._IntegrationDependency_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._IntegrationDependency_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationDependencyPageImplementors = []string{"IntegrationDependencyPage", "Pageable"}

func (ec *executionContext) _IntegrationDependencyPage(ctx context.Context, sel ast.SelectionSet, obj *IntegrationDependencyPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationDependencyPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationDependencyPage")
		case "data":
			out.Values[i] = ec._IntegrationDependencyPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._IntegrationDependencyPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._IntegrationDependencyPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationSystemImplementors = []string{"IntegrationSystem"}

func (ec *executionContext) _IntegrationSystem(ctx context.Context, sel ast.SelectionSet, obj *IntegrationSystem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationSystemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationSystem")
		case "id":
			out.Values[i] = ec._IntegrationSystem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._IntegrationSystem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._IntegrationSystem_description(ctx, field, obj)
		case "auths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IntegrationSystem_auths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationSystemPageImplementors = []string{"IntegrationSystemPage", "Pageable"}

func (ec *executionContext) _IntegrationSystemPage(ctx context.Context, sel ast.SelectionSet, obj *IntegrationSystemPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationSystemPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationSystemPage")
		case "data":
			out.Values[i] = ec._IntegrationSystemPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._IntegrationSystemPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._IntegrationSystemPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var labelImplementors = []string{"Label"}

func (ec *executionContext) _Label(ctx context.Context, sel ast.SelectionSet, obj *Label) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Label")
		case "key":
			out.Values[i] = ec._Label_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Label_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var labelDefinitionImplementors = []string{"LabelDefinition"}

func (ec *executionContext) _LabelDefinition(ctx context.Context, sel ast.SelectionSet, obj *LabelDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelDefinition")
		case "key":
			out.Values[i] = ec._LabelDefinition_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schema":
			out.Values[i] = ec._LabelDefinition_schema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "registerApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unpairApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unpairApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createApplicationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createApplicationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerApplicationFromTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerApplicationFromTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateApplicationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateApplicationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteApplicationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApplicationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeApplications":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_mergeApplications(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerRuntimeContext":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerRuntimeContext(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRuntimeContext":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRuntimeContext(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterRuntimeContext":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterRuntimeContext(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addAPIDefinitionToBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAPIDefinitionToBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addAPIDefinitionToApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAPIDefinitionToApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAPIDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAPIDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAPIDefinitionForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAPIDefinitionForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteAPIDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAPIDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refetchAPISpec":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refetchAPISpec(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addIntegrationDependencyToApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addIntegrationDependencyToApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteIntegrationDependency":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteIntegrationDependency(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestOneTimeTokenForRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestOneTimeTokenForRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestOneTimeTokenForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestOneTimeTokenForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestClientCredentialsForRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestClientCredentialsForRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestClientCredentialsForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestClientCredentialsForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestClientCredentialsForIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestClientCredentialsForIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSystemAuthForRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSystemAuthForRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSystemAuthForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSystemAuthForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSystemAuthForIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSystemAuthForIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSystemAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSystemAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invalidateSystemAuthOneTimeToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_invalidateSystemAuthOneTimeToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addEventDefinitionToBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addEventDefinitionToBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addEventDefinitionToApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addEventDefinitionToApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEventDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEventDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEventDefinitionForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEventDefinitionForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEventDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEventDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refetchEventDefinitionSpec":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refetchEventDefinitionSpec(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addDocumentToBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addDocumentToBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDocument":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDocument(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resynchronizeFormationNotifications":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resynchronizeFormationNotifications(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finalizeDraftFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finalizeDraftFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assignFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignFormationGlobal":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignFormationGlobal(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFormationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFormationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFormationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFormationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFormationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFormationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachConstraintToFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachConstraintToFormationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachConstraintFromFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachConstraintFromFormationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createLabelDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLabelDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateLabelDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLabelDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setApplicationLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setApplicationLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTenantLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTenantLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteApplicationLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApplicationLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setRuntimeLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setRuntimeLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteRuntimeLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRuntimeLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setDefaultEventingForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setDefaultEventingForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDefaultEventingForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDefaultEventingForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestBundleInstanceAuthCreation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestBundleInstanceAuthCreation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestBundleInstanceAuthDeletion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestBundleInstanceAuthDeletion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "writeTenants":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_writeTenants(ctx, field)
			})
		case "writeTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_writeTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTenants":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTenants(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subscribeTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_subscribeTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unsubscribeTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unsubscribeTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFormationTemplate(ctx, field)
			})
		case "deleteFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFormationTemplate(ctx, field)
			})
		case "updateFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFormationTemplate(ctx, field)
			})
		case "createCertificateSubjectMapping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCertificateSubjectMapping(ctx, field)
			})
		case "updateCertificateSubjectMapping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCertificateSubjectMapping(ctx, field)
			})
		case "deleteCertificateSubjectMapping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCertificateSubjectMapping(ctx, field)
			})
		case "addTenantAccess":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addTenantAccess(ctx, field)
			})
		case "removeTenantAccess":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeTenantAccess(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuthCredentialDataImplementors = []string{"OAuthCredentialData", "CredentialData"}

func (ec *executionContext) _OAuthCredentialData(ctx context.Context, sel ast.SelectionSet, obj *OAuthCredentialData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuthCredentialDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthCredentialData")
		case "clientId":
			out.Values[i] = ec._OAuthCredentialData_clientId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientSecret":
			out.Values[i] = ec._OAuthCredentialData_clientSecret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._OAuthCredentialData_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oneTimeTokenForApplicationImplementors = []string{"OneTimeTokenForApplication", "OneTimeToken"}

func (ec *executionContext) _OneTimeTokenForApplication(ctx context.Context, sel ast.SelectionSet, obj *OneTimeTokenForApplication) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oneTimeTokenForApplicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OneTimeTokenForApplication")
		case "token":
			out.Values[i] = ec._OneTimeTokenForApplication_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "connectorURL":
			out.Values[i] = ec._OneTimeTokenForApplication_connectorURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "legacyConnectorURL":
			out.Values[i] = ec._OneTimeTokenForApplication_legacyConnectorURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._OneTimeTokenForApplication_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiresAt":
			out.Values[i] = ec._OneTimeTokenForApplication_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._OneTimeTokenForApplication_createdAt(ctx, field, obj)
		case "usedAt":
			out.Values[i] = ec._OneTimeTokenForApplication_usedAt(ctx, field, obj)
		case "raw":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForApplication_raw(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rawEncoded":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForApplication_rawEncoded(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._OneTimeTokenForApplication_type(ctx, field, obj)
		case "scenarioGroups":
			out.Values[i] = ec._OneTimeTokenForApplication_scenarioGroups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oneTimeTokenForRuntimeImplementors = []string{"OneTimeTokenForRuntime", "OneTimeToken"}

func (ec *executionContext) _OneTimeTokenForRuntime(ctx context.Context, sel ast.SelectionSet, obj *OneTimeTokenForRuntime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oneTimeTokenForRuntimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OneTimeTokenForRuntime")
		case "token":
			out.Values[i] = ec._OneTimeTokenForRuntime_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "connectorURL":
			out.Values[i] = ec._OneTimeTokenForRuntime_connectorURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._OneTimeTokenForRuntime_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiresAt":
			out.Values[i] = ec._OneTimeTokenForRuntime_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._OneTimeTokenForRuntime_createdAt(ctx, field, obj)
		case "usedAt":
			out.Values[i] = ec._OneTimeTokenForRuntime_usedAt(ctx, field, obj)
		case "raw":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForRuntime_raw(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rawEncoded":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForRuntime_rawEncoded(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._OneTimeTokenForRuntime_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var placeholderDefinitionImplementors = []string{"PlaceholderDefinition"}

func (ec *executionContext) _PlaceholderDefinition(ctx context.Context, sel ast.SelectionSet, obj *PlaceholderDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, placeholderDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaceholderDefinition")
		case "name":
			out.Values[i] = ec._PlaceholderDefinition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._PlaceholderDefinition_description(ctx, field, obj)
		case "jsonPath":
			out.Values[i] = ec._PlaceholderDefinition_jsonPath(ctx, field, obj)
		case "optional":
			out.Values[i] = ec._PlaceholderDefinition_optional(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "apisForApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_apisForApplication(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "eventsForApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_eventsForApplication(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applications(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_application(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationBySystemNumber":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationBySystemNumber(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationByLocalTenantIDAndAppTemplateID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationByLocalTenantIDAndAppTemplateID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationsForRuntime":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationsForRuntime(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationTemplates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationTemplates(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationTemplate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationTemplate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "runtimes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runtimes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "runtime":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runtime(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "runtimeByTokenIssuer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runtimeByTokenIssuer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "labelDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_labelDefinitions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "labelDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_labelDefinition(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bundleByInstanceAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bundleByInstanceAuth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bundleInstanceAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bundleInstanceAuth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "healthChecks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_healthChecks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "integrationSystems":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_integrationSystems(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "integrationSystem":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_integrationSystem(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "viewer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewer(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenants":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenants(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenantByExternalID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenantByExternalID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenantByInternalID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenantByInternalID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenantByLowestOwnerForResource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenantByLowestOwnerForResource(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "rootTenants":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_rootTenants(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "automaticScenarioAssignmentForScenario":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_automaticScenarioAssignmentForScenario(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "automaticScenarioAssignmentsForSelector":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_automaticScenarioAssignmentsForSelector(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "automaticScenarioAssignments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_automaticScenarioAssignments(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "systemAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_systemAuth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "systemAuthByToken":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_systemAuthByToken(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formation(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationByName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationByName(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationsForObject":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationsForObject(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationConstraints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationConstraints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationConstraint":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationConstraint(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationConstraintsByFormationType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationConstraintsByFormationType(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationTemplate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationTemplate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationTemplates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationTemplates(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationTemplatesByName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationTemplatesByName(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "certificateSubjectMapping":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_certificateSubjectMapping(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "certificateSubjectMappings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_certificateSubjectMappings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeImplementors = []string{"Runtime", "FormationParticipant"}

func (ec *executionContext) _Runtime(ctx context.Context, sel ast.SelectionSet, obj *Runtime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Runtime")
		case "id":
			out.Values[i] = ec._Runtime_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Runtime_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Runtime_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Runtime_description(ctx, field, obj)
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Runtime_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "auths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_auths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventingConfiguration":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_eventingConfiguration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "runtimeContext":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_runtimeContext(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "runtimeContexts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_runtimeContexts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applicationNamespace":
			out.Values[i] = ec._Runtime_applicationNamespace(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeContextImplementors = []string{"RuntimeContext", "FormationParticipant"}

func (ec *executionContext) _RuntimeContext(ctx context.Context, sel ast.SelectionSet, obj *RuntimeContext) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeContextImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeContext")
		case "id":
			out.Values[i] = ec._RuntimeContext_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "key":
			out.Values[i] = ec._RuntimeContext_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "value":
			out.Values[i] = ec._RuntimeContext_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RuntimeContext_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeContextPageImplementors = []string{"RuntimeContextPage", "Pageable"}

func (ec *executionContext) _RuntimeContextPage(ctx context.Context, sel ast.SelectionSet, obj *RuntimeContextPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeContextPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeContextPage")
		case "data":
			out.Values[i] = ec._RuntimeContextPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._RuntimeContextPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._RuntimeContextPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeEventingConfigurationImplementors = []string{"RuntimeEventingConfiguration"}

func (ec *executionContext) _RuntimeEventingConfiguration(ctx context.Context, sel ast.SelectionSet, obj *RuntimeEventingConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeEventingConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeEventingConfiguration")
		case "defaultURL":
			out.Values[i] = ec._RuntimeEventingConfiguration_defaultURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeMetadataImplementors = []string{"RuntimeMetadata"}

func (ec *executionContext) _RuntimeMetadata(ctx context.Context, sel ast.SelectionSet, obj *RuntimeMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeMetadata")
		case "creationTimestamp":
			out.Values[i] = ec._RuntimeMetadata_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimePageImplementors = []string{"RuntimePage", "Pageable"}

func (ec *executionContext) _RuntimePage(ctx context.Context, sel ast.SelectionSet, obj *RuntimePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimePage")
		case "data":
			out.Values[i] = ec._RuntimePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._RuntimePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._RuntimePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeStatusImplementors = []string{"RuntimeStatus"}

func (ec *executionContext) _RuntimeStatus(ctx context.Context, sel ast.SelectionSet, obj *RuntimeStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeStatus")
		case "condition":
			out.Values[i] = ec._RuntimeStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._RuntimeStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeSystemAuthImplementors = []string{"RuntimeSystemAuth", "SystemAuth"}

func (ec *executionContext) _RuntimeSystemAuth(ctx context.Context, sel ast.SelectionSet, obj *RuntimeSystemAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeSystemAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeSystemAuth")
		case "id":
			out.Values[i] = ec._RuntimeSystemAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._RuntimeSystemAuth_auth(ctx, field, obj)
		case "type":
			out.Values[i] = ec._RuntimeSystemAuth_type(ctx, field, obj)
		case "tenantId":
			out.Values[i] = ec._RuntimeSystemAuth_tenantId(ctx, field, obj)
		case "referenceObjectId":
			out.Values[i] = ec._RuntimeSystemAuth_referenceObjectId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tenantImplementors = []string{"Tenant"}

func (ec *executionContext) _Tenant(ctx context.Context, sel ast.SelectionSet, obj *Tenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tenantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tenant")
		case "id":
			out.Values[i] = ec._Tenant_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "internalID":
			out.Values[i] = ec._Tenant_internalID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Tenant_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Tenant_type(ctx, field, obj)
		case "parents":
			out.Values[i] = ec._Tenant_parents(ctx, field, obj)
		case "initialized":
			out.Values[i] = ec._Tenant_initialized(ctx, field, obj)
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tenant_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "provider":
			out.Values[i] = ec._Tenant_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tenantAccessImplementors = []string{"TenantAccess"}

func (ec *executionContext) _TenantAccess(ctx context.Context, sel ast.SelectionSet, obj *TenantAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tenantAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TenantAccess")
		case "tenantID":
			out.Values[i] = ec._TenantAccess_tenantID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TenantAccess_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceID":
			out.Values[i] = ec._TenantAccess_resourceID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "owner":
			out.Values[i] = ec._TenantAccess_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tenantPageImplementors = []string{"TenantPage", "Pageable"}

func (ec *executionContext) _TenantPage(ctx context.Context, sel ast.SelectionSet, obj *TenantPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tenantPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TenantPage")
		case "data":
			out.Values[i] = ec._TenantPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._TenantPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TenantPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "value":
			out.Values[i] = ec._Version_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecated":
			out.Values[i] = ec._Version_deprecated(ctx, field, obj)
		case "deprecatedSince":
			out.Values[i] = ec._Version_deprecatedSince(ctx, field, obj)
		case "forRemoval":
			out.Values[i] = ec._Version_forRemoval(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var viewerImplementors = []string{"Viewer"}

func (ec *executionContext) _Viewer(ctx context.Context, sel ast.SelectionSet, obj *Viewer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Viewer")
		case "id":
			out.Values[i] = ec._Viewer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Viewer_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookImplementors = []string{"Webhook"}

func (ec *executionContext) _Webhook(ctx context.Context, sel ast.SelectionSet, obj *Webhook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Webhook")
		case "id":
			out.Values[i] = ec._Webhook_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applicationID":
			out.Values[i] = ec._Webhook_applicationID(ctx, field, obj)
		case "applicationTemplateID":
			out.Values[i] = ec._Webhook_applicationTemplateID(ctx, field, obj)
		case "runtimeID":
			out.Values[i] = ec._Webhook_runtimeID(ctx, field, obj)
		case "integrationSystemID":
			out.Values[i] = ec._Webhook_integrationSystemID(ctx, field, obj)
		case "formationTemplateID":
			out.Values[i] = ec._Webhook_formationTemplateID(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Webhook_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mode":
			out.Values[i] = ec._Webhook_mode(ctx, field, obj)
		case "correlationIdKey":
			out.Values[i] = ec._Webhook_correlationIdKey(ctx, field, obj)
		case "retryInterval":
			out.Values[i] = ec._Webhook_retryInterval(ctx, field, obj)
		case "timeout":
			out.Values[i] = ec._Webhook_timeout(ctx, field, obj)
		case "url":
			out.Values[i] = ec._Webhook_url(ctx, field, obj)
		case "auth":
			out.Values[i] = ec._Webhook_auth(ctx, field, obj)
		case "urlTemplate":
			out.Values[i] = ec._Webhook_urlTemplate(ctx, field, obj)
		case "inputTemplate":
			out.Values[i] = ec._Webhook_inputTemplate(ctx, field, obj)
		case "headerTemplate":
			out.Values[i] = ec._Webhook_headerTemplate(ctx, field, obj)
		case "outputTemplate":
			out.Values[i] = ec._Webhook_outputTemplate(ctx, field, obj)
		case "statusTemplate":
			out.Values[i] = ec._Webhook_statusTemplate(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Webhook_createdAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAPIDefinition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx context.Context, sel ast.SelectionSet, v APIDefinition) graphql.Marshaler {
	return ec._APIDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNAPIDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*APIDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx context.Context, sel ast.SelectionSet, v *APIDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._APIDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAPIDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInput(ctx context.Context, v interface{}) (APIDefinitionInput, error) {
	res, err := ec.unmarshalInputAPIDefinitionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAPIDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInput(ctx context.Context, v interface{}) (*APIDefinitionInput, error) {
	res, err := ec.unmarshalInputAPIDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAPISpec2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpec(ctx context.Context, sel ast.SelectionSet, v APISpec) graphql.Marshaler {
	return ec._APISpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNAPISpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpec(ctx context.Context, sel ast.SelectionSet, v *APISpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._APISpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAPISpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpecType(ctx context.Context, v interface{}) (APISpecType, error) {
	var res APISpecType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAPISpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpecType(ctx context.Context, sel ast.SelectionSet, v APISpecType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNAppSystemAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAppSystemAuth(ctx context.Context, sel ast.SelectionSet, v *AppSystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AppSystemAuth(ctx, sel, v)
}

func (ec *executionContext) marshalNApplication2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx context.Context, sel ast.SelectionSet, v Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationᚄ(ctx context.Context, sel ast.SelectionSet, v []*Application) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx context.Context, sel ast.SelectionSet, v *Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationEventingConfiguration2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v ApplicationEventingConfiguration) graphql.Marshaler {
	return ec._ApplicationEventingConfiguration(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationEventingConfiguration2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v *ApplicationEventingConfiguration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationEventingConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationFromTemplateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationFromTemplateInput(ctx context.Context, v interface{}) (ApplicationFromTemplateInput, error) {
	res, err := ec.unmarshalInputApplicationFromTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNApplicationJSONInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationJSONInput(ctx context.Context, v interface{}) (*ApplicationJSONInput, error) {
	res, err := ec.unmarshalInputApplicationJSONInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationPage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationPage(ctx context.Context, sel ast.SelectionSet, v ApplicationPage) graphql.Marshaler {
	return ec._ApplicationPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationPage(ctx context.Context, sel ast.SelectionSet, v *ApplicationPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationRegisterInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationRegisterInput(ctx context.Context, v interface{}) (ApplicationRegisterInput, error) {
	res, err := ec.unmarshalInputApplicationRegisterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatus(ctx context.Context, sel ast.SelectionSet, v *ApplicationStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx context.Context, v interface{}) (ApplicationStatusCondition, error) {
	var res ApplicationStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx context.Context, sel ast.SelectionSet, v ApplicationStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplicationTemplate2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx context.Context, sel ast.SelectionSet, v ApplicationTemplate) graphql.Marshaler {
	return ec._ApplicationTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationTemplate2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateᚄ(ctx context.Context, sel ast.SelectionSet, v []*ApplicationTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx context.Context, sel ast.SelectionSet, v *ApplicationTemplate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationTemplateAccessLevel2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateAccessLevel(ctx context.Context, v interface{}) (ApplicationTemplateAccessLevel, error) {
	var res ApplicationTemplateAccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationTemplateAccessLevel2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateAccessLevel(ctx context.Context, sel ast.SelectionSet, v ApplicationTemplateAccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNApplicationTemplateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateInput(ctx context.Context, v interface{}) (ApplicationTemplateInput, error) {
	res, err := ec.unmarshalInputApplicationTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationTemplatePage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplatePage(ctx context.Context, sel ast.SelectionSet, v ApplicationTemplatePage) graphql.Marshaler {
	return ec._ApplicationTemplatePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationTemplatePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplatePage(ctx context.Context, sel ast.SelectionSet, v *ApplicationTemplatePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationTemplatePage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationTemplateUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplateUpdateInput(ctx context.Context, v interface{}) (ApplicationTemplateUpdateInput, error) {
	res, err := ec.unmarshalInputApplicationTemplateUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNApplicationUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationUpdateInput(ctx context.Context, v interface{}) (ApplicationUpdateInput, error) {
	res, err := ec.unmarshalInputApplicationUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAspect2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspect(ctx context.Context, sel ast.SelectionSet, v *Aspect) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Aspect(ctx, sel, v)
}

func (ec *executionContext) marshalNAspectAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinition(ctx context.Context, sel ast.SelectionSet, v *AspectAPIDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AspectAPIDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAspectAPIDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinitionInput(ctx context.Context, v interface{}) (*AspectAPIDefinitionInput, error) {
	res, err := ec.unmarshalInputAspectAPIDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAspectEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinition(ctx context.Context, sel ast.SelectionSet, v *AspectEventDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AspectEventDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAspectEventDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionInput(ctx context.Context, v interface{}) (*AspectEventDefinitionInput, error) {
	res, err := ec.unmarshalInputAspectEventDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAspectEventDefinitionSubset2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubset(ctx context.Context, sel ast.SelectionSet, v *AspectEventDefinitionSubset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AspectEventDefinitionSubset(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAspectInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectInput(ctx context.Context, v interface{}) (*AspectInput, error) {
	res, err := ec.unmarshalInputAspectInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx context.Context, v interface{}) (AuthInput, error) {
	res, err := ec.unmarshalInputAuthInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx context.Context, v interface{}) (*AuthInput, error) {
	res, err := ec.unmarshalInputAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAutomaticScenarioAssignment2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignmentᚄ(ctx context.Context, sel ast.SelectionSet, v []*AutomaticScenarioAssignment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAutomaticScenarioAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAutomaticScenarioAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignment(ctx context.Context, sel ast.SelectionSet, v *AutomaticScenarioAssignment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AutomaticScenarioAssignment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBundle2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx context.Context, sel ast.SelectionSet, v Bundle) graphql.Marshaler {
	return ec._Bundle(ctx, sel, &v)
}

func (ec *executionContext) marshalNBundle2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleᚄ(ctx context.Context, sel ast.SelectionSet, v []*Bundle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx context.Context, sel ast.SelectionSet, v *Bundle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Bundle(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBundleCreateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleCreateInput(ctx context.Context, v interface{}) (BundleCreateInput, error) {
	res, err := ec.unmarshalInputBundleCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleCreateInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleCreateInput(ctx context.Context, v interface{}) (*BundleCreateInput, error) {
	res, err := ec.unmarshalInputBundleCreateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBundleInstanceAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, v BundleInstanceAuth) graphql.Marshaler {
	return ec._BundleInstanceAuth(ctx, sel, &v)
}

func (ec *executionContext) marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, v *BundleInstanceAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BundleInstanceAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthCreateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthCreateInput(ctx context.Context, v interface{}) (BundleInstanceAuthCreateInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthRequestInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthRequestInput(ctx context.Context, v interface{}) (BundleInstanceAuthRequestInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthRequestInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthSetInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthSetInput(ctx context.Context, v interface{}) (BundleInstanceAuthSetInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthSetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthSetStatusConditionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthSetStatusConditionInput(ctx context.Context, v interface{}) (BundleInstanceAuthSetStatusConditionInput, error) {
	var res BundleInstanceAuthSetStatusConditionInput
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBundleInstanceAuthSetStatusConditionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthSetStatusConditionInput(ctx context.Context, sel ast.SelectionSet, v BundleInstanceAuthSetStatusConditionInput) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBundleInstanceAuthStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthStatus(ctx context.Context, sel ast.SelectionSet, v *BundleInstanceAuthStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BundleInstanceAuthStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthStatusCondition(ctx context.Context, v interface{}) (BundleInstanceAuthStatusCondition, error) {
	var res BundleInstanceAuthStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBundleInstanceAuthStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthStatusCondition(ctx context.Context, sel ast.SelectionSet, v BundleInstanceAuthStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBundleInstanceAuthUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthUpdateInput(ctx context.Context, v interface{}) (BundleInstanceAuthUpdateInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleUpdateInput(ctx context.Context, v interface{}) (BundleUpdateInput, error) {
	res, err := ec.unmarshalInputBundleUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBusinessTenantMappingInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBusinessTenantMappingInput(ctx context.Context, v interface{}) (BusinessTenantMappingInput, error) {
	res, err := ec.unmarshalInputBusinessTenantMappingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBusinessTenantMappingInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBusinessTenantMappingInput(ctx context.Context, v interface{}) (*BusinessTenantMappingInput, error) {
	res, err := ec.unmarshalInputBusinessTenantMappingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCertificateSubjectMapping2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, v CertificateSubjectMapping) graphql.Marshaler {
	return ec._CertificateSubjectMapping(ctx, sel, &v)
}

func (ec *executionContext) marshalNCertificateSubjectMapping2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingᚄ(ctx context.Context, sel ast.SelectionSet, v []*CertificateSubjectMapping) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCertificateSubjectMapping2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCertificateSubjectMapping2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, v *CertificateSubjectMapping) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CertificateSubjectMapping(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCertificateSubjectMappingInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingInput(ctx context.Context, v interface{}) (CertificateSubjectMappingInput, error) {
	res, err := ec.unmarshalInputCertificateSubjectMappingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCertificateSubjectMappingPage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingPage(ctx context.Context, sel ast.SelectionSet, v CertificateSubjectMappingPage) graphql.Marshaler {
	return ec._CertificateSubjectMappingPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNCertificateSubjectMappingPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMappingPage(ctx context.Context, sel ast.SelectionSet, v *CertificateSubjectMappingPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CertificateSubjectMappingPage(ctx, sel, v)
}

func (ec *executionContext) marshalNConstraintReference2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintReference(ctx context.Context, sel ast.SelectionSet, v ConstraintReference) graphql.Marshaler {
	return ec._ConstraintReference(ctx, sel, &v)
}

func (ec *executionContext) marshalNConstraintReference2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintReference(ctx context.Context, sel ast.SelectionSet, v *ConstraintReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConstraintReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConstraintScope2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintScope(ctx context.Context, v interface{}) (ConstraintScope, error) {
	var res ConstraintScope
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConstraintScope2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintScope(ctx context.Context, sel ast.SelectionSet, v ConstraintScope) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNConstraintType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintType(ctx context.Context, v interface{}) (ConstraintType, error) {
	var res ConstraintType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConstraintType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐConstraintType(ctx context.Context, sel ast.SelectionSet, v ConstraintType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDocument2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocument(ctx context.Context, sel ast.SelectionSet, v Document) graphql.Marshaler {
	return ec._Document(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocument2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentᚄ(ctx context.Context, sel ast.SelectionSet, v []*Document) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDocument2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocument(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDocument2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocument(ctx context.Context, sel ast.SelectionSet, v *Document) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Document(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDocumentFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentFormat(ctx context.Context, v interface{}) (DocumentFormat, error) {
	var res DocumentFormat
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDocumentFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentFormat(ctx context.Context, sel ast.SelectionSet, v DocumentFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDocumentInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentInput(ctx context.Context, v interface{}) (DocumentInput, error) {
	res, err := ec.unmarshalInputDocumentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDocumentInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentInput(ctx context.Context, v interface{}) (*DocumentInput, error) {
	res, err := ec.unmarshalInputDocumentInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventDefinition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx context.Context, sel ast.SelectionSet, v EventDefinition) graphql.Marshaler {
	return ec._EventDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*EventDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx context.Context, sel ast.SelectionSet, v *EventDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInput(ctx context.Context, v interface{}) (EventDefinitionInput, error) {
	res, err := ec.unmarshalInputEventDefinitionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEventDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInput(ctx context.Context, v interface{}) (*EventDefinitionInput, error) {
	res, err := ec.unmarshalInputEventDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventSpec2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpec(ctx context.Context, sel ast.SelectionSet, v EventSpec) graphql.Marshaler {
	return ec._EventSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventSpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpec(ctx context.Context, sel ast.SelectionSet, v *EventSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventSpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpecType(ctx context.Context, v interface{}) (EventSpecType, error) {
	var res EventSpecType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventSpecType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpecType(ctx context.Context, sel ast.SelectionSet, v EventSpecType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventType(ctx context.Context, v interface{}) (EventType, error) {
	var res EventType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventType(ctx context.Context, sel ast.SelectionSet, v EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFetchMode2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchMode(ctx context.Context, v interface{}) (FetchMode, error) {
	var res FetchMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFetchMode2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchMode(ctx context.Context, sel ast.SelectionSet, v FetchMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFetchRequestStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestStatus(ctx context.Context, sel ast.SelectionSet, v *FetchRequestStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FetchRequestStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFetchRequestStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestStatusCondition(ctx context.Context, v interface{}) (FetchRequestStatusCondition, error) {
	var res FetchRequestStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFetchRequestStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestStatusCondition(ctx context.Context, sel ast.SelectionSet, v FetchRequestStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormation2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx context.Context, sel ast.SelectionSet, v Formation) graphql.Marshaler {
	return ec._Formation(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormation2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationᚄ(ctx context.Context, sel ast.SelectionSet, v []*Formation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx context.Context, sel ast.SelectionSet, v *Formation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Formation(ctx, sel, v)
}

func (ec *executionContext) marshalNFormationAssignment2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentᚄ(ctx context.Context, sel ast.SelectionSet, v []*FormationAssignment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormationAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignment(ctx context.Context, sel ast.SelectionSet, v *FormationAssignment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationAssignment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationAssignmentType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentType(ctx context.Context, v interface{}) (FormationAssignmentType, error) {
	var res FormationAssignmentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationAssignmentType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentType(ctx context.Context, sel ast.SelectionSet, v FormationAssignmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormationConstraint2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx context.Context, sel ast.SelectionSet, v FormationConstraint) graphql.Marshaler {
	return ec._FormationConstraint(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationConstraint2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintᚄ(ctx context.Context, sel ast.SelectionSet, v []*FormationConstraint) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationConstraint2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormationConstraint2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx context.Context, sel ast.SelectionSet, v *FormationConstraint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationConstraint(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationConstraintInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintInput(ctx context.Context, v interface{}) (FormationConstraintInput, error) {
	res, err := ec.unmarshalInputFormationConstraintInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFormationConstraintUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintUpdateInput(ctx context.Context, v interface{}) (FormationConstraintUpdateInput, error) {
	res, err := ec.unmarshalInputFormationConstraintUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFormationInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationInput(ctx context.Context, v interface{}) (FormationInput, error) {
	res, err := ec.unmarshalInputFormationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFormationObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationObjectType(ctx context.Context, v interface{}) (FormationObjectType, error) {
	var res FormationObjectType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationObjectType(ctx context.Context, sel ast.SelectionSet, v FormationObjectType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormationPage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationPage(ctx context.Context, sel ast.SelectionSet, v FormationPage) graphql.Marshaler {
	return ec._FormationPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationPage(ctx context.Context, sel ast.SelectionSet, v *FormationPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationPage(ctx, sel, v)
}

func (ec *executionContext) marshalNFormationStatus2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatus(ctx context.Context, sel ast.SelectionSet, v FormationStatus) graphql.Marshaler {
	return ec._FormationStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatus(ctx context.Context, sel ast.SelectionSet, v *FormationStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatusCondition(ctx context.Context, v interface{}) (FormationStatusCondition, error) {
	var res FormationStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatusCondition(ctx context.Context, sel ast.SelectionSet, v FormationStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormationStatusError2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatusError(ctx context.Context, sel ast.SelectionSet, v *FormationStatusError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationStatusError(ctx, sel, v)
}

func (ec *executionContext) marshalNFormationTemplate2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplateᚄ(ctx context.Context, sel ast.SelectionSet, v []*FormationTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplate(ctx context.Context, sel ast.SelectionSet, v *FormationTemplate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationTemplateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplateInput(ctx context.Context, v interface{}) (FormationTemplateInput, error) {
	res, err := ec.unmarshalInputFormationTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationTemplatePage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplatePage(ctx context.Context, sel ast.SelectionSet, v FormationTemplatePage) graphql.Marshaler {
	return ec._FormationTemplatePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationTemplatePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplatePage(ctx context.Context, sel ast.SelectionSet, v *FormationTemplatePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationTemplatePage(ctx, sel, v)
}

func (ec *executionContext) marshalNHealthCheck2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckᚄ(ctx context.Context, sel ast.SelectionSet, v []*HealthCheck) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHealthCheck2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheck(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHealthCheck2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheck(ctx context.Context, sel ast.SelectionSet, v *HealthCheck) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthCheck(ctx, sel, v)
}

func (ec *executionContext) marshalNHealthCheckPage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckPage(ctx context.Context, sel ast.SelectionSet, v HealthCheckPage) graphql.Marshaler {
	return ec._HealthCheckPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNHealthCheckPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckPage(ctx context.Context, sel ast.SelectionSet, v *HealthCheckPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthCheckPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHealthCheckStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckStatusCondition(ctx context.Context, v interface{}) (HealthCheckStatusCondition, error) {
	var res HealthCheckStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHealthCheckStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckStatusCondition(ctx context.Context, sel ast.SelectionSet, v HealthCheckStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHealthCheckType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckType(ctx context.Context, v interface{}) (HealthCheckType, error) {
	var res HealthCheckType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHealthCheckType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckType(ctx context.Context, sel ast.SelectionSet, v HealthCheckType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIntSysSystemAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntSysSystemAuth(ctx context.Context, sel ast.SelectionSet, v *IntSysSystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntSysSystemAuth(ctx, sel, v)
}

func (ec *executionContext) marshalNIntegrationDependency2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependency(ctx context.Context, sel ast.SelectionSet, v IntegrationDependency) graphql.Marshaler {
	return ec._IntegrationDependency(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationDependency2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependencyᚄ(ctx context.Context, sel ast.SelectionSet, v []*IntegrationDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntegrationDependency2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIntegrationDependency2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependency(ctx context.Context, sel ast.SelectionSet, v *IntegrationDependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationDependency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIntegrationDependencyInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependencyInput(ctx context.Context, v interface{}) (IntegrationDependencyInput, error) {
	res, err := ec.unmarshalInputIntegrationDependencyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIntegrationSystem2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx context.Context, sel ast.SelectionSet, v IntegrationSystem) graphql.Marshaler {
	return ec._IntegrationSystem(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationSystem2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemᚄ(ctx context.Context, sel ast.SelectionSet, v []*IntegrationSystem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntegrationSystem2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIntegrationSystem2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx context.Context, sel ast.SelectionSet, v *IntegrationSystem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationSystem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIntegrationSystemInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemInput(ctx context.Context, v interface{}) (IntegrationSystemInput, error) {
	res, err := ec.unmarshalInputIntegrationSystemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIntegrationSystemPage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemPage(ctx context.Context, sel ast.SelectionSet, v IntegrationSystemPage) graphql.Marshaler {
	return ec._IntegrationSystemPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationSystemPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystemPage(ctx context.Context, sel ast.SelectionSet, v *IntegrationSystemPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationSystemPage(ctx, sel, v)
}

func (ec *executionContext) marshalNLabel2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx context.Context, sel ast.SelectionSet, v Label) graphql.Marshaler {
	return ec._Label(ctx, sel, &v)
}

func (ec *executionContext) marshalNLabel2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabel(ctx context.Context, sel ast.SelectionSet, v *Label) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Label(ctx, sel, v)
}

func (ec *executionContext) marshalNLabelDefinition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinition(ctx context.Context, sel ast.SelectionSet, v LabelDefinition) graphql.Marshaler {
	return ec._LabelDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNLabelDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*LabelDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLabelDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLabelDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinition(ctx context.Context, sel ast.SelectionSet, v *LabelDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LabelDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLabelDefinitionInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinitionInput(ctx context.Context, v interface{}) (LabelDefinitionInput, error) {
	res, err := ec.unmarshalInputLabelDefinitionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLabelFilter2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelFilter(ctx context.Context, v interface{}) (*LabelFilter, error) {
	res, err := ec.unmarshalInputLabelFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLabelSelectorInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelSelectorInput(ctx context.Context, v interface{}) (LabelSelectorInput, error) {
	res, err := ec.unmarshalInputLabelSelectorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOneTimeTokenForApplication2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenForApplication(ctx context.Context, sel ast.SelectionSet, v OneTimeTokenForApplication) graphql.Marshaler {
	return ec._OneTimeTokenForApplication(ctx, sel, &v)
}

func (ec *executionContext) marshalNOneTimeTokenForApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenForApplication(ctx context.Context, sel ast.SelectionSet, v *OneTimeTokenForApplication) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OneTimeTokenForApplication(ctx, sel, v)
}

func (ec *executionContext) marshalNOneTimeTokenForRuntime2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenForRuntime(ctx context.Context, sel ast.SelectionSet, v OneTimeTokenForRuntime) graphql.Marshaler {
	return ec._OneTimeTokenForRuntime(ctx, sel, &v)
}

func (ec *executionContext) marshalNOneTimeTokenForRuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenForRuntime(ctx context.Context, sel ast.SelectionSet, v *OneTimeTokenForRuntime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OneTimeTokenForRuntime(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOperationType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationType(ctx context.Context, v interface{}) (OperationType, error) {
	var res OperationType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOperationType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationType(ctx context.Context, sel ast.SelectionSet, v OperationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPageCursor2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx context.Context, v interface{}) (PageCursor, error) {
	var res PageCursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageCursor2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx context.Context, sel ast.SelectionSet, v PageCursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v *PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNPlaceholderDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*PlaceholderDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlaceholderDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPlaceholderDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinition(ctx context.Context, sel ast.SelectionSet, v *PlaceholderDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlaceholderDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPlaceholderDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinitionInput(ctx context.Context, v interface{}) (*PlaceholderDefinitionInput, error) {
	res, err := ec.unmarshalInputPlaceholderDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNResourceType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐResourceType(ctx context.Context, v interface{}) (ResourceType, error) {
	var res ResourceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐResourceType(ctx context.Context, sel ast.SelectionSet, v ResourceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRuntime2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx context.Context, sel ast.SelectionSet, v Runtime) graphql.Marshaler {
	return ec._Runtime(ctx, sel, &v)
}

func (ec *executionContext) marshalNRuntime2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeᚄ(ctx context.Context, sel ast.SelectionSet, v []*Runtime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx context.Context, sel ast.SelectionSet, v *Runtime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Runtime(ctx, sel, v)
}

func (ec *executionContext) marshalNRuntimeContext2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx context.Context, sel ast.SelectionSet, v RuntimeContext) graphql.Marshaler {
	return ec._RuntimeContext(ctx, sel, &v)
}

func (ec *executionContext) marshalNRuntimeContext2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContextᚄ(ctx context.Context, sel ast.SelectionSet, v []*RuntimeContext) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuntimeContext2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRuntimeContext2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx context.Context, sel ast.SelectionSet, v *RuntimeContext) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeContext(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeContextInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContextInput(ctx context.Context, v interface{}) (RuntimeContextInput, error) {
	res, err := ec.unmarshalInputRuntimeContextInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntimeMetadata2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeMetadata(ctx context.Context, sel ast.SelectionSet, v *RuntimeMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNRuntimePage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimePage(ctx context.Context, sel ast.SelectionSet, v RuntimePage) graphql.Marshaler {
	return ec._RuntimePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNRuntimePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimePage(ctx context.Context, sel ast.SelectionSet, v *RuntimePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimePage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeRegisterInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeRegisterInput(ctx context.Context, v interface{}) (RuntimeRegisterInput, error) {
	res, err := ec.unmarshalInputRuntimeRegisterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntimeStatus2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatus(ctx context.Context, sel ast.SelectionSet, v *RuntimeStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatusCondition(ctx context.Context, v interface{}) (RuntimeStatusCondition, error) {
	var res RuntimeStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntimeStatusCondition2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatusCondition(ctx context.Context, sel ast.SelectionSet, v RuntimeStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRuntimeSystemAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeSystemAuth(ctx context.Context, sel ast.SelectionSet, v *RuntimeSystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeSystemAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeUpdateInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeUpdateInput(ctx context.Context, v interface{}) (RuntimeUpdateInput, error) {
	res, err := ec.unmarshalInputRuntimeUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSpecFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSpecFormat(ctx context.Context, v interface{}) (SpecFormat, error) {
	var res SpecFormat
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpecFormat2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSpecFormat(ctx context.Context, sel ast.SelectionSet, v SpecFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx context.Context, sel ast.SelectionSet, v SystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SystemAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTargetOperation2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTargetOperation(ctx context.Context, v interface{}) (TargetOperation, error) {
	var res TargetOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTargetOperation2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTargetOperation(ctx context.Context, sel ast.SelectionSet, v TargetOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTenant2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx context.Context, sel ast.SelectionSet, v Tenant) graphql.Marshaler {
	return ec._Tenant(ctx, sel, &v)
}

func (ec *executionContext) marshalNTenant2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantᚄ(ctx context.Context, sel ast.SelectionSet, v []*Tenant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTenant2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTenant2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx context.Context, sel ast.SelectionSet, v *Tenant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tenant(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTenantAccessInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccessInput(ctx context.Context, v interface{}) (TenantAccessInput, error) {
	res, err := ec.unmarshalInputTenantAccessInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTenantAccessObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccessObjectType(ctx context.Context, v interface{}) (TenantAccessObjectType, error) {
	var res TenantAccessObjectType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTenantAccessObjectType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccessObjectType(ctx context.Context, sel ast.SelectionSet, v TenantAccessObjectType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTenantPage2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantPage(ctx context.Context, sel ast.SelectionSet, v TenantPage) graphql.Marshaler {
	return ec._TenantPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNTenantPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantPage(ctx context.Context, sel ast.SelectionSet, v *TenantPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TenantPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx context.Context, v interface{}) (Timestamp, error) {
	var res Timestamp
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimestamp2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx context.Context, sel ast.SelectionSet, v Timestamp) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx context.Context, v interface{}) (*Timestamp, error) {
	var res = new(Timestamp)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx context.Context, sel ast.SelectionSet, v *Timestamp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNViewer2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐViewer(ctx context.Context, sel ast.SelectionSet, v Viewer) graphql.Marshaler {
	return ec._Viewer(ctx, sel, &v)
}

func (ec *executionContext) marshalNViewer2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐViewer(ctx context.Context, sel ast.SelectionSet, v *Viewer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Viewer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNViewerType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐViewerType(ctx context.Context, v interface{}) (ViewerType, error) {
	var res ViewerType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNViewerType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐViewerType(ctx context.Context, sel ast.SelectionSet, v ViewerType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWebhook2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhook(ctx context.Context, sel ast.SelectionSet, v Webhook) graphql.Marshaler {
	return ec._Webhook(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhook2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhook(ctx context.Context, sel ast.SelectionSet, v *Webhook) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Webhook(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWebhookInput2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInput(ctx context.Context, v interface{}) (WebhookInput, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWebhookInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInput(ctx context.Context, v interface{}) (*WebhookInput, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWebhookType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx context.Context, v interface{}) (WebhookType, error) {
	var res WebhookType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWebhookType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx context.Context, sel ast.SelectionSet, v WebhookType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinition(ctx context.Context, sel ast.SelectionSet, v *APIDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APIDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAPIDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInputᚄ(ctx context.Context, v interface{}) ([]*APIDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*APIDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAPIDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAPIDefinitionPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPIDefinitionPage(ctx context.Context, sel ast.SelectionSet, v *APIDefinitionPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APIDefinitionPage(ctx, sel, v)
}

func (ec *executionContext) marshalOAPISpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpec(ctx context.Context, sel ast.SelectionSet, v *APISpec) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APISpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAPISpecInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAPISpecInput(ctx context.Context, v interface{}) (*APISpecInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAPISpecInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAppSystemAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAppSystemAuthᚄ(ctx context.Context, sel ast.SelectionSet, v []*AppSystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAppSystemAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAppSystemAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOApplication2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplication(ctx context.Context, sel ast.SelectionSet, v *Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationEventingConfiguration2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v *ApplicationEventingConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationEventingConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalOApplicationStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx context.Context, v interface{}) (*ApplicationStatusCondition, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ApplicationStatusCondition)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOApplicationStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationStatusCondition(ctx context.Context, sel ast.SelectionSet, v *ApplicationStatusCondition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOApplicationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐApplicationTemplate(ctx context.Context, sel ast.SelectionSet, v *ApplicationTemplate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalOArtifactType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐArtifactType(ctx context.Context, v interface{}) (*ArtifactType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ArtifactType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOArtifactType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐArtifactType(ctx context.Context, sel ast.SelectionSet, v *ArtifactType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAspect2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectᚄ(ctx context.Context, sel ast.SelectionSet, v []*Aspect) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspect2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspect(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAspectAPIDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*AspectAPIDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspectAPIDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAspectAPIDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinitionInputᚄ(ctx context.Context, v interface{}) ([]*AspectAPIDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectAPIDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAspectAPIDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectAPIDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAspectEventDefinition2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*AspectEventDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspectEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAspectEventDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionInputᚄ(ctx context.Context, v interface{}) ([]*AspectEventDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectEventDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAspectEventDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAspectEventDefinitionSubset2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubsetᚄ(ctx context.Context, sel ast.SelectionSet, v []*AspectEventDefinitionSubset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspectEventDefinitionSubset2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAspectEventDefinitionSubsetInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubsetInput(ctx context.Context, v interface{}) ([]*AspectEventDefinitionSubsetInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectEventDefinitionSubsetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOAspectEventDefinitionSubsetInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubsetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAspectEventDefinitionSubsetInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectEventDefinitionSubsetInput(ctx context.Context, v interface{}) (*AspectEventDefinitionSubsetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAspectEventDefinitionSubsetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAspectInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectInputᚄ(ctx context.Context, v interface{}) ([]*AspectInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAspectInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAspectInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuth(ctx context.Context, sel ast.SelectionSet, v *Auth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Auth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAuthInput(ctx context.Context, v interface{}) (*AuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAutomaticScenarioAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignment(ctx context.Context, sel ast.SelectionSet, v *AutomaticScenarioAssignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AutomaticScenarioAssignment(ctx, sel, v)
}

func (ec *executionContext) marshalOAutomaticScenarioAssignmentPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐAutomaticScenarioAssignmentPage(ctx context.Context, sel ast.SelectionSet, v *AutomaticScenarioAssignmentPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AutomaticScenarioAssignmentPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBasicCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBasicCredentialDataInput(ctx context.Context, v interface{}) (*BasicCredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBasicCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOBundle2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundle(ctx context.Context, sel ast.SelectionSet, v *Bundle) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Bundle(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBundleCreateInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleCreateInputᚄ(ctx context.Context, v interface{}) ([]*BundleCreateInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*BundleCreateInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBundleCreateInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleCreateInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBundleInstanceAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthᚄ(ctx context.Context, sel ast.SelectionSet, v []*BundleInstanceAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOBundleInstanceAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, v *BundleInstanceAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BundleInstanceAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBundleInstanceAuthStatusInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundleInstanceAuthStatusInput(ctx context.Context, v interface{}) (*BundleInstanceAuthStatusInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBundleInstanceAuthStatusInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBundlePage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBundlePage(ctx context.Context, sel ast.SelectionSet, v *BundlePage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BundlePage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBusinessTenantMappingInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBusinessTenantMappingInputᚄ(ctx context.Context, v interface{}) ([]*BusinessTenantMappingInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*BusinessTenantMappingInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBusinessTenantMappingInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐBusinessTenantMappingInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx context.Context, v interface{}) (*CLOB, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(CLOB)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCLOB2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCLOB(ctx context.Context, sel ast.SelectionSet, v *CLOB) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOCSRFTokenCredentialRequestAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCSRFTokenCredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, v *CSRFTokenCredentialRequestAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CSRFTokenCredentialRequestAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCSRFTokenCredentialRequestAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCSRFTokenCredentialRequestAuthInput(ctx context.Context, v interface{}) (*CSRFTokenCredentialRequestAuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCSRFTokenCredentialRequestAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCertificateOAuthCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateOAuthCredentialDataInput(ctx context.Context, v interface{}) (*CertificateOAuthCredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCertificateOAuthCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCertificateSubjectMapping2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, v *CertificateSubjectMapping) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CertificateSubjectMapping(ctx, sel, v)
}

func (ec *executionContext) marshalOCredentialData2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialData(ctx context.Context, sel ast.SelectionSet, v CredentialData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CredentialData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialDataInput(ctx context.Context, v interface{}) (*CredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCredentialRequestAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, v *CredentialRequestAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CredentialRequestAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCredentialRequestAuthInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐCredentialRequestAuthInput(ctx context.Context, v interface{}) (*CredentialRequestAuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCredentialRequestAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODocument2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocument(ctx context.Context, sel ast.SelectionSet, v *Document) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Document(ctx, sel, v)
}

func (ec *executionContext) unmarshalODocumentInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentInputᚄ(ctx context.Context, v interface{}) ([]*DocumentInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*DocumentInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDocumentInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODocumentPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐDocumentPage(ctx context.Context, sel ast.SelectionSet, v *DocumentPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DocumentPage(ctx, sel, v)
}

func (ec *executionContext) marshalOEventDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinition(ctx context.Context, sel ast.SelectionSet, v *EventDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInputᚄ(ctx context.Context, v interface{}) ([]*EventDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*EventDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEventDefinitionPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventDefinitionPage(ctx context.Context, sel ast.SelectionSet, v *EventDefinitionPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventDefinitionPage(ctx, sel, v)
}

func (ec *executionContext) marshalOEventSpec2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpec(ctx context.Context, sel ast.SelectionSet, v *EventSpec) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventSpecInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐEventSpecInput(ctx context.Context, v interface{}) (*EventSpecInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventSpecInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFetchMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchMode(ctx context.Context, v interface{}) (*FetchMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FetchMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFetchMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchMode(ctx context.Context, sel ast.SelectionSet, v *FetchMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFetchRequest2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequest(ctx context.Context, sel ast.SelectionSet, v *FetchRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FetchRequest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFetchRequestInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFetchRequestInput(ctx context.Context, v interface{}) (*FetchRequestInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFetchRequestInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFormation2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormation(ctx context.Context, sel ast.SelectionSet, v *Formation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Formation(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationAssignment2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignment(ctx context.Context, sel ast.SelectionSet, v *FormationAssignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationAssignment(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationAssignmentPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationAssignmentPage(ctx context.Context, sel ast.SelectionSet, v *FormationAssignmentPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationAssignmentPage(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationConstraint2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraintᚄ(ctx context.Context, sel ast.SelectionSet, v []*FormationConstraint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationConstraint2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationConstraint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFormationError2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationError(ctx context.Context, sel ast.SelectionSet, v FormationError) graphql.Marshaler {
	return ec._FormationError(ctx, sel, &v)
}

func (ec *executionContext) marshalOFormationParticipant2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationParticipant(ctx context.Context, sel ast.SelectionSet, v FormationParticipant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationParticipant(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationStatusError2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatusErrorᚄ(ctx context.Context, sel ast.SelectionSet, v []*FormationStatusError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationStatusError2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationStatusError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFormationTemplate2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐFormationTemplate(ctx context.Context, sel ast.SelectionSet, v *FormationTemplate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHealthCheckType2ᚕgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckTypeᚄ(ctx context.Context, v interface{}) ([]HealthCheckType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]HealthCheckType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHealthCheckType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHealthCheckType2ᚕgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []HealthCheckType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHealthCheckType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHealthCheckType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHttpHeaders2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeaders(ctx context.Context, v interface{}) (HTTPHeaders, error) {
	if v == nil {
		return nil, nil
	}
	var res HTTPHeaders
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHttpHeaders2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeaders(ctx context.Context, sel ast.SelectionSet, v HTTPHeaders) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOHttpHeadersSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeadersSerialized(ctx context.Context, v interface{}) (*HTTPHeadersSerialized, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := HTTPHeadersSerialized(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHttpHeadersSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐHTTPHeadersSerialized(ctx context.Context, sel ast.SelectionSet, v *HTTPHeadersSerialized) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	return res
}

func (ec *executionContext) unmarshalOID2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOIntSysSystemAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntSysSystemAuthᚄ(ctx context.Context, sel ast.SelectionSet, v []*IntSysSystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntSysSystemAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntSysSystemAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOIntegrationDependencyPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationDependencyPage(ctx context.Context, sel ast.SelectionSet, v *IntegrationDependencyPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IntegrationDependencyPage(ctx, sel, v)
}

func (ec *executionContext) marshalOIntegrationSystem2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐIntegrationSystem(ctx context.Context, sel ast.SelectionSet, v *IntegrationSystem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IntegrationSystem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx context.Context, v interface{}) (*JSON, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(JSON)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSON(ctx context.Context, sel ast.SelectionSet, v *JSON) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOJSONSchema2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSONSchema(ctx context.Context, v interface{}) (*JSONSchema, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(JSONSchema)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSONSchema2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐJSONSchema(ctx context.Context, sel ast.SelectionSet, v *JSONSchema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOLabelDefinition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelDefinition(ctx context.Context, sel ast.SelectionSet, v *LabelDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LabelDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLabelFilter2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelFilterᚄ(ctx context.Context, v interface{}) ([]*LabelFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*LabelFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLabelFilter2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabelFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx context.Context, v interface{}) (Labels, error) {
	if v == nil {
		return nil, nil
	}
	var res Labels
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLabels2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx context.Context, sel ast.SelectionSet, v Labels) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLabels2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx context.Context, v interface{}) (*Labels, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(Labels)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLabels2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐLabels(ctx context.Context, sel ast.SelectionSet, v *Labels) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOAuthCredentialDataInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOAuthCredentialDataInput(ctx context.Context, v interface{}) (*OAuthCredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOAuthCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOneTimeToken2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeToken(ctx context.Context, sel ast.SelectionSet, v OneTimeToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OneTimeToken(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOneTimeTokenInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenInput(ctx context.Context, v interface{}) (*OneTimeTokenInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOneTimeTokenInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOneTimeTokenType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenType(ctx context.Context, v interface{}) (OneTimeTokenType, error) {
	var res OneTimeTokenType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOneTimeTokenType2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenType(ctx context.Context, sel ast.SelectionSet, v OneTimeTokenType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOOneTimeTokenType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenType(ctx context.Context, v interface{}) (*OneTimeTokenType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(OneTimeTokenType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOneTimeTokenType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOneTimeTokenType(ctx context.Context, sel ast.SelectionSet, v *OneTimeTokenType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOperationMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationMode(ctx context.Context, v interface{}) (*OperationMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(OperationMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOperationMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐOperationMode(ctx context.Context, sel ast.SelectionSet, v *OperationMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx context.Context, v interface{}) (*PageCursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(PageCursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPageCursor2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPageCursor(ctx context.Context, sel ast.SelectionSet, v *PageCursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPlaceholderDefinitionInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinitionInputᚄ(ctx context.Context, v interface{}) ([]*PlaceholderDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*PlaceholderDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPlaceholderDefinitionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐPlaceholderDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOQueryParams2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParams(ctx context.Context, v interface{}) (QueryParams, error) {
	if v == nil {
		return nil, nil
	}
	var res QueryParams
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOQueryParams2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParams(ctx context.Context, sel ast.SelectionSet, v QueryParams) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOQueryParamsSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParamsSerialized(ctx context.Context, v interface{}) (*QueryParamsSerialized, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := QueryParamsSerialized(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOQueryParamsSerialized2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐQueryParamsSerialized(ctx context.Context, sel ast.SelectionSet, v *QueryParamsSerialized) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalORuntime2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntime(ctx context.Context, sel ast.SelectionSet, v *Runtime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Runtime(ctx, sel, v)
}

func (ec *executionContext) marshalORuntimeContext2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContext(ctx context.Context, sel ast.SelectionSet, v *RuntimeContext) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeContext(ctx, sel, v)
}

func (ec *executionContext) marshalORuntimeContextPage2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeContextPage(ctx context.Context, sel ast.SelectionSet, v *RuntimeContextPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeContextPage(ctx, sel, v)
}

func (ec *executionContext) marshalORuntimeEventingConfiguration2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v *RuntimeEventingConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeEventingConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalORuntimeStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatusCondition(ctx context.Context, v interface{}) (*RuntimeStatusCondition, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(RuntimeStatusCondition)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORuntimeStatusCondition2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeStatusCondition(ctx context.Context, sel ast.SelectionSet, v *RuntimeStatusCondition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORuntimeSystemAuth2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeSystemAuthᚄ(ctx context.Context, sel ast.SelectionSet, v []*RuntimeSystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuntimeSystemAuth2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐRuntimeSystemAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOSystemAuth2githubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuth(ctx context.Context, sel ast.SelectionSet, v SystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SystemAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSystemAuthReferenceType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuthReferenceType(ctx context.Context, v interface{}) (*SystemAuthReferenceType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SystemAuthReferenceType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSystemAuthReferenceType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐSystemAuthReferenceType(ctx context.Context, sel ast.SelectionSet, v *SystemAuthReferenceType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTemplateValueInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTemplateValueInput(ctx context.Context, v interface{}) ([]*TemplateValueInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*TemplateValueInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTemplateValueInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTemplateValueInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTemplateValueInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTemplateValueInput(ctx context.Context, v interface{}) (*TemplateValueInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTemplateValueInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTenant2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantᚄ(ctx context.Context, sel ast.SelectionSet, v []*Tenant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTenant2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTenant2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenant(ctx context.Context, sel ast.SelectionSet, v *Tenant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tenant(ctx, sel, v)
}

func (ec *executionContext) marshalOTenantAccess2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTenantAccess(ctx context.Context, sel ast.SelectionSet, v *TenantAccess) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TenantAccess(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx context.Context, v interface{}) (*Timestamp, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(Timestamp)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTimestamp2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐTimestamp(ctx context.Context, sel ast.SelectionSet, v *Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOVersion2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersion(ctx context.Context, sel ast.SelectionSet, v *Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVersionInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐVersionInput(ctx context.Context, v interface{}) (*VersionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVersionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhook2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookᚄ(ctx context.Context, sel ast.SelectionSet, v []*Webhook) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhook2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhook(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWebhookInput2ᚕᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInputᚄ(ctx context.Context, v interface{}) ([]*WebhookInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*WebhookInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWebhookInput2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWebhookMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookMode(ctx context.Context, v interface{}) (*WebhookMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(WebhookMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookMode2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookMode(ctx context.Context, sel ast.SelectionSet, v *WebhookMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOWebhookType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx context.Context, v interface{}) (*WebhookType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(WebhookType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookType2ᚖgithubᚗcomᚋkymaᚑincubatorᚋcompassᚋcomponentsᚋdirectorᚋpkgᚋgraphqlᚐWebhookType(ctx context.Context, sel ast.SelectionSet, v *WebhookType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
