// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	APIDefinition() APIDefinitionResolver
	APISpec() APISpecResolver
	Application() ApplicationResolver
	ApplicationTemplate() ApplicationTemplateResolver
	Bundle() BundleResolver
	Document() DocumentResolver
	EventDefinition() EventDefinitionResolver
	EventSpec() EventSpecResolver
	Formation() FormationResolver
	FormationAssignment() FormationAssignmentResolver
	FormationTemplate() FormationTemplateResolver
	IntegrationSystem() IntegrationSystemResolver
	Mutation() MutationResolver
	OneTimeTokenForApplication() OneTimeTokenForApplicationResolver
	OneTimeTokenForRuntime() OneTimeTokenForRuntimeResolver
	Query() QueryResolver
	Runtime() RuntimeResolver
	RuntimeContext() RuntimeContextResolver
	Tenant() TenantResolver
}

type DirectiveRoot struct {
	Async                         func(ctx context.Context, obj interface{}, next graphql.Resolver, operationType OperationType, webhookType *WebhookType, idField *string) (res interface{}, err error)
	HasScenario                   func(ctx context.Context, obj interface{}, next graphql.Resolver, applicationProvider string, idField string) (res interface{}, err error)
	HasScopes                     func(ctx context.Context, obj interface{}, next graphql.Resolver, path string) (res interface{}, err error)
	Sanitize                      func(ctx context.Context, obj interface{}, next graphql.Resolver, path string) (res interface{}, err error)
	SynchronizeApplicationTenancy func(ctx context.Context, obj interface{}, next graphql.Resolver, eventType EventType) (res interface{}, err error)
	Validate                      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	APIDefinition struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		Error       func(childComplexity int) int
		Group       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Spec        func(childComplexity int) int
		TargetURL   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	APIDefinitionPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	APISpec struct {
		Data         func(childComplexity int) int
		FetchRequest func(childComplexity int) int
		Format       func(childComplexity int) int
		ID           func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	AppSystemAuth struct {
		Auth              func(childComplexity int) int
		ID                func(childComplexity int) int
		ReferenceObjectID func(childComplexity int) int
		TenantID          func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Application struct {
		APIDefinition           func(childComplexity int, id string) int
		ApplicationNamespace    func(childComplexity int) int
		ApplicationTemplate     func(childComplexity int) int
		ApplicationTemplateID   func(childComplexity int) int
		Auths                   func(childComplexity int) int
		BaseURL                 func(childComplexity int) int
		Bundle                  func(childComplexity int, id string) int
		Bundles                 func(childComplexity int, first *int, after *PageCursor) int
		CreatedAt               func(childComplexity int) int
		DeletedAt               func(childComplexity int) int
		Description             func(childComplexity int) int
		Error                   func(childComplexity int) int
		EventDefinition         func(childComplexity int, id string) int
		EventingConfiguration   func(childComplexity int) int
		HealthCheckURL          func(childComplexity int) int
		ID                      func(childComplexity int) int
		IntegrationDependencies func(childComplexity int, first *int, after *PageCursor) int
		IntegrationSystemID     func(childComplexity int) int
		Labels                  func(childComplexity int, key *string) int
		LocalTenantID           func(childComplexity int) int
		Name                    func(childComplexity int) int
		ProviderName            func(childComplexity int) int
		Status                  func(childComplexity int) int
		SystemNumber            func(childComplexity int) int
		SystemStatus            func(childComplexity int) int
		UpdatedAt               func(childComplexity int) int
		Webhooks                func(childComplexity int) int
	}

	ApplicationEventingConfiguration struct {
		DefaultURL func(childComplexity int) int
	}

	ApplicationPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ApplicationStatus struct {
		Condition func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	ApplicationTemplate struct {
		AccessLevel          func(childComplexity int) int
		ApplicationInput     func(childComplexity int) int
		ApplicationNamespace func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		Description          func(childComplexity int) int
		ID                   func(childComplexity int) int
		Labels               func(childComplexity int, key *string) int
		Name                 func(childComplexity int) int
		Placeholders         func(childComplexity int) int
		UpdatedAt            func(childComplexity int) int
		Webhooks             func(childComplexity int) int
	}

	ApplicationTemplatePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Aspect struct {
		APIResources   func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		DeletedAt      func(childComplexity int) int
		Description    func(childComplexity int) int
		Error          func(childComplexity int) int
		EventResources func(childComplexity int) int
		ID             func(childComplexity int) int
		Mandatory      func(childComplexity int) int
		Name           func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	AspectAPIDefinition struct {
		OrdID func(childComplexity int) int
	}

	AspectEventDefinition struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		Error     func(childComplexity int) int
		OrdID     func(childComplexity int) int
		Subset    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	AspectEventDefinitionSubset struct {
		EventType func(childComplexity int) int
	}

	Auth struct {
		AccessStrategy                  func(childComplexity int) int
		AdditionalHeaders               func(childComplexity int) int
		AdditionalHeadersSerialized     func(childComplexity int) int
		AdditionalQueryParams           func(childComplexity int) int
		AdditionalQueryParamsSerialized func(childComplexity int) int
		CertCommonName                  func(childComplexity int) int
		Credential                      func(childComplexity int) int
		OneTimeToken                    func(childComplexity int) int
		RequestAuth                     func(childComplexity int) int
	}

	AutomaticScenarioAssignment struct {
		ScenarioName func(childComplexity int) int
		Selector     func(childComplexity int) int
	}

	AutomaticScenarioAssignmentPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BasicCredentialData struct {
		Password func(childComplexity int) int
		Username func(childComplexity int) int
	}

	Bundle struct {
		APIDefinition                  func(childComplexity int, id string) int
		APIDefinitions                 func(childComplexity int, group *string, first *int, after *PageCursor) int
		CorrelationIDs                 func(childComplexity int) int
		CreatedAt                      func(childComplexity int) int
		DefaultInstanceAuth            func(childComplexity int) int
		DeletedAt                      func(childComplexity int) int
		Description                    func(childComplexity int) int
		Document                       func(childComplexity int, id string) int
		Documents                      func(childComplexity int, first *int, after *PageCursor) int
		Error                          func(childComplexity int) int
		EventDefinition                func(childComplexity int, id string) int
		EventDefinitions               func(childComplexity int, group *string, first *int, after *PageCursor) int
		ID                             func(childComplexity int) int
		InstanceAuth                   func(childComplexity int, id string) int
		InstanceAuthRequestInputSchema func(childComplexity int) int
		InstanceAuths                  func(childComplexity int) int
		Name                           func(childComplexity int) int
		UpdatedAt                      func(childComplexity int) int
	}

	BundleInstanceAuth struct {
		Auth             func(childComplexity int) int
		Context          func(childComplexity int) int
		ID               func(childComplexity int) int
		InputParams      func(childComplexity int) int
		RuntimeContextID func(childComplexity int) int
		RuntimeID        func(childComplexity int) int
		Status           func(childComplexity int) int
	}

	BundleInstanceAuthStatus struct {
		Condition func(childComplexity int) int
		Message   func(childComplexity int) int
		Reason    func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	BundlePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CSRFTokenCredentialRequestAuth struct {
		AdditionalHeaders               func(childComplexity int) int
		AdditionalHeadersSerialized     func(childComplexity int) int
		AdditionalQueryParams           func(childComplexity int) int
		AdditionalQueryParamsSerialized func(childComplexity int) int
		Credential                      func(childComplexity int) int
		TokenEndpointURL                func(childComplexity int) int
	}

	CertificateOAuthCredentialData struct {
		Certificate func(childComplexity int) int
		ClientID    func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	CertificateSubjectMapping struct {
		ConsumerType       func(childComplexity int) int
		ID                 func(childComplexity int) int
		InternalConsumerID func(childComplexity int) int
		Subject            func(childComplexity int) int
		TenantAccessLevels func(childComplexity int) int
	}

	CertificateSubjectMappingPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ConstraintReference struct {
		ConstraintID        func(childComplexity int) int
		FormationTemplateID func(childComplexity int) int
	}

	CredentialRequestAuth struct {
		Csrf func(childComplexity int) int
	}

	Document struct {
		CreatedAt    func(childComplexity int) int
		Data         func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		DisplayName  func(childComplexity int) int
		Error        func(childComplexity int) int
		FetchRequest func(childComplexity int) int
		Format       func(childComplexity int) int
		ID           func(childComplexity int) int
		Kind         func(childComplexity int) int
		Title        func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	DocumentPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EventDefinition struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		Error       func(childComplexity int) int
		Group       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Spec        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	EventDefinitionPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EventSpec struct {
		Data         func(childComplexity int) int
		FetchRequest func(childComplexity int) int
		Format       func(childComplexity int) int
		ID           func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	FetchRequest struct {
		Auth   func(childComplexity int) int
		Filter func(childComplexity int) int
		Mode   func(childComplexity int) int
		Status func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	FetchRequestStatus struct {
		Condition func(childComplexity int) int
		Message   func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	Formation struct {
		Error                         func(childComplexity int) int
		FormationAssignment           func(childComplexity int, id string) int
		FormationAssignments          func(childComplexity int, first *int, after *PageCursor) int
		FormationTemplateID           func(childComplexity int) int
		ID                            func(childComplexity int) int
		LastNotificationSentTimestamp func(childComplexity int) int
		LastStateChangeTimestamp      func(childComplexity int) int
		Name                          func(childComplexity int) int
		State                         func(childComplexity int) int
		Status                        func(childComplexity int) int
		TenantID                      func(childComplexity int) int
	}

	FormationAssignment struct {
		Configuration                 func(childComplexity int) int
		Error                         func(childComplexity int) int
		ID                            func(childComplexity int) int
		LastNotificationSentTimestamp func(childComplexity int) int
		LastStateChangeTimestamp      func(childComplexity int) int
		Source                        func(childComplexity int) int
		SourceEntity                  func(childComplexity int) int
		SourceType                    func(childComplexity int) int
		State                         func(childComplexity int) int
		Target                        func(childComplexity int) int
		TargetEntity                  func(childComplexity int) int
		TargetType                    func(childComplexity int) int
		Value                         func(childComplexity int) int
	}

	FormationAssignmentPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	FormationConstraint struct {
		ConstraintScope func(childComplexity int) int
		ConstraintType  func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Description     func(childComplexity int) int
		ID              func(childComplexity int) int
		InputTemplate   func(childComplexity int) int
		Name            func(childComplexity int) int
		Operator        func(childComplexity int) int
		Priority        func(childComplexity int) int
		ResourceSubtype func(childComplexity int) int
		ResourceType    func(childComplexity int) int
		TargetOperation func(childComplexity int) int
	}

	FormationError struct {
		ErrorCode func(childComplexity int) int
		Message   func(childComplexity int) int
	}

	FormationPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	FormationStatus struct {
		Condition func(childComplexity int) int
		Errors    func(childComplexity int) int
	}

	FormationStatusError struct {
		AssignmentID func(childComplexity int) int
		ErrorCode    func(childComplexity int) int
		Message      func(childComplexity int) int
	}

	FormationTemplate struct {
		ApplicationTypes       func(childComplexity int) int
		DiscoveryConsumers     func(childComplexity int) int
		FormationConstraints   func(childComplexity int) int
		ID                     func(childComplexity int) int
		LeadingProductIDs      func(childComplexity int) int
		Name                   func(childComplexity int) int
		RuntimeArtifactKind    func(childComplexity int) int
		RuntimeTypeDisplayName func(childComplexity int) int
		RuntimeTypes           func(childComplexity int) int
		SupportsReset          func(childComplexity int) int
		Webhooks               func(childComplexity int) int
	}

	FormationTemplatePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HealthCheck struct {
		Condition func(childComplexity int) int
		Message   func(childComplexity int) int
		Origin    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	HealthCheckPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IntSysSystemAuth struct {
		Auth              func(childComplexity int) int
		ID                func(childComplexity int) int
		ReferenceObjectID func(childComplexity int) int
		TenantID          func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	IntegrationDependency struct {
		Aspects       func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		Error         func(childComplexity int) int
		ID            func(childComplexity int) int
		Labels        func(childComplexity int) int
		Mandatory     func(childComplexity int) int
		Name          func(childComplexity int) int
		OrdID         func(childComplexity int) int
		PartOfPackage func(childComplexity int) int
		ReleaseStatus func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Version       func(childComplexity int) int
		Visibility    func(childComplexity int) int
	}

	IntegrationDependencyPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IntegrationSystem struct {
		Auths       func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	IntegrationSystemPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Label struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	LabelDefinition struct {
		Key    func(childComplexity int) int
		Schema func(childComplexity int) int
	}

	Mutation struct {
		AddAPIDefinitionToApplication                func(childComplexity int, appID string, in APIDefinitionInput) int
		AddAPIDefinitionToBundle                     func(childComplexity int, bundleID string, in APIDefinitionInput) int
		AddBundle                                    func(childComplexity int, applicationID string, in BundleCreateInput) int
		AddDocumentToBundle                          func(childComplexity int, bundleID string, in DocumentInput) int
		AddEventDefinitionToApplication              func(childComplexity int, appID string, in EventDefinitionInput) int
		AddEventDefinitionToBundle                   func(childComplexity int, bundleID string, in EventDefinitionInput) int
		AddIntegrationDependencyToApplication        func(childComplexity int, appID string, in IntegrationDependencyInput) int
		AddTenantAccess                              func(childComplexity int, in TenantAccessInput) int
		AddWebhook                                   func(childComplexity int, applicationID *string, applicationTemplateID *string, runtimeID *string, formationTemplateID *string, in WebhookInput) int
		AssignFormation                              func(childComplexity int, objectID string, objectType FormationObjectType, formation FormationInput) int
		AttachConstraintToFormationTemplate          func(childComplexity int, constraintID string, formationTemplateID string) int
		CreateApplicationTemplate                    func(childComplexity int, in ApplicationTemplateInput) int
		CreateBundleInstanceAuth                     func(childComplexity int, bundleID string, in BundleInstanceAuthCreateInput) int
		CreateCertificateSubjectMapping              func(childComplexity int, in CertificateSubjectMappingInput) int
		CreateFormation                              func(childComplexity int, formation FormationInput) int
		CreateFormationConstraint                    func(childComplexity int, formationConstraint FormationConstraintInput) int
		CreateFormationTemplate                      func(childComplexity int, in FormationTemplateInput) int
		CreateLabelDefinition                        func(childComplexity int, in LabelDefinitionInput) int
		DeleteAPIDefinition                          func(childComplexity int, id string) int
		DeleteApplicationLabel                       func(childComplexity int, applicationID string, key string) int
		DeleteApplicationTemplate                    func(childComplexity int, id string) int
		DeleteBundle                                 func(childComplexity int, id string) int
		DeleteBundleInstanceAuth                     func(childComplexity int, authID string) int
		DeleteCertificateSubjectMapping              func(childComplexity int, id string) int
		DeleteDefaultEventingForApplication          func(childComplexity int, appID string) int
		DeleteDocument                               func(childComplexity int, id string) int
		DeleteEventDefinition                        func(childComplexity int, id string) int
		DeleteFormation                              func(childComplexity int, formation FormationInput) int
		DeleteFormationConstraint                    func(childComplexity int, id string) int
		DeleteFormationTemplate                      func(childComplexity int, id string) int
		DeleteIntegrationDependency                  func(childComplexity int, id string) int
		DeleteRuntimeLabel                           func(childComplexity int, runtimeID string, key string) int
		DeleteSystemAuthForApplication               func(childComplexity int, authID string) int
		DeleteSystemAuthForIntegrationSystem         func(childComplexity int, authID string) int
		DeleteSystemAuthForRuntime                   func(childComplexity int, authID string) int
		DeleteTenants                                func(childComplexity int, in []string) int
		DeleteWebhook                                func(childComplexity int, webhookID string) int
		DetachConstraintFromFormationTemplate        func(childComplexity int, constraintID string, formationTemplateID string) int
		FinalizeDraftFormation                       func(childComplexity int, formationID string) int
		InvalidateSystemAuthOneTimeToken             func(childComplexity int, authID string) int
		MergeApplications                            func(childComplexity int, destinationID string, sourceID string) int
		RefetchAPISpec                               func(childComplexity int, apiID string) int
		RefetchEventDefinitionSpec                   func(childComplexity int, eventID string) int
		RegisterApplication                          func(childComplexity int, in ApplicationRegisterInput, mode *OperationMode) int
		RegisterApplicationFromTemplate              func(childComplexity int, in ApplicationFromTemplateInput) int
		RegisterIntegrationSystem                    func(childComplexity int, in IntegrationSystemInput) int
		RegisterRuntime                              func(childComplexity int, in RuntimeRegisterInput) int
		RegisterRuntimeContext                       func(childComplexity int, runtimeID string, in RuntimeContextInput) int
		RemoveTenantAccess                           func(childComplexity int, tenantID string, resourceID string, resourceType TenantAccessObjectType) int
		RequestBundleInstanceAuthCreation            func(childComplexity int, bundleID string, in BundleInstanceAuthRequestInput) int
		RequestBundleInstanceAuthDeletion            func(childComplexity int, authID string) int
		RequestClientCredentialsForApplication       func(childComplexity int, id string) int
		RequestClientCredentialsForIntegrationSystem func(childComplexity int, id string) int
		RequestClientCredentialsForRuntime           func(childComplexity int, id string) int
		RequestOneTimeTokenForApplication            func(childComplexity int, id string, systemAuthID *string) int
		RequestOneTimeTokenForRuntime                func(childComplexity int, id string, systemAuthID *string) int
		ResynchronizeFormationNotifications          func(childComplexity int, formationID string, reset *bool) int
		SetApplicationLabel                          func(childComplexity int, applicationID string, key string, value interface{}) int
		SetBundleInstanceAuth                        func(childComplexity int, authID string, in BundleInstanceAuthSetInput) int
		SetDefaultEventingForApplication             func(childComplexity int, appID string, runtimeID string) int
		SetRuntimeLabel                              func(childComplexity int, runtimeID string, key string, value interface{}) int
		SetTenantLabel                               func(childComplexity int, tenantID string, key string, value interface{}) int
		SubscribeTenant                              func(childComplexity int, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionAppName string, subscriptionPayload string) int
		UnassignFormation                            func(childComplexity int, objectID string, objectType FormationObjectType, formation FormationInput) int
		UnassignFormationGlobal                      func(childComplexity int, objectID string, objectType FormationObjectType, formation string) int
		UnpairApplication                            func(childComplexity int, id string, mode *OperationMode) int
		UnregisterApplication                        func(childComplexity int, id string, mode *OperationMode) int
		UnregisterIntegrationSystem                  func(childComplexity int, id string) int
		UnregisterRuntime                            func(childComplexity int, id string) int
		UnregisterRuntimeContext                     func(childComplexity int, id string) int
		UnsubscribeTenant                            func(childComplexity int, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionPayload string) int
		UpdateAPIDefinition                          func(childComplexity int, id string, in APIDefinitionInput) int
		UpdateAPIDefinitionForApplication            func(childComplexity int, id string, in APIDefinitionInput) int
		UpdateApplication                            func(childComplexity int, id string, in ApplicationUpdateInput) int
		UpdateApplicationTemplate                    func(childComplexity int, id string, override *bool, in ApplicationTemplateUpdateInput) int
		UpdateBundle                                 func(childComplexity int, id string, in BundleUpdateInput) int
		UpdateBundleInstanceAuth                     func(childComplexity int, id string, bundleID string, in BundleInstanceAuthUpdateInput) int
		UpdateCertificateSubjectMapping              func(childComplexity int, id string, in CertificateSubjectMappingInput) int
		UpdateEventDefinition                        func(childComplexity int, id string, in EventDefinitionInput) int
		UpdateEventDefinitionForApplication          func(childComplexity int, id string, in EventDefinitionInput) int
		UpdateFormationConstraint                    func(childComplexity int, id string, in FormationConstraintUpdateInput) int
		UpdateFormationTemplate                      func(childComplexity int, id string, in FormationTemplateInput) int
		UpdateIntegrationSystem                      func(childComplexity int, id string, in IntegrationSystemInput) int
		UpdateLabelDefinition                        func(childComplexity int, in LabelDefinitionInput) int
		UpdateRuntime                                func(childComplexity int, id string, in RuntimeUpdateInput) int
		UpdateRuntimeContext                         func(childComplexity int, id string, in RuntimeContextInput) int
		UpdateSystemAuth                             func(childComplexity int, authID string, in AuthInput) int
		UpdateTenant                                 func(childComplexity int, id string, in BusinessTenantMappingInput) int
		UpdateWebhook                                func(childComplexity int, webhookID string, in WebhookInput) int
		WriteTenant                                  func(childComplexity int, in BusinessTenantMappingInput) int
		WriteTenants                                 func(childComplexity int, in []*BusinessTenantMappingInput) int
	}

	OAuthCredentialData struct {
		ClientID     func(childComplexity int) int
		ClientSecret func(childComplexity int) int
		URL          func(childComplexity int) int
	}

	OneTimeTokenForApplication struct {
		ConnectorURL       func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		ExpiresAt          func(childComplexity int) int
		LegacyConnectorURL func(childComplexity int) int
		Raw                func(childComplexity int) int
		RawEncoded         func(childComplexity int) int
		ScenarioGroups     func(childComplexity int) int
		Token              func(childComplexity int) int
		Type               func(childComplexity int) int
		Used               func(childComplexity int) int
		UsedAt             func(childComplexity int) int
	}

	OneTimeTokenForRuntime struct {
		ConnectorURL func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		ExpiresAt    func(childComplexity int) int
		Raw          func(childComplexity int) int
		RawEncoded   func(childComplexity int) int
		Token        func(childComplexity int) int
		Type         func(childComplexity int) int
		Used         func(childComplexity int) int
		UsedAt       func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor   func(childComplexity int) int
		HasNextPage func(childComplexity int) int
		StartCursor func(childComplexity int) int
	}

	PlaceholderDefinition struct {
		Description func(childComplexity int) int
		JSONPath    func(childComplexity int) int
		Name        func(childComplexity int) int
		Optional    func(childComplexity int) int
	}

	Query struct {
		ApisForApplication                         func(childComplexity int, appID string, first *int, after *PageCursor) int
		Application                                func(childComplexity int, id string) int
		ApplicationByLocalTenantIDAndAppTemplateID func(childComplexity int, localTenantID string, applicationTemplateID string) int
		ApplicationBySystemNumber                  func(childComplexity int, systemNumber string) int
		ApplicationTemplate                        func(childComplexity int, id string) int
		ApplicationTemplates                       func(childComplexity int, filter []*LabelFilter, first *int, after *PageCursor) int
		Applications                               func(childComplexity int, filter []*LabelFilter, first *int, after *PageCursor) int
		ApplicationsForRuntime                     func(childComplexity int, runtimeID string, first *int, after *PageCursor) int
		AutomaticScenarioAssignmentForScenario     func(childComplexity int, scenarioName string) int
		AutomaticScenarioAssignments               func(childComplexity int, first *int, after *PageCursor) int
		AutomaticScenarioAssignmentsForSelector    func(childComplexity int, selector LabelSelectorInput) int
		BundleByInstanceAuth                       func(childComplexity int, authID string) int
		BundleInstanceAuth                         func(childComplexity int, id string) int
		CertificateSubjectMapping                  func(childComplexity int, id string) int
		CertificateSubjectMappings                 func(childComplexity int, first *int, after *PageCursor) int
		EventsForApplication                       func(childComplexity int, appID string, first *int, after *PageCursor) int
		Formation                                  func(childComplexity int, id string) int
		FormationByName                            func(childComplexity int, name string) int
		FormationConstraint                        func(childComplexity int, id string) int
		FormationConstraints                       func(childComplexity int) int
		FormationConstraintsByFormationType        func(childComplexity int, formationTemplateID string) int
		FormationTemplate                          func(childComplexity int, id string) int
		FormationTemplates                         func(childComplexity int, first *int, after *PageCursor) int
		FormationTemplatesByName                   func(childComplexity int, name string, first *int, after *PageCursor) int
		Formations                                 func(childComplexity int, first *int, after *PageCursor) int
		FormationsForObject                        func(childComplexity int, objectID string) int
		HealthChecks                               func(childComplexity int, types []HealthCheckType, origin *string, first *int, after *PageCursor) int
		IntegrationSystem                          func(childComplexity int, id string) int
		IntegrationSystems                         func(childComplexity int, first *int, after *PageCursor) int
		LabelDefinition                            func(childComplexity int, key string) int
		LabelDefinitions                           func(childComplexity int) int
		RootTenants                                func(childComplexity int, externalTenant string) int
		Runtime                                    func(childComplexity int, id string) int
		RuntimeByTokenIssuer                       func(childComplexity int, issuer string) int
		Runtimes                                   func(childComplexity int, filter []*LabelFilter, first *int, after *PageCursor) int
		SystemAuth                                 func(childComplexity int, id string) int
		SystemAuthByToken                          func(childComplexity int, token string) int
		TenantByExternalID                         func(childComplexity int, id string) int
		TenantByInternalID                         func(childComplexity int, id string) int
		TenantByLowestOwnerForResource             func(childComplexity int, id string, resource string) int
		Tenants                                    func(childComplexity int, first *int, after *PageCursor, searchTerm *string) int
		Viewer                                     func(childComplexity int) int
	}

	Runtime struct {
		ApplicationNamespace  func(childComplexity int) int
		Auths                 func(childComplexity int) int
		Description           func(childComplexity int) int
		EventingConfiguration func(childComplexity int) int
		ID                    func(childComplexity int) int
		Labels                func(childComplexity int, key *string) int
		Metadata              func(childComplexity int) int
		Name                  func(childComplexity int) int
		RuntimeContext        func(childComplexity int, id string) int
		RuntimeContexts       func(childComplexity int, first *int, after *PageCursor) int
		Status                func(childComplexity int) int
		Webhooks              func(childComplexity int) int
	}

	RuntimeContext struct {
		ID     func(childComplexity int) int
		Key    func(childComplexity int) int
		Labels func(childComplexity int, key *string) int
		Value  func(childComplexity int) int
	}

	RuntimeContextPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RuntimeEventingConfiguration struct {
		DefaultURL func(childComplexity int) int
	}

	RuntimeMetadata struct {
		CreationTimestamp func(childComplexity int) int
	}

	RuntimePage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RuntimeStatus struct {
		Condition func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	RuntimeSystemAuth struct {
		Auth              func(childComplexity int) int
		ID                func(childComplexity int) int
		ReferenceObjectID func(childComplexity int) int
		TenantID          func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Tenant struct {
		ID          func(childComplexity int) int
		Initialized func(childComplexity int) int
		InternalID  func(childComplexity int) int
		Labels      func(childComplexity int, key *string) int
		Name        func(childComplexity int) int
		Parents     func(childComplexity int) int
		Provider    func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	TenantAccess struct {
		Owner        func(childComplexity int) int
		ResourceID   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		TenantID     func(childComplexity int) int
	}

	TenantPage struct {
		Data       func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Version struct {
		Deprecated      func(childComplexity int) int
		DeprecatedSince func(childComplexity int) int
		ForRemoval      func(childComplexity int) int
		Value           func(childComplexity int) int
	}

	Viewer struct {
		ID   func(childComplexity int) int
		Type func(childComplexity int) int
	}

	Webhook struct {
		ApplicationID         func(childComplexity int) int
		ApplicationTemplateID func(childComplexity int) int
		Auth                  func(childComplexity int) int
		CorrelationIDKey      func(childComplexity int) int
		CreatedAt             func(childComplexity int) int
		FormationTemplateID   func(childComplexity int) int
		HeaderTemplate        func(childComplexity int) int
		ID                    func(childComplexity int) int
		InputTemplate         func(childComplexity int) int
		IntegrationSystemID   func(childComplexity int) int
		Mode                  func(childComplexity int) int
		OutputTemplate        func(childComplexity int) int
		RetryInterval         func(childComplexity int) int
		RuntimeID             func(childComplexity int) int
		StatusTemplate        func(childComplexity int) int
		Timeout               func(childComplexity int) int
		Type                  func(childComplexity int) int
		URL                   func(childComplexity int) int
		URLTemplate           func(childComplexity int) int
	}
}

type APIDefinitionResolver interface {
	Spec(ctx context.Context, obj *APIDefinition) (*APISpec, error)
}
type APISpecResolver interface {
	FetchRequest(ctx context.Context, obj *APISpec) (*FetchRequest, error)
}
type ApplicationResolver interface {
	ApplicationTemplate(ctx context.Context, obj *Application) (*ApplicationTemplate, error)
	Labels(ctx context.Context, obj *Application, key *string) (Labels, error)

	Webhooks(ctx context.Context, obj *Application) ([]*Webhook, error)

	Bundles(ctx context.Context, obj *Application, first *int, after *PageCursor) (*BundlePage, error)
	Bundle(ctx context.Context, obj *Application, id string) (*Bundle, error)
	APIDefinition(ctx context.Context, obj *Application, id string) (*APIDefinition, error)
	EventDefinition(ctx context.Context, obj *Application, id string) (*EventDefinition, error)
	IntegrationDependencies(ctx context.Context, obj *Application, first *int, after *PageCursor) (*IntegrationDependencyPage, error)
	Auths(ctx context.Context, obj *Application) ([]*AppSystemAuth, error)
	EventingConfiguration(ctx context.Context, obj *Application) (*ApplicationEventingConfiguration, error)
}
type ApplicationTemplateResolver interface {
	Webhooks(ctx context.Context, obj *ApplicationTemplate) ([]*Webhook, error)

	Labels(ctx context.Context, obj *ApplicationTemplate, key *string) (Labels, error)
}
type BundleResolver interface {
	InstanceAuth(ctx context.Context, obj *Bundle, id string) (*BundleInstanceAuth, error)
	InstanceAuths(ctx context.Context, obj *Bundle) ([]*BundleInstanceAuth, error)

	APIDefinitions(ctx context.Context, obj *Bundle, group *string, first *int, after *PageCursor) (*APIDefinitionPage, error)
	EventDefinitions(ctx context.Context, obj *Bundle, group *string, first *int, after *PageCursor) (*EventDefinitionPage, error)
	Documents(ctx context.Context, obj *Bundle, first *int, after *PageCursor) (*DocumentPage, error)
	APIDefinition(ctx context.Context, obj *Bundle, id string) (*APIDefinition, error)
	EventDefinition(ctx context.Context, obj *Bundle, id string) (*EventDefinition, error)

	Document(ctx context.Context, obj *Bundle, id string) (*Document, error)
}
type DocumentResolver interface {
	FetchRequest(ctx context.Context, obj *Document) (*FetchRequest, error)
}
type EventDefinitionResolver interface {
	Spec(ctx context.Context, obj *EventDefinition) (*EventSpec, error)
}
type EventSpecResolver interface {
	FetchRequest(ctx context.Context, obj *EventSpec) (*FetchRequest, error)
}
type FormationResolver interface {
	FormationAssignment(ctx context.Context, obj *Formation, id string) (*FormationAssignment, error)
	FormationAssignments(ctx context.Context, obj *Formation, first *int, after *PageCursor) (*FormationAssignmentPage, error)
	Status(ctx context.Context, obj *Formation) (*FormationStatus, error)
}
type FormationAssignmentResolver interface {
	SourceEntity(ctx context.Context, obj *FormationAssignment) (FormationParticipant, error)

	TargetEntity(ctx context.Context, obj *FormationAssignment) (FormationParticipant, error)
}
type FormationTemplateResolver interface {
	Webhooks(ctx context.Context, obj *FormationTemplate) ([]*Webhook, error)

	FormationConstraints(ctx context.Context, obj *FormationTemplate) ([]*FormationConstraint, error)
}
type IntegrationSystemResolver interface {
	Auths(ctx context.Context, obj *IntegrationSystem) ([]*IntSysSystemAuth, error)
}
type MutationResolver interface {
	RegisterApplication(ctx context.Context, in ApplicationRegisterInput, mode *OperationMode) (*Application, error)
	UpdateApplication(ctx context.Context, id string, in ApplicationUpdateInput) (*Application, error)
	UnregisterApplication(ctx context.Context, id string, mode *OperationMode) (*Application, error)
	UnpairApplication(ctx context.Context, id string, mode *OperationMode) (*Application, error)
	CreateApplicationTemplate(ctx context.Context, in ApplicationTemplateInput) (*ApplicationTemplate, error)
	RegisterApplicationFromTemplate(ctx context.Context, in ApplicationFromTemplateInput) (*Application, error)
	UpdateApplicationTemplate(ctx context.Context, id string, override *bool, in ApplicationTemplateUpdateInput) (*ApplicationTemplate, error)
	DeleteApplicationTemplate(ctx context.Context, id string) (*ApplicationTemplate, error)
	MergeApplications(ctx context.Context, destinationID string, sourceID string) (*Application, error)
	RegisterRuntime(ctx context.Context, in RuntimeRegisterInput) (*Runtime, error)
	UpdateRuntime(ctx context.Context, id string, in RuntimeUpdateInput) (*Runtime, error)
	UnregisterRuntime(ctx context.Context, id string) (*Runtime, error)
	RegisterRuntimeContext(ctx context.Context, runtimeID string, in RuntimeContextInput) (*RuntimeContext, error)
	UpdateRuntimeContext(ctx context.Context, id string, in RuntimeContextInput) (*RuntimeContext, error)
	UnregisterRuntimeContext(ctx context.Context, id string) (*RuntimeContext, error)
	RegisterIntegrationSystem(ctx context.Context, in IntegrationSystemInput) (*IntegrationSystem, error)
	UpdateIntegrationSystem(ctx context.Context, id string, in IntegrationSystemInput) (*IntegrationSystem, error)
	UnregisterIntegrationSystem(ctx context.Context, id string) (*IntegrationSystem, error)
	AddWebhook(ctx context.Context, applicationID *string, applicationTemplateID *string, runtimeID *string, formationTemplateID *string, in WebhookInput) (*Webhook, error)
	UpdateWebhook(ctx context.Context, webhookID string, in WebhookInput) (*Webhook, error)
	DeleteWebhook(ctx context.Context, webhookID string) (*Webhook, error)
	AddAPIDefinitionToBundle(ctx context.Context, bundleID string, in APIDefinitionInput) (*APIDefinition, error)
	AddAPIDefinitionToApplication(ctx context.Context, appID string, in APIDefinitionInput) (*APIDefinition, error)
	UpdateAPIDefinition(ctx context.Context, id string, in APIDefinitionInput) (*APIDefinition, error)
	UpdateAPIDefinitionForApplication(ctx context.Context, id string, in APIDefinitionInput) (*APIDefinition, error)
	DeleteAPIDefinition(ctx context.Context, id string) (*APIDefinition, error)
	RefetchAPISpec(ctx context.Context, apiID string) (*APISpec, error)
	AddIntegrationDependencyToApplication(ctx context.Context, appID string, in IntegrationDependencyInput) (*IntegrationDependency, error)
	DeleteIntegrationDependency(ctx context.Context, id string) (*IntegrationDependency, error)
	RequestOneTimeTokenForRuntime(ctx context.Context, id string, systemAuthID *string) (*OneTimeTokenForRuntime, error)
	RequestOneTimeTokenForApplication(ctx context.Context, id string, systemAuthID *string) (*OneTimeTokenForApplication, error)
	RequestClientCredentialsForRuntime(ctx context.Context, id string) (SystemAuth, error)
	RequestClientCredentialsForApplication(ctx context.Context, id string) (SystemAuth, error)
	RequestClientCredentialsForIntegrationSystem(ctx context.Context, id string) (SystemAuth, error)
	DeleteSystemAuthForRuntime(ctx context.Context, authID string) (SystemAuth, error)
	DeleteSystemAuthForApplication(ctx context.Context, authID string) (SystemAuth, error)
	DeleteSystemAuthForIntegrationSystem(ctx context.Context, authID string) (SystemAuth, error)
	UpdateSystemAuth(ctx context.Context, authID string, in AuthInput) (SystemAuth, error)
	InvalidateSystemAuthOneTimeToken(ctx context.Context, authID string) (SystemAuth, error)
	AddEventDefinitionToBundle(ctx context.Context, bundleID string, in EventDefinitionInput) (*EventDefinition, error)
	AddEventDefinitionToApplication(ctx context.Context, appID string, in EventDefinitionInput) (*EventDefinition, error)
	UpdateEventDefinition(ctx context.Context, id string, in EventDefinitionInput) (*EventDefinition, error)
	UpdateEventDefinitionForApplication(ctx context.Context, id string, in EventDefinitionInput) (*EventDefinition, error)
	DeleteEventDefinition(ctx context.Context, id string) (*EventDefinition, error)
	RefetchEventDefinitionSpec(ctx context.Context, eventID string) (*EventSpec, error)
	AddDocumentToBundle(ctx context.Context, bundleID string, in DocumentInput) (*Document, error)
	DeleteDocument(ctx context.Context, id string) (*Document, error)
	CreateFormation(ctx context.Context, formation FormationInput) (*Formation, error)
	ResynchronizeFormationNotifications(ctx context.Context, formationID string, reset *bool) (*Formation, error)
	FinalizeDraftFormation(ctx context.Context, formationID string) (*Formation, error)
	DeleteFormation(ctx context.Context, formation FormationInput) (*Formation, error)
	AssignFormation(ctx context.Context, objectID string, objectType FormationObjectType, formation FormationInput) (*Formation, error)
	UnassignFormation(ctx context.Context, objectID string, objectType FormationObjectType, formation FormationInput) (*Formation, error)
	UnassignFormationGlobal(ctx context.Context, objectID string, objectType FormationObjectType, formation string) (*Formation, error)
	CreateFormationConstraint(ctx context.Context, formationConstraint FormationConstraintInput) (*FormationConstraint, error)
	DeleteFormationConstraint(ctx context.Context, id string) (*FormationConstraint, error)
	UpdateFormationConstraint(ctx context.Context, id string, in FormationConstraintUpdateInput) (*FormationConstraint, error)
	AttachConstraintToFormationTemplate(ctx context.Context, constraintID string, formationTemplateID string) (*ConstraintReference, error)
	DetachConstraintFromFormationTemplate(ctx context.Context, constraintID string, formationTemplateID string) (*ConstraintReference, error)
	CreateLabelDefinition(ctx context.Context, in LabelDefinitionInput) (*LabelDefinition, error)
	UpdateLabelDefinition(ctx context.Context, in LabelDefinitionInput) (*LabelDefinition, error)
	SetApplicationLabel(ctx context.Context, applicationID string, key string, value interface{}) (*Label, error)
	SetTenantLabel(ctx context.Context, tenantID string, key string, value interface{}) (*Label, error)
	DeleteApplicationLabel(ctx context.Context, applicationID string, key string) (*Label, error)
	SetRuntimeLabel(ctx context.Context, runtimeID string, key string, value interface{}) (*Label, error)
	DeleteRuntimeLabel(ctx context.Context, runtimeID string, key string) (*Label, error)
	SetDefaultEventingForApplication(ctx context.Context, appID string, runtimeID string) (*ApplicationEventingConfiguration, error)
	DeleteDefaultEventingForApplication(ctx context.Context, appID string) (*ApplicationEventingConfiguration, error)
	SetBundleInstanceAuth(ctx context.Context, authID string, in BundleInstanceAuthSetInput) (*BundleInstanceAuth, error)
	DeleteBundleInstanceAuth(ctx context.Context, authID string) (*BundleInstanceAuth, error)
	RequestBundleInstanceAuthCreation(ctx context.Context, bundleID string, in BundleInstanceAuthRequestInput) (*BundleInstanceAuth, error)
	RequestBundleInstanceAuthDeletion(ctx context.Context, authID string) (*BundleInstanceAuth, error)
	CreateBundleInstanceAuth(ctx context.Context, bundleID string, in BundleInstanceAuthCreateInput) (*BundleInstanceAuth, error)
	UpdateBundleInstanceAuth(ctx context.Context, id string, bundleID string, in BundleInstanceAuthUpdateInput) (*BundleInstanceAuth, error)
	AddBundle(ctx context.Context, applicationID string, in BundleCreateInput) (*Bundle, error)
	UpdateBundle(ctx context.Context, id string, in BundleUpdateInput) (*Bundle, error)
	DeleteBundle(ctx context.Context, id string) (*Bundle, error)
	WriteTenants(ctx context.Context, in []*BusinessTenantMappingInput) ([]string, error)
	WriteTenant(ctx context.Context, in BusinessTenantMappingInput) (string, error)
	DeleteTenants(ctx context.Context, in []string) (int, error)
	UpdateTenant(ctx context.Context, id string, in BusinessTenantMappingInput) (*Tenant, error)
	SubscribeTenant(ctx context.Context, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionAppName string, subscriptionPayload string) (bool, error)
	UnsubscribeTenant(ctx context.Context, providerID string, subaccountID string, providerSubaccountID string, consumerTenantID string, region string, subscriptionPayload string) (bool, error)
	CreateFormationTemplate(ctx context.Context, in FormationTemplateInput) (*FormationTemplate, error)
	DeleteFormationTemplate(ctx context.Context, id string) (*FormationTemplate, error)
	UpdateFormationTemplate(ctx context.Context, id string, in FormationTemplateInput) (*FormationTemplate, error)
	CreateCertificateSubjectMapping(ctx context.Context, in CertificateSubjectMappingInput) (*CertificateSubjectMapping, error)
	UpdateCertificateSubjectMapping(ctx context.Context, id string, in CertificateSubjectMappingInput) (*CertificateSubjectMapping, error)
	DeleteCertificateSubjectMapping(ctx context.Context, id string) (*CertificateSubjectMapping, error)
	AddTenantAccess(ctx context.Context, in TenantAccessInput) (*TenantAccess, error)
	RemoveTenantAccess(ctx context.Context, tenantID string, resourceID string, resourceType TenantAccessObjectType) (*TenantAccess, error)
}
type OneTimeTokenForApplicationResolver interface {
	Raw(ctx context.Context, obj *OneTimeTokenForApplication) (*string, error)
	RawEncoded(ctx context.Context, obj *OneTimeTokenForApplication) (*string, error)
}
type OneTimeTokenForRuntimeResolver interface {
	Raw(ctx context.Context, obj *OneTimeTokenForRuntime) (*string, error)
	RawEncoded(ctx context.Context, obj *OneTimeTokenForRuntime) (*string, error)
}
type QueryResolver interface {
	ApisForApplication(ctx context.Context, appID string, first *int, after *PageCursor) (*APIDefinitionPage, error)
	EventsForApplication(ctx context.Context, appID string, first *int, after *PageCursor) (*EventDefinitionPage, error)
	Applications(ctx context.Context, filter []*LabelFilter, first *int, after *PageCursor) (*ApplicationPage, error)
	Application(ctx context.Context, id string) (*Application, error)
	ApplicationBySystemNumber(ctx context.Context, systemNumber string) (*Application, error)
	ApplicationByLocalTenantIDAndAppTemplateID(ctx context.Context, localTenantID string, applicationTemplateID string) (*Application, error)
	ApplicationsForRuntime(ctx context.Context, runtimeID string, first *int, after *PageCursor) (*ApplicationPage, error)
	ApplicationTemplates(ctx context.Context, filter []*LabelFilter, first *int, after *PageCursor) (*ApplicationTemplatePage, error)
	ApplicationTemplate(ctx context.Context, id string) (*ApplicationTemplate, error)
	Runtimes(ctx context.Context, filter []*LabelFilter, first *int, after *PageCursor) (*RuntimePage, error)
	Runtime(ctx context.Context, id string) (*Runtime, error)
	RuntimeByTokenIssuer(ctx context.Context, issuer string) (*Runtime, error)
	LabelDefinitions(ctx context.Context) ([]*LabelDefinition, error)
	LabelDefinition(ctx context.Context, key string) (*LabelDefinition, error)
	BundleByInstanceAuth(ctx context.Context, authID string) (*Bundle, error)
	BundleInstanceAuth(ctx context.Context, id string) (*BundleInstanceAuth, error)
	HealthChecks(ctx context.Context, types []HealthCheckType, origin *string, first *int, after *PageCursor) (*HealthCheckPage, error)
	IntegrationSystems(ctx context.Context, first *int, after *PageCursor) (*IntegrationSystemPage, error)
	IntegrationSystem(ctx context.Context, id string) (*IntegrationSystem, error)
	Viewer(ctx context.Context) (*Viewer, error)
	Tenants(ctx context.Context, first *int, after *PageCursor, searchTerm *string) (*TenantPage, error)
	TenantByExternalID(ctx context.Context, id string) (*Tenant, error)
	TenantByInternalID(ctx context.Context, id string) (*Tenant, error)
	TenantByLowestOwnerForResource(ctx context.Context, id string, resource string) (string, error)
	RootTenants(ctx context.Context, externalTenant string) ([]*Tenant, error)
	AutomaticScenarioAssignmentForScenario(ctx context.Context, scenarioName string) (*AutomaticScenarioAssignment, error)
	AutomaticScenarioAssignmentsForSelector(ctx context.Context, selector LabelSelectorInput) ([]*AutomaticScenarioAssignment, error)
	AutomaticScenarioAssignments(ctx context.Context, first *int, after *PageCursor) (*AutomaticScenarioAssignmentPage, error)
	SystemAuth(ctx context.Context, id string) (SystemAuth, error)
	SystemAuthByToken(ctx context.Context, token string) (SystemAuth, error)
	Formation(ctx context.Context, id string) (*Formation, error)
	FormationByName(ctx context.Context, name string) (*Formation, error)
	Formations(ctx context.Context, first *int, after *PageCursor) (*FormationPage, error)
	FormationsForObject(ctx context.Context, objectID string) ([]*Formation, error)
	FormationConstraints(ctx context.Context) ([]*FormationConstraint, error)
	FormationConstraint(ctx context.Context, id string) (*FormationConstraint, error)
	FormationConstraintsByFormationType(ctx context.Context, formationTemplateID string) ([]*FormationConstraint, error)
	FormationTemplate(ctx context.Context, id string) (*FormationTemplate, error)
	FormationTemplates(ctx context.Context, first *int, after *PageCursor) (*FormationTemplatePage, error)
	FormationTemplatesByName(ctx context.Context, name string, first *int, after *PageCursor) (*FormationTemplatePage, error)
	CertificateSubjectMapping(ctx context.Context, id string) (*CertificateSubjectMapping, error)
	CertificateSubjectMappings(ctx context.Context, first *int, after *PageCursor) (*CertificateSubjectMappingPage, error)
}
type RuntimeResolver interface {
	Labels(ctx context.Context, obj *Runtime, key *string) (Labels, error)
	Webhooks(ctx context.Context, obj *Runtime) ([]*Webhook, error)

	Auths(ctx context.Context, obj *Runtime) ([]*RuntimeSystemAuth, error)
	EventingConfiguration(ctx context.Context, obj *Runtime) (*RuntimeEventingConfiguration, error)
	RuntimeContext(ctx context.Context, obj *Runtime, id string) (*RuntimeContext, error)
	RuntimeContexts(ctx context.Context, obj *Runtime, first *int, after *PageCursor) (*RuntimeContextPage, error)
}
type RuntimeContextResolver interface {
	Labels(ctx context.Context, obj *RuntimeContext, key *string) (Labels, error)
}
type TenantResolver interface {
	Labels(ctx context.Context, obj *Tenant, key *string) (Labels, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "APIDefinition.created_at":
		if e.complexity.APIDefinition.CreatedAt == nil {
			break
		}

		return e.complexity.APIDefinition.CreatedAt(childComplexity), true

	case "APIDefinition.deleted_at":
		if e.complexity.APIDefinition.DeletedAt == nil {
			break
		}

		return e.complexity.APIDefinition.DeletedAt(childComplexity), true

	case "APIDefinition.description":
		if e.complexity.APIDefinition.Description == nil {
			break
		}

		return e.complexity.APIDefinition.Description(childComplexity), true

	case "APIDefinition.error":
		if e.complexity.APIDefinition.Error == nil {
			break
		}

		return e.complexity.APIDefinition.Error(childComplexity), true

	case "APIDefinition.group":
		if e.complexity.APIDefinition.Group == nil {
			break
		}

		return e.complexity.APIDefinition.Group(childComplexity), true

	case "APIDefinition.id":
		if e.complexity.APIDefinition.ID == nil {
			break
		}

		return e.complexity.APIDefinition.ID(childComplexity), true

	case "APIDefinition.name":
		if e.complexity.APIDefinition.Name == nil {
			break
		}

		return e.complexity.APIDefinition.Name(childComplexity), true

	case "APIDefinition.spec":
		if e.complexity.APIDefinition.Spec == nil {
			break
		}

		return e.complexity.APIDefinition.Spec(childComplexity), true

	case "APIDefinition.targetURL":
		if e.complexity.APIDefinition.TargetURL == nil {
			break
		}

		return e.complexity.APIDefinition.TargetURL(childComplexity), true

	case "APIDefinition.updated_at":
		if e.complexity.APIDefinition.UpdatedAt == nil {
			break
		}

		return e.complexity.APIDefinition.UpdatedAt(childComplexity), true

	case "APIDefinition.version":
		if e.complexity.APIDefinition.Version == nil {
			break
		}

		return e.complexity.APIDefinition.Version(childComplexity), true

	case "APIDefinitionPage.data":
		if e.complexity.APIDefinitionPage.Data == nil {
			break
		}

		return e.complexity.APIDefinitionPage.Data(childComplexity), true

	case "APIDefinitionPage.pageInfo":
		if e.complexity.APIDefinitionPage.PageInfo == nil {
			break
		}

		return e.complexity.APIDefinitionPage.PageInfo(childComplexity), true

	case "APIDefinitionPage.totalCount":
		if e.complexity.APIDefinitionPage.TotalCount == nil {
			break
		}

		return e.complexity.APIDefinitionPage.TotalCount(childComplexity), true

	case "APISpec.data":
		if e.complexity.APISpec.Data == nil {
			break
		}

		return e.complexity.APISpec.Data(childComplexity), true

	case "APISpec.fetchRequest":
		if e.complexity.APISpec.FetchRequest == nil {
			break
		}

		return e.complexity.APISpec.FetchRequest(childComplexity), true

	case "APISpec.format":
		if e.complexity.APISpec.Format == nil {
			break
		}

		return e.complexity.APISpec.Format(childComplexity), true

	case "APISpec.id":
		if e.complexity.APISpec.ID == nil {
			break
		}

		return e.complexity.APISpec.ID(childComplexity), true

	case "APISpec.type":
		if e.complexity.APISpec.Type == nil {
			break
		}

		return e.complexity.APISpec.Type(childComplexity), true

	case "AppSystemAuth.auth":
		if e.complexity.AppSystemAuth.Auth == nil {
			break
		}

		return e.complexity.AppSystemAuth.Auth(childComplexity), true

	case "AppSystemAuth.id":
		if e.complexity.AppSystemAuth.ID == nil {
			break
		}

		return e.complexity.AppSystemAuth.ID(childComplexity), true

	case "AppSystemAuth.referenceObjectId":
		if e.complexity.AppSystemAuth.ReferenceObjectID == nil {
			break
		}

		return e.complexity.AppSystemAuth.ReferenceObjectID(childComplexity), true

	case "AppSystemAuth.tenantId":
		if e.complexity.AppSystemAuth.TenantID == nil {
			break
		}

		return e.complexity.AppSystemAuth.TenantID(childComplexity), true

	case "AppSystemAuth.type":
		if e.complexity.AppSystemAuth.Type == nil {
			break
		}

		return e.complexity.AppSystemAuth.Type(childComplexity), true

	case "Application.apiDefinition":
		if e.complexity.Application.APIDefinition == nil {
			break
		}

		args, err := ec.field_Application_apiDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.APIDefinition(childComplexity, args["id"].(string)), true

	case "Application.applicationNamespace":
		if e.complexity.Application.ApplicationNamespace == nil {
			break
		}

		return e.complexity.Application.ApplicationNamespace(childComplexity), true

	case "Application.applicationTemplate":
		if e.complexity.Application.ApplicationTemplate == nil {
			break
		}

		return e.complexity.Application.ApplicationTemplate(childComplexity), true

	case "Application.applicationTemplateID":
		if e.complexity.Application.ApplicationTemplateID == nil {
			break
		}

		return e.complexity.Application.ApplicationTemplateID(childComplexity), true

	case "Application.auths":
		if e.complexity.Application.Auths == nil {
			break
		}

		return e.complexity.Application.Auths(childComplexity), true

	case "Application.baseUrl":
		if e.complexity.Application.BaseURL == nil {
			break
		}

		return e.complexity.Application.BaseURL(childComplexity), true

	case "Application.bundle":
		if e.complexity.Application.Bundle == nil {
			break
		}

		args, err := ec.field_Application_bundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Bundle(childComplexity, args["id"].(string)), true

	case "Application.bundles":
		if e.complexity.Application.Bundles == nil {
			break
		}

		args, err := ec.field_Application_bundles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Bundles(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Application.createdAt":
		if e.complexity.Application.CreatedAt == nil {
			break
		}

		return e.complexity.Application.CreatedAt(childComplexity), true

	case "Application.deletedAt":
		if e.complexity.Application.DeletedAt == nil {
			break
		}

		return e.complexity.Application.DeletedAt(childComplexity), true

	case "Application.description":
		if e.complexity.Application.Description == nil {
			break
		}

		return e.complexity.Application.Description(childComplexity), true

	case "Application.error":
		if e.complexity.Application.Error == nil {
			break
		}

		return e.complexity.Application.Error(childComplexity), true

	case "Application.eventDefinition":
		if e.complexity.Application.EventDefinition == nil {
			break
		}

		args, err := ec.field_Application_eventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.EventDefinition(childComplexity, args["id"].(string)), true

	case "Application.eventingConfiguration":
		if e.complexity.Application.EventingConfiguration == nil {
			break
		}

		return e.complexity.Application.EventingConfiguration(childComplexity), true

	case "Application.healthCheckURL":
		if e.complexity.Application.HealthCheckURL == nil {
			break
		}

		return e.complexity.Application.HealthCheckURL(childComplexity), true

	case "Application.id":
		if e.complexity.Application.ID == nil {
			break
		}

		return e.complexity.Application.ID(childComplexity), true

	case "Application.integrationDependencies":
		if e.complexity.Application.IntegrationDependencies == nil {
			break
		}

		args, err := ec.field_Application_integrationDependencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.IntegrationDependencies(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Application.integrationSystemID":
		if e.complexity.Application.IntegrationSystemID == nil {
			break
		}

		return e.complexity.Application.IntegrationSystemID(childComplexity), true

	case "Application.labels":
		if e.complexity.Application.Labels == nil {
			break
		}

		args, err := ec.field_Application_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Application.Labels(childComplexity, args["key"].(*string)), true

	case "Application.localTenantID":
		if e.complexity.Application.LocalTenantID == nil {
			break
		}

		return e.complexity.Application.LocalTenantID(childComplexity), true

	case "Application.name":
		if e.complexity.Application.Name == nil {
			break
		}

		return e.complexity.Application.Name(childComplexity), true

	case "Application.providerName":
		if e.complexity.Application.ProviderName == nil {
			break
		}

		return e.complexity.Application.ProviderName(childComplexity), true

	case "Application.status":
		if e.complexity.Application.Status == nil {
			break
		}

		return e.complexity.Application.Status(childComplexity), true

	case "Application.systemNumber":
		if e.complexity.Application.SystemNumber == nil {
			break
		}

		return e.complexity.Application.SystemNumber(childComplexity), true

	case "Application.systemStatus":
		if e.complexity.Application.SystemStatus == nil {
			break
		}

		return e.complexity.Application.SystemStatus(childComplexity), true

	case "Application.updatedAt":
		if e.complexity.Application.UpdatedAt == nil {
			break
		}

		return e.complexity.Application.UpdatedAt(childComplexity), true

	case "Application.webhooks":
		if e.complexity.Application.Webhooks == nil {
			break
		}

		return e.complexity.Application.Webhooks(childComplexity), true

	case "ApplicationEventingConfiguration.defaultURL":
		if e.complexity.ApplicationEventingConfiguration.DefaultURL == nil {
			break
		}

		return e.complexity.ApplicationEventingConfiguration.DefaultURL(childComplexity), true

	case "ApplicationPage.data":
		if e.complexity.ApplicationPage.Data == nil {
			break
		}

		return e.complexity.ApplicationPage.Data(childComplexity), true

	case "ApplicationPage.pageInfo":
		if e.complexity.ApplicationPage.PageInfo == nil {
			break
		}

		return e.complexity.ApplicationPage.PageInfo(childComplexity), true

	case "ApplicationPage.totalCount":
		if e.complexity.ApplicationPage.TotalCount == nil {
			break
		}

		return e.complexity.ApplicationPage.TotalCount(childComplexity), true

	case "ApplicationStatus.condition":
		if e.complexity.ApplicationStatus.Condition == nil {
			break
		}

		return e.complexity.ApplicationStatus.Condition(childComplexity), true

	case "ApplicationStatus.timestamp":
		if e.complexity.ApplicationStatus.Timestamp == nil {
			break
		}

		return e.complexity.ApplicationStatus.Timestamp(childComplexity), true

	case "ApplicationTemplate.accessLevel":
		if e.complexity.ApplicationTemplate.AccessLevel == nil {
			break
		}

		return e.complexity.ApplicationTemplate.AccessLevel(childComplexity), true

	case "ApplicationTemplate.applicationInput":
		if e.complexity.ApplicationTemplate.ApplicationInput == nil {
			break
		}

		return e.complexity.ApplicationTemplate.ApplicationInput(childComplexity), true

	case "ApplicationTemplate.applicationNamespace":
		if e.complexity.ApplicationTemplate.ApplicationNamespace == nil {
			break
		}

		return e.complexity.ApplicationTemplate.ApplicationNamespace(childComplexity), true

	case "ApplicationTemplate.createdAt":
		if e.complexity.ApplicationTemplate.CreatedAt == nil {
			break
		}

		return e.complexity.ApplicationTemplate.CreatedAt(childComplexity), true

	case "ApplicationTemplate.description":
		if e.complexity.ApplicationTemplate.Description == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Description(childComplexity), true

	case "ApplicationTemplate.id":
		if e.complexity.ApplicationTemplate.ID == nil {
			break
		}

		return e.complexity.ApplicationTemplate.ID(childComplexity), true

	case "ApplicationTemplate.labels":
		if e.complexity.ApplicationTemplate.Labels == nil {
			break
		}

		args, err := ec.field_ApplicationTemplate_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationTemplate.Labels(childComplexity, args["key"].(*string)), true

	case "ApplicationTemplate.name":
		if e.complexity.ApplicationTemplate.Name == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Name(childComplexity), true

	case "ApplicationTemplate.placeholders":
		if e.complexity.ApplicationTemplate.Placeholders == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Placeholders(childComplexity), true

	case "ApplicationTemplate.updatedAt":
		if e.complexity.ApplicationTemplate.UpdatedAt == nil {
			break
		}

		return e.complexity.ApplicationTemplate.UpdatedAt(childComplexity), true

	case "ApplicationTemplate.webhooks":
		if e.complexity.ApplicationTemplate.Webhooks == nil {
			break
		}

		return e.complexity.ApplicationTemplate.Webhooks(childComplexity), true

	case "ApplicationTemplatePage.data":
		if e.complexity.ApplicationTemplatePage.Data == nil {
			break
		}

		return e.complexity.ApplicationTemplatePage.Data(childComplexity), true

	case "ApplicationTemplatePage.pageInfo":
		if e.complexity.ApplicationTemplatePage.PageInfo == nil {
			break
		}

		return e.complexity.ApplicationTemplatePage.PageInfo(childComplexity), true

	case "ApplicationTemplatePage.totalCount":
		if e.complexity.ApplicationTemplatePage.TotalCount == nil {
			break
		}

		return e.complexity.ApplicationTemplatePage.TotalCount(childComplexity), true

	case "Aspect.apiResources":
		if e.complexity.Aspect.APIResources == nil {
			break
		}

		return e.complexity.Aspect.APIResources(childComplexity), true

	case "Aspect.created_at":
		if e.complexity.Aspect.CreatedAt == nil {
			break
		}

		return e.complexity.Aspect.CreatedAt(childComplexity), true

	case "Aspect.deleted_at":
		if e.complexity.Aspect.DeletedAt == nil {
			break
		}

		return e.complexity.Aspect.DeletedAt(childComplexity), true

	case "Aspect.description":
		if e.complexity.Aspect.Description == nil {
			break
		}

		return e.complexity.Aspect.Description(childComplexity), true

	case "Aspect.error":
		if e.complexity.Aspect.Error == nil {
			break
		}

		return e.complexity.Aspect.Error(childComplexity), true

	case "Aspect.eventResources":
		if e.complexity.Aspect.EventResources == nil {
			break
		}

		return e.complexity.Aspect.EventResources(childComplexity), true

	case "Aspect.id":
		if e.complexity.Aspect.ID == nil {
			break
		}

		return e.complexity.Aspect.ID(childComplexity), true

	case "Aspect.mandatory":
		if e.complexity.Aspect.Mandatory == nil {
			break
		}

		return e.complexity.Aspect.Mandatory(childComplexity), true

	case "Aspect.name":
		if e.complexity.Aspect.Name == nil {
			break
		}

		return e.complexity.Aspect.Name(childComplexity), true

	case "Aspect.updated_at":
		if e.complexity.Aspect.UpdatedAt == nil {
			break
		}

		return e.complexity.Aspect.UpdatedAt(childComplexity), true

	case "AspectAPIDefinition.ordID":
		if e.complexity.AspectAPIDefinition.OrdID == nil {
			break
		}

		return e.complexity.AspectAPIDefinition.OrdID(childComplexity), true

	case "AspectEventDefinition.created_at":
		if e.complexity.AspectEventDefinition.CreatedAt == nil {
			break
		}

		return e.complexity.AspectEventDefinition.CreatedAt(childComplexity), true

	case "AspectEventDefinition.deleted_at":
		if e.complexity.AspectEventDefinition.DeletedAt == nil {
			break
		}

		return e.complexity.AspectEventDefinition.DeletedAt(childComplexity), true

	case "AspectEventDefinition.error":
		if e.complexity.AspectEventDefinition.Error == nil {
			break
		}

		return e.complexity.AspectEventDefinition.Error(childComplexity), true

	case "AspectEventDefinition.ordID":
		if e.complexity.AspectEventDefinition.OrdID == nil {
			break
		}

		return e.complexity.AspectEventDefinition.OrdID(childComplexity), true

	case "AspectEventDefinition.subset":
		if e.complexity.AspectEventDefinition.Subset == nil {
			break
		}

		return e.complexity.AspectEventDefinition.Subset(childComplexity), true

	case "AspectEventDefinition.updated_at":
		if e.complexity.AspectEventDefinition.UpdatedAt == nil {
			break
		}

		return e.complexity.AspectEventDefinition.UpdatedAt(childComplexity), true

	case "AspectEventDefinitionSubset.eventType":
		if e.complexity.AspectEventDefinitionSubset.EventType == nil {
			break
		}

		return e.complexity.AspectEventDefinitionSubset.EventType(childComplexity), true

	case "Auth.accessStrategy":
		if e.complexity.Auth.AccessStrategy == nil {
			break
		}

		return e.complexity.Auth.AccessStrategy(childComplexity), true

	case "Auth.additionalHeaders":
		if e.complexity.Auth.AdditionalHeaders == nil {
			break
		}

		return e.complexity.Auth.AdditionalHeaders(childComplexity), true

	case "Auth.additionalHeadersSerialized":
		if e.complexity.Auth.AdditionalHeadersSerialized == nil {
			break
		}

		return e.complexity.Auth.AdditionalHeadersSerialized(childComplexity), true

	case "Auth.additionalQueryParams":
		if e.complexity.Auth.AdditionalQueryParams == nil {
			break
		}

		return e.complexity.Auth.AdditionalQueryParams(childComplexity), true

	case "Auth.additionalQueryParamsSerialized":
		if e.complexity.Auth.AdditionalQueryParamsSerialized == nil {
			break
		}

		return e.complexity.Auth.AdditionalQueryParamsSerialized(childComplexity), true

	case "Auth.certCommonName":
		if e.complexity.Auth.CertCommonName == nil {
			break
		}

		return e.complexity.Auth.CertCommonName(childComplexity), true

	case "Auth.credential":
		if e.complexity.Auth.Credential == nil {
			break
		}

		return e.complexity.Auth.Credential(childComplexity), true

	case "Auth.oneTimeToken":
		if e.complexity.Auth.OneTimeToken == nil {
			break
		}

		return e.complexity.Auth.OneTimeToken(childComplexity), true

	case "Auth.requestAuth":
		if e.complexity.Auth.RequestAuth == nil {
			break
		}

		return e.complexity.Auth.RequestAuth(childComplexity), true

	case "AutomaticScenarioAssignment.scenarioName":
		if e.complexity.AutomaticScenarioAssignment.ScenarioName == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignment.ScenarioName(childComplexity), true

	case "AutomaticScenarioAssignment.selector":
		if e.complexity.AutomaticScenarioAssignment.Selector == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignment.Selector(childComplexity), true

	case "AutomaticScenarioAssignmentPage.data":
		if e.complexity.AutomaticScenarioAssignmentPage.Data == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignmentPage.Data(childComplexity), true

	case "AutomaticScenarioAssignmentPage.pageInfo":
		if e.complexity.AutomaticScenarioAssignmentPage.PageInfo == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignmentPage.PageInfo(childComplexity), true

	case "AutomaticScenarioAssignmentPage.totalCount":
		if e.complexity.AutomaticScenarioAssignmentPage.TotalCount == nil {
			break
		}

		return e.complexity.AutomaticScenarioAssignmentPage.TotalCount(childComplexity), true

	case "BasicCredentialData.password":
		if e.complexity.BasicCredentialData.Password == nil {
			break
		}

		return e.complexity.BasicCredentialData.Password(childComplexity), true

	case "BasicCredentialData.username":
		if e.complexity.BasicCredentialData.Username == nil {
			break
		}

		return e.complexity.BasicCredentialData.Username(childComplexity), true

	case "Bundle.apiDefinition":
		if e.complexity.Bundle.APIDefinition == nil {
			break
		}

		args, err := ec.field_Bundle_apiDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.APIDefinition(childComplexity, args["id"].(string)), true

	case "Bundle.apiDefinitions":
		if e.complexity.Bundle.APIDefinitions == nil {
			break
		}

		args, err := ec.field_Bundle_apiDefinitions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.APIDefinitions(childComplexity, args["group"].(*string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Bundle.correlationIDs":
		if e.complexity.Bundle.CorrelationIDs == nil {
			break
		}

		return e.complexity.Bundle.CorrelationIDs(childComplexity), true

	case "Bundle.createdAt":
		if e.complexity.Bundle.CreatedAt == nil {
			break
		}

		return e.complexity.Bundle.CreatedAt(childComplexity), true

	case "Bundle.defaultInstanceAuth":
		if e.complexity.Bundle.DefaultInstanceAuth == nil {
			break
		}

		return e.complexity.Bundle.DefaultInstanceAuth(childComplexity), true

	case "Bundle.deletedAt":
		if e.complexity.Bundle.DeletedAt == nil {
			break
		}

		return e.complexity.Bundle.DeletedAt(childComplexity), true

	case "Bundle.description":
		if e.complexity.Bundle.Description == nil {
			break
		}

		return e.complexity.Bundle.Description(childComplexity), true

	case "Bundle.document":
		if e.complexity.Bundle.Document == nil {
			break
		}

		args, err := ec.field_Bundle_document_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.Document(childComplexity, args["id"].(string)), true

	case "Bundle.documents":
		if e.complexity.Bundle.Documents == nil {
			break
		}

		args, err := ec.field_Bundle_documents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.Documents(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Bundle.error":
		if e.complexity.Bundle.Error == nil {
			break
		}

		return e.complexity.Bundle.Error(childComplexity), true

	case "Bundle.eventDefinition":
		if e.complexity.Bundle.EventDefinition == nil {
			break
		}

		args, err := ec.field_Bundle_eventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.EventDefinition(childComplexity, args["id"].(string)), true

	case "Bundle.eventDefinitions":
		if e.complexity.Bundle.EventDefinitions == nil {
			break
		}

		args, err := ec.field_Bundle_eventDefinitions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.EventDefinitions(childComplexity, args["group"].(*string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Bundle.id":
		if e.complexity.Bundle.ID == nil {
			break
		}

		return e.complexity.Bundle.ID(childComplexity), true

	case "Bundle.instanceAuth":
		if e.complexity.Bundle.InstanceAuth == nil {
			break
		}

		args, err := ec.field_Bundle_instanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Bundle.InstanceAuth(childComplexity, args["id"].(string)), true

	case "Bundle.instanceAuthRequestInputSchema":
		if e.complexity.Bundle.InstanceAuthRequestInputSchema == nil {
			break
		}

		return e.complexity.Bundle.InstanceAuthRequestInputSchema(childComplexity), true

	case "Bundle.instanceAuths":
		if e.complexity.Bundle.InstanceAuths == nil {
			break
		}

		return e.complexity.Bundle.InstanceAuths(childComplexity), true

	case "Bundle.name":
		if e.complexity.Bundle.Name == nil {
			break
		}

		return e.complexity.Bundle.Name(childComplexity), true

	case "Bundle.updatedAt":
		if e.complexity.Bundle.UpdatedAt == nil {
			break
		}

		return e.complexity.Bundle.UpdatedAt(childComplexity), true

	case "BundleInstanceAuth.auth":
		if e.complexity.BundleInstanceAuth.Auth == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.Auth(childComplexity), true

	case "BundleInstanceAuth.context":
		if e.complexity.BundleInstanceAuth.Context == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.Context(childComplexity), true

	case "BundleInstanceAuth.id":
		if e.complexity.BundleInstanceAuth.ID == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.ID(childComplexity), true

	case "BundleInstanceAuth.inputParams":
		if e.complexity.BundleInstanceAuth.InputParams == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.InputParams(childComplexity), true

	case "BundleInstanceAuth.runtimeContextID":
		if e.complexity.BundleInstanceAuth.RuntimeContextID == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.RuntimeContextID(childComplexity), true

	case "BundleInstanceAuth.runtimeID":
		if e.complexity.BundleInstanceAuth.RuntimeID == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.RuntimeID(childComplexity), true

	case "BundleInstanceAuth.status":
		if e.complexity.BundleInstanceAuth.Status == nil {
			break
		}

		return e.complexity.BundleInstanceAuth.Status(childComplexity), true

	case "BundleInstanceAuthStatus.condition":
		if e.complexity.BundleInstanceAuthStatus.Condition == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Condition(childComplexity), true

	case "BundleInstanceAuthStatus.message":
		if e.complexity.BundleInstanceAuthStatus.Message == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Message(childComplexity), true

	case "BundleInstanceAuthStatus.reason":
		if e.complexity.BundleInstanceAuthStatus.Reason == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Reason(childComplexity), true

	case "BundleInstanceAuthStatus.timestamp":
		if e.complexity.BundleInstanceAuthStatus.Timestamp == nil {
			break
		}

		return e.complexity.BundleInstanceAuthStatus.Timestamp(childComplexity), true

	case "BundlePage.data":
		if e.complexity.BundlePage.Data == nil {
			break
		}

		return e.complexity.BundlePage.Data(childComplexity), true

	case "BundlePage.pageInfo":
		if e.complexity.BundlePage.PageInfo == nil {
			break
		}

		return e.complexity.BundlePage.PageInfo(childComplexity), true

	case "BundlePage.totalCount":
		if e.complexity.BundlePage.TotalCount == nil {
			break
		}

		return e.complexity.BundlePage.TotalCount(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalHeaders":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeaders == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeaders(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalHeadersSerialized":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeadersSerialized == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalHeadersSerialized(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalQueryParams":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParams == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParams(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.additionalQueryParamsSerialized":
		if e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParamsSerialized == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.AdditionalQueryParamsSerialized(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.credential":
		if e.complexity.CSRFTokenCredentialRequestAuth.Credential == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.Credential(childComplexity), true

	case "CSRFTokenCredentialRequestAuth.tokenEndpointURL":
		if e.complexity.CSRFTokenCredentialRequestAuth.TokenEndpointURL == nil {
			break
		}

		return e.complexity.CSRFTokenCredentialRequestAuth.TokenEndpointURL(childComplexity), true

	case "CertificateOAuthCredentialData.certificate":
		if e.complexity.CertificateOAuthCredentialData.Certificate == nil {
			break
		}

		return e.complexity.CertificateOAuthCredentialData.Certificate(childComplexity), true

	case "CertificateOAuthCredentialData.clientId":
		if e.complexity.CertificateOAuthCredentialData.ClientID == nil {
			break
		}

		return e.complexity.CertificateOAuthCredentialData.ClientID(childComplexity), true

	case "CertificateOAuthCredentialData.url":
		if e.complexity.CertificateOAuthCredentialData.URL == nil {
			break
		}

		return e.complexity.CertificateOAuthCredentialData.URL(childComplexity), true

	case "CertificateSubjectMapping.consumerType":
		if e.complexity.CertificateSubjectMapping.ConsumerType == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.ConsumerType(childComplexity), true

	case "CertificateSubjectMapping.id":
		if e.complexity.CertificateSubjectMapping.ID == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.ID(childComplexity), true

	case "CertificateSubjectMapping.internalConsumerID":
		if e.complexity.CertificateSubjectMapping.InternalConsumerID == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.InternalConsumerID(childComplexity), true

	case "CertificateSubjectMapping.subject":
		if e.complexity.CertificateSubjectMapping.Subject == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.Subject(childComplexity), true

	case "CertificateSubjectMapping.tenantAccessLevels":
		if e.complexity.CertificateSubjectMapping.TenantAccessLevels == nil {
			break
		}

		return e.complexity.CertificateSubjectMapping.TenantAccessLevels(childComplexity), true

	case "CertificateSubjectMappingPage.data":
		if e.complexity.CertificateSubjectMappingPage.Data == nil {
			break
		}

		return e.complexity.CertificateSubjectMappingPage.Data(childComplexity), true

	case "CertificateSubjectMappingPage.pageInfo":
		if e.complexity.CertificateSubjectMappingPage.PageInfo == nil {
			break
		}

		return e.complexity.CertificateSubjectMappingPage.PageInfo(childComplexity), true

	case "CertificateSubjectMappingPage.totalCount":
		if e.complexity.CertificateSubjectMappingPage.TotalCount == nil {
			break
		}

		return e.complexity.CertificateSubjectMappingPage.TotalCount(childComplexity), true

	case "ConstraintReference.constraintID":
		if e.complexity.ConstraintReference.ConstraintID == nil {
			break
		}

		return e.complexity.ConstraintReference.ConstraintID(childComplexity), true

	case "ConstraintReference.formationTemplateID":
		if e.complexity.ConstraintReference.FormationTemplateID == nil {
			break
		}

		return e.complexity.ConstraintReference.FormationTemplateID(childComplexity), true

	case "CredentialRequestAuth.csrf":
		if e.complexity.CredentialRequestAuth.Csrf == nil {
			break
		}

		return e.complexity.CredentialRequestAuth.Csrf(childComplexity), true

	case "Document.createdAt":
		if e.complexity.Document.CreatedAt == nil {
			break
		}

		return e.complexity.Document.CreatedAt(childComplexity), true

	case "Document.data":
		if e.complexity.Document.Data == nil {
			break
		}

		return e.complexity.Document.Data(childComplexity), true

	case "Document.deletedAt":
		if e.complexity.Document.DeletedAt == nil {
			break
		}

		return e.complexity.Document.DeletedAt(childComplexity), true

	case "Document.description":
		if e.complexity.Document.Description == nil {
			break
		}

		return e.complexity.Document.Description(childComplexity), true

	case "Document.displayName":
		if e.complexity.Document.DisplayName == nil {
			break
		}

		return e.complexity.Document.DisplayName(childComplexity), true

	case "Document.error":
		if e.complexity.Document.Error == nil {
			break
		}

		return e.complexity.Document.Error(childComplexity), true

	case "Document.fetchRequest":
		if e.complexity.Document.FetchRequest == nil {
			break
		}

		return e.complexity.Document.FetchRequest(childComplexity), true

	case "Document.format":
		if e.complexity.Document.Format == nil {
			break
		}

		return e.complexity.Document.Format(childComplexity), true

	case "Document.id":
		if e.complexity.Document.ID == nil {
			break
		}

		return e.complexity.Document.ID(childComplexity), true

	case "Document.kind":
		if e.complexity.Document.Kind == nil {
			break
		}

		return e.complexity.Document.Kind(childComplexity), true

	case "Document.title":
		if e.complexity.Document.Title == nil {
			break
		}

		return e.complexity.Document.Title(childComplexity), true

	case "Document.updatedAt":
		if e.complexity.Document.UpdatedAt == nil {
			break
		}

		return e.complexity.Document.UpdatedAt(childComplexity), true

	case "DocumentPage.data":
		if e.complexity.DocumentPage.Data == nil {
			break
		}

		return e.complexity.DocumentPage.Data(childComplexity), true

	case "DocumentPage.pageInfo":
		if e.complexity.DocumentPage.PageInfo == nil {
			break
		}

		return e.complexity.DocumentPage.PageInfo(childComplexity), true

	case "DocumentPage.totalCount":
		if e.complexity.DocumentPage.TotalCount == nil {
			break
		}

		return e.complexity.DocumentPage.TotalCount(childComplexity), true

	case "EventDefinition.createdAt":
		if e.complexity.EventDefinition.CreatedAt == nil {
			break
		}

		return e.complexity.EventDefinition.CreatedAt(childComplexity), true

	case "EventDefinition.deletedAt":
		if e.complexity.EventDefinition.DeletedAt == nil {
			break
		}

		return e.complexity.EventDefinition.DeletedAt(childComplexity), true

	case "EventDefinition.description":
		if e.complexity.EventDefinition.Description == nil {
			break
		}

		return e.complexity.EventDefinition.Description(childComplexity), true

	case "EventDefinition.error":
		if e.complexity.EventDefinition.Error == nil {
			break
		}

		return e.complexity.EventDefinition.Error(childComplexity), true

	case "EventDefinition.group":
		if e.complexity.EventDefinition.Group == nil {
			break
		}

		return e.complexity.EventDefinition.Group(childComplexity), true

	case "EventDefinition.id":
		if e.complexity.EventDefinition.ID == nil {
			break
		}

		return e.complexity.EventDefinition.ID(childComplexity), true

	case "EventDefinition.name":
		if e.complexity.EventDefinition.Name == nil {
			break
		}

		return e.complexity.EventDefinition.Name(childComplexity), true

	case "EventDefinition.spec":
		if e.complexity.EventDefinition.Spec == nil {
			break
		}

		return e.complexity.EventDefinition.Spec(childComplexity), true

	case "EventDefinition.updatedAt":
		if e.complexity.EventDefinition.UpdatedAt == nil {
			break
		}

		return e.complexity.EventDefinition.UpdatedAt(childComplexity), true

	case "EventDefinition.version":
		if e.complexity.EventDefinition.Version == nil {
			break
		}

		return e.complexity.EventDefinition.Version(childComplexity), true

	case "EventDefinitionPage.data":
		if e.complexity.EventDefinitionPage.Data == nil {
			break
		}

		return e.complexity.EventDefinitionPage.Data(childComplexity), true

	case "EventDefinitionPage.pageInfo":
		if e.complexity.EventDefinitionPage.PageInfo == nil {
			break
		}

		return e.complexity.EventDefinitionPage.PageInfo(childComplexity), true

	case "EventDefinitionPage.totalCount":
		if e.complexity.EventDefinitionPage.TotalCount == nil {
			break
		}

		return e.complexity.EventDefinitionPage.TotalCount(childComplexity), true

	case "EventSpec.data":
		if e.complexity.EventSpec.Data == nil {
			break
		}

		return e.complexity.EventSpec.Data(childComplexity), true

	case "EventSpec.fetchRequest":
		if e.complexity.EventSpec.FetchRequest == nil {
			break
		}

		return e.complexity.EventSpec.FetchRequest(childComplexity), true

	case "EventSpec.format":
		if e.complexity.EventSpec.Format == nil {
			break
		}

		return e.complexity.EventSpec.Format(childComplexity), true

	case "EventSpec.id":
		if e.complexity.EventSpec.ID == nil {
			break
		}

		return e.complexity.EventSpec.ID(childComplexity), true

	case "EventSpec.type":
		if e.complexity.EventSpec.Type == nil {
			break
		}

		return e.complexity.EventSpec.Type(childComplexity), true

	case "FetchRequest.auth":
		if e.complexity.FetchRequest.Auth == nil {
			break
		}

		return e.complexity.FetchRequest.Auth(childComplexity), true

	case "FetchRequest.filter":
		if e.complexity.FetchRequest.Filter == nil {
			break
		}

		return e.complexity.FetchRequest.Filter(childComplexity), true

	case "FetchRequest.mode":
		if e.complexity.FetchRequest.Mode == nil {
			break
		}

		return e.complexity.FetchRequest.Mode(childComplexity), true

	case "FetchRequest.status":
		if e.complexity.FetchRequest.Status == nil {
			break
		}

		return e.complexity.FetchRequest.Status(childComplexity), true

	case "FetchRequest.url":
		if e.complexity.FetchRequest.URL == nil {
			break
		}

		return e.complexity.FetchRequest.URL(childComplexity), true

	case "FetchRequestStatus.condition":
		if e.complexity.FetchRequestStatus.Condition == nil {
			break
		}

		return e.complexity.FetchRequestStatus.Condition(childComplexity), true

	case "FetchRequestStatus.message":
		if e.complexity.FetchRequestStatus.Message == nil {
			break
		}

		return e.complexity.FetchRequestStatus.Message(childComplexity), true

	case "FetchRequestStatus.timestamp":
		if e.complexity.FetchRequestStatus.Timestamp == nil {
			break
		}

		return e.complexity.FetchRequestStatus.Timestamp(childComplexity), true

	case "Formation.error":
		if e.complexity.Formation.Error == nil {
			break
		}

		return e.complexity.Formation.Error(childComplexity), true

	case "Formation.formationAssignment":
		if e.complexity.Formation.FormationAssignment == nil {
			break
		}

		args, err := ec.field_Formation_formationAssignment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Formation.FormationAssignment(childComplexity, args["id"].(string)), true

	case "Formation.formationAssignments":
		if e.complexity.Formation.FormationAssignments == nil {
			break
		}

		args, err := ec.field_Formation_formationAssignments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Formation.FormationAssignments(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Formation.formationTemplateId":
		if e.complexity.Formation.FormationTemplateID == nil {
			break
		}

		return e.complexity.Formation.FormationTemplateID(childComplexity), true

	case "Formation.id":
		if e.complexity.Formation.ID == nil {
			break
		}

		return e.complexity.Formation.ID(childComplexity), true

	case "Formation.lastNotificationSentTimestamp":
		if e.complexity.Formation.LastNotificationSentTimestamp == nil {
			break
		}

		return e.complexity.Formation.LastNotificationSentTimestamp(childComplexity), true

	case "Formation.lastStateChangeTimestamp":
		if e.complexity.Formation.LastStateChangeTimestamp == nil {
			break
		}

		return e.complexity.Formation.LastStateChangeTimestamp(childComplexity), true

	case "Formation.name":
		if e.complexity.Formation.Name == nil {
			break
		}

		return e.complexity.Formation.Name(childComplexity), true

	case "Formation.state":
		if e.complexity.Formation.State == nil {
			break
		}

		return e.complexity.Formation.State(childComplexity), true

	case "Formation.status":
		if e.complexity.Formation.Status == nil {
			break
		}

		return e.complexity.Formation.Status(childComplexity), true

	case "Formation.tenantID":
		if e.complexity.Formation.TenantID == nil {
			break
		}

		return e.complexity.Formation.TenantID(childComplexity), true

	case "FormationAssignment.configuration":
		if e.complexity.FormationAssignment.Configuration == nil {
			break
		}

		return e.complexity.FormationAssignment.Configuration(childComplexity), true

	case "FormationAssignment.error":
		if e.complexity.FormationAssignment.Error == nil {
			break
		}

		return e.complexity.FormationAssignment.Error(childComplexity), true

	case "FormationAssignment.id":
		if e.complexity.FormationAssignment.ID == nil {
			break
		}

		return e.complexity.FormationAssignment.ID(childComplexity), true

	case "FormationAssignment.lastNotificationSentTimestamp":
		if e.complexity.FormationAssignment.LastNotificationSentTimestamp == nil {
			break
		}

		return e.complexity.FormationAssignment.LastNotificationSentTimestamp(childComplexity), true

	case "FormationAssignment.lastStateChangeTimestamp":
		if e.complexity.FormationAssignment.LastStateChangeTimestamp == nil {
			break
		}

		return e.complexity.FormationAssignment.LastStateChangeTimestamp(childComplexity), true

	case "FormationAssignment.source":
		if e.complexity.FormationAssignment.Source == nil {
			break
		}

		return e.complexity.FormationAssignment.Source(childComplexity), true

	case "FormationAssignment.sourceEntity":
		if e.complexity.FormationAssignment.SourceEntity == nil {
			break
		}

		return e.complexity.FormationAssignment.SourceEntity(childComplexity), true

	case "FormationAssignment.sourceType":
		if e.complexity.FormationAssignment.SourceType == nil {
			break
		}

		return e.complexity.FormationAssignment.SourceType(childComplexity), true

	case "FormationAssignment.state":
		if e.complexity.FormationAssignment.State == nil {
			break
		}

		return e.complexity.FormationAssignment.State(childComplexity), true

	case "FormationAssignment.target":
		if e.complexity.FormationAssignment.Target == nil {
			break
		}

		return e.complexity.FormationAssignment.Target(childComplexity), true

	case "FormationAssignment.targetEntity":
		if e.complexity.FormationAssignment.TargetEntity == nil {
			break
		}

		return e.complexity.FormationAssignment.TargetEntity(childComplexity), true

	case "FormationAssignment.targetType":
		if e.complexity.FormationAssignment.TargetType == nil {
			break
		}

		return e.complexity.FormationAssignment.TargetType(childComplexity), true

	case "FormationAssignment.value":
		if e.complexity.FormationAssignment.Value == nil {
			break
		}

		return e.complexity.FormationAssignment.Value(childComplexity), true

	case "FormationAssignmentPage.data":
		if e.complexity.FormationAssignmentPage.Data == nil {
			break
		}

		return e.complexity.FormationAssignmentPage.Data(childComplexity), true

	case "FormationAssignmentPage.pageInfo":
		if e.complexity.FormationAssignmentPage.PageInfo == nil {
			break
		}

		return e.complexity.FormationAssignmentPage.PageInfo(childComplexity), true

	case "FormationAssignmentPage.totalCount":
		if e.complexity.FormationAssignmentPage.TotalCount == nil {
			break
		}

		return e.complexity.FormationAssignmentPage.TotalCount(childComplexity), true

	case "FormationConstraint.constraintScope":
		if e.complexity.FormationConstraint.ConstraintScope == nil {
			break
		}

		return e.complexity.FormationConstraint.ConstraintScope(childComplexity), true

	case "FormationConstraint.constraintType":
		if e.complexity.FormationConstraint.ConstraintType == nil {
			break
		}

		return e.complexity.FormationConstraint.ConstraintType(childComplexity), true

	case "FormationConstraint.createdAt":
		if e.complexity.FormationConstraint.CreatedAt == nil {
			break
		}

		return e.complexity.FormationConstraint.CreatedAt(childComplexity), true

	case "FormationConstraint.description":
		if e.complexity.FormationConstraint.Description == nil {
			break
		}

		return e.complexity.FormationConstraint.Description(childComplexity), true

	case "FormationConstraint.id":
		if e.complexity.FormationConstraint.ID == nil {
			break
		}

		return e.complexity.FormationConstraint.ID(childComplexity), true

	case "FormationConstraint.inputTemplate":
		if e.complexity.FormationConstraint.InputTemplate == nil {
			break
		}

		return e.complexity.FormationConstraint.InputTemplate(childComplexity), true

	case "FormationConstraint.name":
		if e.complexity.FormationConstraint.Name == nil {
			break
		}

		return e.complexity.FormationConstraint.Name(childComplexity), true

	case "FormationConstraint.operator":
		if e.complexity.FormationConstraint.Operator == nil {
			break
		}

		return e.complexity.FormationConstraint.Operator(childComplexity), true

	case "FormationConstraint.priority":
		if e.complexity.FormationConstraint.Priority == nil {
			break
		}

		return e.complexity.FormationConstraint.Priority(childComplexity), true

	case "FormationConstraint.resourceSubtype":
		if e.complexity.FormationConstraint.ResourceSubtype == nil {
			break
		}

		return e.complexity.FormationConstraint.ResourceSubtype(childComplexity), true

	case "FormationConstraint.resourceType":
		if e.complexity.FormationConstraint.ResourceType == nil {
			break
		}

		return e.complexity.FormationConstraint.ResourceType(childComplexity), true

	case "FormationConstraint.targetOperation":
		if e.complexity.FormationConstraint.TargetOperation == nil {
			break
		}

		return e.complexity.FormationConstraint.TargetOperation(childComplexity), true

	case "FormationError.errorCode":
		if e.complexity.FormationError.ErrorCode == nil {
			break
		}

		return e.complexity.FormationError.ErrorCode(childComplexity), true

	case "FormationError.message":
		if e.complexity.FormationError.Message == nil {
			break
		}

		return e.complexity.FormationError.Message(childComplexity), true

	case "FormationPage.data":
		if e.complexity.FormationPage.Data == nil {
			break
		}

		return e.complexity.FormationPage.Data(childComplexity), true

	case "FormationPage.pageInfo":
		if e.complexity.FormationPage.PageInfo == nil {
			break
		}

		return e.complexity.FormationPage.PageInfo(childComplexity), true

	case "FormationPage.totalCount":
		if e.complexity.FormationPage.TotalCount == nil {
			break
		}

		return e.complexity.FormationPage.TotalCount(childComplexity), true

	case "FormationStatus.condition":
		if e.complexity.FormationStatus.Condition == nil {
			break
		}

		return e.complexity.FormationStatus.Condition(childComplexity), true

	case "FormationStatus.errors":
		if e.complexity.FormationStatus.Errors == nil {
			break
		}

		return e.complexity.FormationStatus.Errors(childComplexity), true

	case "FormationStatusError.assignmentID":
		if e.complexity.FormationStatusError.AssignmentID == nil {
			break
		}

		return e.complexity.FormationStatusError.AssignmentID(childComplexity), true

	case "FormationStatusError.errorCode":
		if e.complexity.FormationStatusError.ErrorCode == nil {
			break
		}

		return e.complexity.FormationStatusError.ErrorCode(childComplexity), true

	case "FormationStatusError.message":
		if e.complexity.FormationStatusError.Message == nil {
			break
		}

		return e.complexity.FormationStatusError.Message(childComplexity), true

	case "FormationTemplate.applicationTypes":
		if e.complexity.FormationTemplate.ApplicationTypes == nil {
			break
		}

		return e.complexity.FormationTemplate.ApplicationTypes(childComplexity), true

	case "FormationTemplate.discoveryConsumers":
		if e.complexity.FormationTemplate.DiscoveryConsumers == nil {
			break
		}

		return e.complexity.FormationTemplate.DiscoveryConsumers(childComplexity), true

	case "FormationTemplate.formationConstraints":
		if e.complexity.FormationTemplate.FormationConstraints == nil {
			break
		}

		return e.complexity.FormationTemplate.FormationConstraints(childComplexity), true

	case "FormationTemplate.id":
		if e.complexity.FormationTemplate.ID == nil {
			break
		}

		return e.complexity.FormationTemplate.ID(childComplexity), true

	case "FormationTemplate.leadingProductIDs":
		if e.complexity.FormationTemplate.LeadingProductIDs == nil {
			break
		}

		return e.complexity.FormationTemplate.LeadingProductIDs(childComplexity), true

	case "FormationTemplate.name":
		if e.complexity.FormationTemplate.Name == nil {
			break
		}

		return e.complexity.FormationTemplate.Name(childComplexity), true

	case "FormationTemplate.runtimeArtifactKind":
		if e.complexity.FormationTemplate.RuntimeArtifactKind == nil {
			break
		}

		return e.complexity.FormationTemplate.RuntimeArtifactKind(childComplexity), true

	case "FormationTemplate.runtimeTypeDisplayName":
		if e.complexity.FormationTemplate.RuntimeTypeDisplayName == nil {
			break
		}

		return e.complexity.FormationTemplate.RuntimeTypeDisplayName(childComplexity), true

	case "FormationTemplate.runtimeTypes":
		if e.complexity.FormationTemplate.RuntimeTypes == nil {
			break
		}

		return e.complexity.FormationTemplate.RuntimeTypes(childComplexity), true

	case "FormationTemplate.supportsReset":
		if e.complexity.FormationTemplate.SupportsReset == nil {
			break
		}

		return e.complexity.FormationTemplate.SupportsReset(childComplexity), true

	case "FormationTemplate.webhooks":
		if e.complexity.FormationTemplate.Webhooks == nil {
			break
		}

		return e.complexity.FormationTemplate.Webhooks(childComplexity), true

	case "FormationTemplatePage.data":
		if e.complexity.FormationTemplatePage.Data == nil {
			break
		}

		return e.complexity.FormationTemplatePage.Data(childComplexity), true

	case "FormationTemplatePage.pageInfo":
		if e.complexity.FormationTemplatePage.PageInfo == nil {
			break
		}

		return e.complexity.FormationTemplatePage.PageInfo(childComplexity), true

	case "FormationTemplatePage.totalCount":
		if e.complexity.FormationTemplatePage.TotalCount == nil {
			break
		}

		return e.complexity.FormationTemplatePage.TotalCount(childComplexity), true

	case "HealthCheck.condition":
		if e.complexity.HealthCheck.Condition == nil {
			break
		}

		return e.complexity.HealthCheck.Condition(childComplexity), true

	case "HealthCheck.message":
		if e.complexity.HealthCheck.Message == nil {
			break
		}

		return e.complexity.HealthCheck.Message(childComplexity), true

	case "HealthCheck.origin":
		if e.complexity.HealthCheck.Origin == nil {
			break
		}

		return e.complexity.HealthCheck.Origin(childComplexity), true

	case "HealthCheck.timestamp":
		if e.complexity.HealthCheck.Timestamp == nil {
			break
		}

		return e.complexity.HealthCheck.Timestamp(childComplexity), true

	case "HealthCheck.type":
		if e.complexity.HealthCheck.Type == nil {
			break
		}

		return e.complexity.HealthCheck.Type(childComplexity), true

	case "HealthCheckPage.data":
		if e.complexity.HealthCheckPage.Data == nil {
			break
		}

		return e.complexity.HealthCheckPage.Data(childComplexity), true

	case "HealthCheckPage.pageInfo":
		if e.complexity.HealthCheckPage.PageInfo == nil {
			break
		}

		return e.complexity.HealthCheckPage.PageInfo(childComplexity), true

	case "HealthCheckPage.totalCount":
		if e.complexity.HealthCheckPage.TotalCount == nil {
			break
		}

		return e.complexity.HealthCheckPage.TotalCount(childComplexity), true

	case "IntSysSystemAuth.auth":
		if e.complexity.IntSysSystemAuth.Auth == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.Auth(childComplexity), true

	case "IntSysSystemAuth.id":
		if e.complexity.IntSysSystemAuth.ID == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.ID(childComplexity), true

	case "IntSysSystemAuth.referenceObjectId":
		if e.complexity.IntSysSystemAuth.ReferenceObjectID == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.ReferenceObjectID(childComplexity), true

	case "IntSysSystemAuth.tenantId":
		if e.complexity.IntSysSystemAuth.TenantID == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.TenantID(childComplexity), true

	case "IntSysSystemAuth.type":
		if e.complexity.IntSysSystemAuth.Type == nil {
			break
		}

		return e.complexity.IntSysSystemAuth.Type(childComplexity), true

	case "IntegrationDependency.aspects":
		if e.complexity.IntegrationDependency.Aspects == nil {
			break
		}

		return e.complexity.IntegrationDependency.Aspects(childComplexity), true

	case "IntegrationDependency.created_at":
		if e.complexity.IntegrationDependency.CreatedAt == nil {
			break
		}

		return e.complexity.IntegrationDependency.CreatedAt(childComplexity), true

	case "IntegrationDependency.deleted_at":
		if e.complexity.IntegrationDependency.DeletedAt == nil {
			break
		}

		return e.complexity.IntegrationDependency.DeletedAt(childComplexity), true

	case "IntegrationDependency.description":
		if e.complexity.IntegrationDependency.Description == nil {
			break
		}

		return e.complexity.IntegrationDependency.Description(childComplexity), true

	case "IntegrationDependency.error":
		if e.complexity.IntegrationDependency.Error == nil {
			break
		}

		return e.complexity.IntegrationDependency.Error(childComplexity), true

	case "IntegrationDependency.id":
		if e.complexity.IntegrationDependency.ID == nil {
			break
		}

		return e.complexity.IntegrationDependency.ID(childComplexity), true

	case "IntegrationDependency.labels":
		if e.complexity.IntegrationDependency.Labels == nil {
			break
		}

		return e.complexity.IntegrationDependency.Labels(childComplexity), true

	case "IntegrationDependency.mandatory":
		if e.complexity.IntegrationDependency.Mandatory == nil {
			break
		}

		return e.complexity.IntegrationDependency.Mandatory(childComplexity), true

	case "IntegrationDependency.name":
		if e.complexity.IntegrationDependency.Name == nil {
			break
		}

		return e.complexity.IntegrationDependency.Name(childComplexity), true

	case "IntegrationDependency.ordID":
		if e.complexity.IntegrationDependency.OrdID == nil {
			break
		}

		return e.complexity.IntegrationDependency.OrdID(childComplexity), true

	case "IntegrationDependency.partOfPackage":
		if e.complexity.IntegrationDependency.PartOfPackage == nil {
			break
		}

		return e.complexity.IntegrationDependency.PartOfPackage(childComplexity), true

	case "IntegrationDependency.releaseStatus":
		if e.complexity.IntegrationDependency.ReleaseStatus == nil {
			break
		}

		return e.complexity.IntegrationDependency.ReleaseStatus(childComplexity), true

	case "IntegrationDependency.updated_at":
		if e.complexity.IntegrationDependency.UpdatedAt == nil {
			break
		}

		return e.complexity.IntegrationDependency.UpdatedAt(childComplexity), true

	case "IntegrationDependency.version":
		if e.complexity.IntegrationDependency.Version == nil {
			break
		}

		return e.complexity.IntegrationDependency.Version(childComplexity), true

	case "IntegrationDependency.visibility":
		if e.complexity.IntegrationDependency.Visibility == nil {
			break
		}

		return e.complexity.IntegrationDependency.Visibility(childComplexity), true

	case "IntegrationDependencyPage.data":
		if e.complexity.IntegrationDependencyPage.Data == nil {
			break
		}

		return e.complexity.IntegrationDependencyPage.Data(childComplexity), true

	case "IntegrationDependencyPage.pageInfo":
		if e.complexity.IntegrationDependencyPage.PageInfo == nil {
			break
		}

		return e.complexity.IntegrationDependencyPage.PageInfo(childComplexity), true

	case "IntegrationDependencyPage.totalCount":
		if e.complexity.IntegrationDependencyPage.TotalCount == nil {
			break
		}

		return e.complexity.IntegrationDependencyPage.TotalCount(childComplexity), true

	case "IntegrationSystem.auths":
		if e.complexity.IntegrationSystem.Auths == nil {
			break
		}

		return e.complexity.IntegrationSystem.Auths(childComplexity), true

	case "IntegrationSystem.description":
		if e.complexity.IntegrationSystem.Description == nil {
			break
		}

		return e.complexity.IntegrationSystem.Description(childComplexity), true

	case "IntegrationSystem.id":
		if e.complexity.IntegrationSystem.ID == nil {
			break
		}

		return e.complexity.IntegrationSystem.ID(childComplexity), true

	case "IntegrationSystem.name":
		if e.complexity.IntegrationSystem.Name == nil {
			break
		}

		return e.complexity.IntegrationSystem.Name(childComplexity), true

	case "IntegrationSystemPage.data":
		if e.complexity.IntegrationSystemPage.Data == nil {
			break
		}

		return e.complexity.IntegrationSystemPage.Data(childComplexity), true

	case "IntegrationSystemPage.pageInfo":
		if e.complexity.IntegrationSystemPage.PageInfo == nil {
			break
		}

		return e.complexity.IntegrationSystemPage.PageInfo(childComplexity), true

	case "IntegrationSystemPage.totalCount":
		if e.complexity.IntegrationSystemPage.TotalCount == nil {
			break
		}

		return e.complexity.IntegrationSystemPage.TotalCount(childComplexity), true

	case "Label.key":
		if e.complexity.Label.Key == nil {
			break
		}

		return e.complexity.Label.Key(childComplexity), true

	case "Label.value":
		if e.complexity.Label.Value == nil {
			break
		}

		return e.complexity.Label.Value(childComplexity), true

	case "LabelDefinition.key":
		if e.complexity.LabelDefinition.Key == nil {
			break
		}

		return e.complexity.LabelDefinition.Key(childComplexity), true

	case "LabelDefinition.schema":
		if e.complexity.LabelDefinition.Schema == nil {
			break
		}

		return e.complexity.LabelDefinition.Schema(childComplexity), true

	case "Mutation.addAPIDefinitionToApplication":
		if e.complexity.Mutation.AddAPIDefinitionToApplication == nil {
			break
		}

		args, err := ec.field_Mutation_addAPIDefinitionToApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAPIDefinitionToApplication(childComplexity, args["appID"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.addAPIDefinitionToBundle":
		if e.complexity.Mutation.AddAPIDefinitionToBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addAPIDefinitionToBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAPIDefinitionToBundle(childComplexity, args["bundleID"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.addBundle":
		if e.complexity.Mutation.AddBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddBundle(childComplexity, args["applicationID"].(string), args["in"].(BundleCreateInput)), true

	case "Mutation.addDocumentToBundle":
		if e.complexity.Mutation.AddDocumentToBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addDocumentToBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddDocumentToBundle(childComplexity, args["bundleID"].(string), args["in"].(DocumentInput)), true

	case "Mutation.addEventDefinitionToApplication":
		if e.complexity.Mutation.AddEventDefinitionToApplication == nil {
			break
		}

		args, err := ec.field_Mutation_addEventDefinitionToApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventDefinitionToApplication(childComplexity, args["appID"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.addEventDefinitionToBundle":
		if e.complexity.Mutation.AddEventDefinitionToBundle == nil {
			break
		}

		args, err := ec.field_Mutation_addEventDefinitionToBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventDefinitionToBundle(childComplexity, args["bundleID"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.addIntegrationDependencyToApplication":
		if e.complexity.Mutation.AddIntegrationDependencyToApplication == nil {
			break
		}

		args, err := ec.field_Mutation_addIntegrationDependencyToApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddIntegrationDependencyToApplication(childComplexity, args["appID"].(string), args["in"].(IntegrationDependencyInput)), true

	case "Mutation.addTenantAccess":
		if e.complexity.Mutation.AddTenantAccess == nil {
			break
		}

		args, err := ec.field_Mutation_addTenantAccess_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTenantAccess(childComplexity, args["in"].(TenantAccessInput)), true

	case "Mutation.addWebhook":
		if e.complexity.Mutation.AddWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_addWebhook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddWebhook(childComplexity, args["applicationID"].(*string), args["applicationTemplateID"].(*string), args["runtimeID"].(*string), args["formationTemplateID"].(*string), args["in"].(WebhookInput)), true

	case "Mutation.assignFormation":
		if e.complexity.Mutation.AssignFormation == nil {
			break
		}

		args, err := ec.field_Mutation_assignFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignFormation(childComplexity, args["objectID"].(string), args["objectType"].(FormationObjectType), args["formation"].(FormationInput)), true

	case "Mutation.attachConstraintToFormationTemplate":
		if e.complexity.Mutation.AttachConstraintToFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_attachConstraintToFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachConstraintToFormationTemplate(childComplexity, args["constraintID"].(string), args["formationTemplateID"].(string)), true

	case "Mutation.createApplicationTemplate":
		if e.complexity.Mutation.CreateApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_createApplicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApplicationTemplate(childComplexity, args["in"].(ApplicationTemplateInput)), true

	case "Mutation.createBundleInstanceAuth":
		if e.complexity.Mutation.CreateBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_createBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBundleInstanceAuth(childComplexity, args["bundleID"].(string), args["in"].(BundleInstanceAuthCreateInput)), true

	case "Mutation.createCertificateSubjectMapping":
		if e.complexity.Mutation.CreateCertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Mutation_createCertificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCertificateSubjectMapping(childComplexity, args["in"].(CertificateSubjectMappingInput)), true

	case "Mutation.createFormation":
		if e.complexity.Mutation.CreateFormation == nil {
			break
		}

		args, err := ec.field_Mutation_createFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFormation(childComplexity, args["formation"].(FormationInput)), true

	case "Mutation.createFormationConstraint":
		if e.complexity.Mutation.CreateFormationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_createFormationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFormationConstraint(childComplexity, args["formationConstraint"].(FormationConstraintInput)), true

	case "Mutation.createFormationTemplate":
		if e.complexity.Mutation.CreateFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_createFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFormationTemplate(childComplexity, args["in"].(FormationTemplateInput)), true

	case "Mutation.createLabelDefinition":
		if e.complexity.Mutation.CreateLabelDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_createLabelDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLabelDefinition(childComplexity, args["in"].(LabelDefinitionInput)), true

	case "Mutation.deleteAPIDefinition":
		if e.complexity.Mutation.DeleteAPIDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAPIDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAPIDefinition(childComplexity, args["id"].(string)), true

	case "Mutation.deleteApplicationLabel":
		if e.complexity.Mutation.DeleteApplicationLabel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApplicationLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplicationLabel(childComplexity, args["applicationID"].(string), args["key"].(string)), true

	case "Mutation.deleteApplicationTemplate":
		if e.complexity.Mutation.DeleteApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApplicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplicationTemplate(childComplexity, args["id"].(string)), true

	case "Mutation.deleteBundle":
		if e.complexity.Mutation.DeleteBundle == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBundle(childComplexity, args["id"].(string)), true

	case "Mutation.deleteBundleInstanceAuth":
		if e.complexity.Mutation.DeleteBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBundleInstanceAuth(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteCertificateSubjectMapping":
		if e.complexity.Mutation.DeleteCertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCertificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCertificateSubjectMapping(childComplexity, args["id"].(string)), true

	case "Mutation.deleteDefaultEventingForApplication":
		if e.complexity.Mutation.DeleteDefaultEventingForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDefaultEventingForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDefaultEventingForApplication(childComplexity, args["appID"].(string)), true

	case "Mutation.deleteDocument":
		if e.complexity.Mutation.DeleteDocument == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDocument_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDocument(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEventDefinition":
		if e.complexity.Mutation.DeleteEventDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventDefinition(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFormation":
		if e.complexity.Mutation.DeleteFormation == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFormation(childComplexity, args["formation"].(FormationInput)), true

	case "Mutation.deleteFormationConstraint":
		if e.complexity.Mutation.DeleteFormationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFormationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFormationConstraint(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFormationTemplate":
		if e.complexity.Mutation.DeleteFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFormationTemplate(childComplexity, args["id"].(string)), true

	case "Mutation.deleteIntegrationDependency":
		if e.complexity.Mutation.DeleteIntegrationDependency == nil {
			break
		}

		args, err := ec.field_Mutation_deleteIntegrationDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteIntegrationDependency(childComplexity, args["id"].(string)), true

	case "Mutation.deleteRuntimeLabel":
		if e.complexity.Mutation.DeleteRuntimeLabel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRuntimeLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRuntimeLabel(childComplexity, args["runtimeID"].(string), args["key"].(string)), true

	case "Mutation.deleteSystemAuthForApplication":
		if e.complexity.Mutation.DeleteSystemAuthForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSystemAuthForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSystemAuthForApplication(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteSystemAuthForIntegrationSystem":
		if e.complexity.Mutation.DeleteSystemAuthForIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSystemAuthForIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSystemAuthForIntegrationSystem(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteSystemAuthForRuntime":
		if e.complexity.Mutation.DeleteSystemAuthForRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSystemAuthForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSystemAuthForRuntime(childComplexity, args["authID"].(string)), true

	case "Mutation.deleteTenants":
		if e.complexity.Mutation.DeleteTenants == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTenants(childComplexity, args["in"].([]string)), true

	case "Mutation.deleteWebhook":
		if e.complexity.Mutation.DeleteWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWebhook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWebhook(childComplexity, args["webhookID"].(string)), true

	case "Mutation.detachConstraintFromFormationTemplate":
		if e.complexity.Mutation.DetachConstraintFromFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_detachConstraintFromFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachConstraintFromFormationTemplate(childComplexity, args["constraintID"].(string), args["formationTemplateID"].(string)), true

	case "Mutation.finalizeDraftFormation":
		if e.complexity.Mutation.FinalizeDraftFormation == nil {
			break
		}

		args, err := ec.field_Mutation_finalizeDraftFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinalizeDraftFormation(childComplexity, args["formationID"].(string)), true

	case "Mutation.invalidateSystemAuthOneTimeToken":
		if e.complexity.Mutation.InvalidateSystemAuthOneTimeToken == nil {
			break
		}

		args, err := ec.field_Mutation_invalidateSystemAuthOneTimeToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InvalidateSystemAuthOneTimeToken(childComplexity, args["authID"].(string)), true

	case "Mutation.mergeApplications":
		if e.complexity.Mutation.MergeApplications == nil {
			break
		}

		args, err := ec.field_Mutation_mergeApplications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MergeApplications(childComplexity, args["destinationID"].(string), args["sourceID"].(string)), true

	case "Mutation.refetchAPISpec":
		if e.complexity.Mutation.RefetchAPISpec == nil {
			break
		}

		args, err := ec.field_Mutation_refetchAPISpec_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefetchAPISpec(childComplexity, args["apiID"].(string)), true

	case "Mutation.refetchEventDefinitionSpec":
		if e.complexity.Mutation.RefetchEventDefinitionSpec == nil {
			break
		}

		args, err := ec.field_Mutation_refetchEventDefinitionSpec_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefetchEventDefinitionSpec(childComplexity, args["eventID"].(string)), true

	case "Mutation.registerApplication":
		if e.complexity.Mutation.RegisterApplication == nil {
			break
		}

		args, err := ec.field_Mutation_registerApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterApplication(childComplexity, args["in"].(ApplicationRegisterInput), args["mode"].(*OperationMode)), true

	case "Mutation.registerApplicationFromTemplate":
		if e.complexity.Mutation.RegisterApplicationFromTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_registerApplicationFromTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterApplicationFromTemplate(childComplexity, args["in"].(ApplicationFromTemplateInput)), true

	case "Mutation.registerIntegrationSystem":
		if e.complexity.Mutation.RegisterIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_registerIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterIntegrationSystem(childComplexity, args["in"].(IntegrationSystemInput)), true

	case "Mutation.registerRuntime":
		if e.complexity.Mutation.RegisterRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_registerRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterRuntime(childComplexity, args["in"].(RuntimeRegisterInput)), true

	case "Mutation.registerRuntimeContext":
		if e.complexity.Mutation.RegisterRuntimeContext == nil {
			break
		}

		args, err := ec.field_Mutation_registerRuntimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterRuntimeContext(childComplexity, args["runtimeID"].(string), args["in"].(RuntimeContextInput)), true

	case "Mutation.removeTenantAccess":
		if e.complexity.Mutation.RemoveTenantAccess == nil {
			break
		}

		args, err := ec.field_Mutation_removeTenantAccess_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveTenantAccess(childComplexity, args["tenantID"].(string), args["resourceID"].(string), args["resourceType"].(TenantAccessObjectType)), true

	case "Mutation.requestBundleInstanceAuthCreation":
		if e.complexity.Mutation.RequestBundleInstanceAuthCreation == nil {
			break
		}

		args, err := ec.field_Mutation_requestBundleInstanceAuthCreation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestBundleInstanceAuthCreation(childComplexity, args["bundleID"].(string), args["in"].(BundleInstanceAuthRequestInput)), true

	case "Mutation.requestBundleInstanceAuthDeletion":
		if e.complexity.Mutation.RequestBundleInstanceAuthDeletion == nil {
			break
		}

		args, err := ec.field_Mutation_requestBundleInstanceAuthDeletion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestBundleInstanceAuthDeletion(childComplexity, args["authID"].(string)), true

	case "Mutation.requestClientCredentialsForApplication":
		if e.complexity.Mutation.RequestClientCredentialsForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_requestClientCredentialsForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestClientCredentialsForApplication(childComplexity, args["id"].(string)), true

	case "Mutation.requestClientCredentialsForIntegrationSystem":
		if e.complexity.Mutation.RequestClientCredentialsForIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_requestClientCredentialsForIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestClientCredentialsForIntegrationSystem(childComplexity, args["id"].(string)), true

	case "Mutation.requestClientCredentialsForRuntime":
		if e.complexity.Mutation.RequestClientCredentialsForRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_requestClientCredentialsForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestClientCredentialsForRuntime(childComplexity, args["id"].(string)), true

	case "Mutation.requestOneTimeTokenForApplication":
		if e.complexity.Mutation.RequestOneTimeTokenForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_requestOneTimeTokenForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestOneTimeTokenForApplication(childComplexity, args["id"].(string), args["systemAuthID"].(*string)), true

	case "Mutation.requestOneTimeTokenForRuntime":
		if e.complexity.Mutation.RequestOneTimeTokenForRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_requestOneTimeTokenForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RequestOneTimeTokenForRuntime(childComplexity, args["id"].(string), args["systemAuthID"].(*string)), true

	case "Mutation.resynchronizeFormationNotifications":
		if e.complexity.Mutation.ResynchronizeFormationNotifications == nil {
			break
		}

		args, err := ec.field_Mutation_resynchronizeFormationNotifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResynchronizeFormationNotifications(childComplexity, args["formationID"].(string), args["reset"].(*bool)), true

	case "Mutation.setApplicationLabel":
		if e.complexity.Mutation.SetApplicationLabel == nil {
			break
		}

		args, err := ec.field_Mutation_setApplicationLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetApplicationLabel(childComplexity, args["applicationID"].(string), args["key"].(string), args["value"].(interface{})), true

	case "Mutation.setBundleInstanceAuth":
		if e.complexity.Mutation.SetBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_setBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetBundleInstanceAuth(childComplexity, args["authID"].(string), args["in"].(BundleInstanceAuthSetInput)), true

	case "Mutation.setDefaultEventingForApplication":
		if e.complexity.Mutation.SetDefaultEventingForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_setDefaultEventingForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetDefaultEventingForApplication(childComplexity, args["appID"].(string), args["runtimeID"].(string)), true

	case "Mutation.setRuntimeLabel":
		if e.complexity.Mutation.SetRuntimeLabel == nil {
			break
		}

		args, err := ec.field_Mutation_setRuntimeLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetRuntimeLabel(childComplexity, args["runtimeID"].(string), args["key"].(string), args["value"].(interface{})), true

	case "Mutation.setTenantLabel":
		if e.complexity.Mutation.SetTenantLabel == nil {
			break
		}

		args, err := ec.field_Mutation_setTenantLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTenantLabel(childComplexity, args["tenantID"].(string), args["key"].(string), args["value"].(interface{})), true

	case "Mutation.subscribeTenant":
		if e.complexity.Mutation.SubscribeTenant == nil {
			break
		}

		args, err := ec.field_Mutation_subscribeTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SubscribeTenant(childComplexity, args["providerID"].(string), args["subaccountID"].(string), args["providerSubaccountID"].(string), args["consumerTenantID"].(string), args["region"].(string), args["subscriptionAppName"].(string), args["subscriptionPayload"].(string)), true

	case "Mutation.unassignFormation":
		if e.complexity.Mutation.UnassignFormation == nil {
			break
		}

		args, err := ec.field_Mutation_unassignFormation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignFormation(childComplexity, args["objectID"].(string), args["objectType"].(FormationObjectType), args["formation"].(FormationInput)), true

	case "Mutation.unassignFormationGlobal":
		if e.complexity.Mutation.UnassignFormationGlobal == nil {
			break
		}

		args, err := ec.field_Mutation_unassignFormationGlobal_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignFormationGlobal(childComplexity, args["objectID"].(string), args["objectType"].(FormationObjectType), args["formation"].(string)), true

	case "Mutation.unpairApplication":
		if e.complexity.Mutation.UnpairApplication == nil {
			break
		}

		args, err := ec.field_Mutation_unpairApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnpairApplication(childComplexity, args["id"].(string), args["mode"].(*OperationMode)), true

	case "Mutation.unregisterApplication":
		if e.complexity.Mutation.UnregisterApplication == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterApplication(childComplexity, args["id"].(string), args["mode"].(*OperationMode)), true

	case "Mutation.unregisterIntegrationSystem":
		if e.complexity.Mutation.UnregisterIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterIntegrationSystem(childComplexity, args["id"].(string)), true

	case "Mutation.unregisterRuntime":
		if e.complexity.Mutation.UnregisterRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterRuntime(childComplexity, args["id"].(string)), true

	case "Mutation.unregisterRuntimeContext":
		if e.complexity.Mutation.UnregisterRuntimeContext == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterRuntimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterRuntimeContext(childComplexity, args["id"].(string)), true

	case "Mutation.unsubscribeTenant":
		if e.complexity.Mutation.UnsubscribeTenant == nil {
			break
		}

		args, err := ec.field_Mutation_unsubscribeTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnsubscribeTenant(childComplexity, args["providerID"].(string), args["subaccountID"].(string), args["providerSubaccountID"].(string), args["consumerTenantID"].(string), args["region"].(string), args["subscriptionPayload"].(string)), true

	case "Mutation.updateAPIDefinition":
		if e.complexity.Mutation.UpdateAPIDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_updateAPIDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAPIDefinition(childComplexity, args["id"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.updateAPIDefinitionForApplication":
		if e.complexity.Mutation.UpdateAPIDefinitionForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_updateAPIDefinitionForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAPIDefinitionForApplication(childComplexity, args["id"].(string), args["in"].(APIDefinitionInput)), true

	case "Mutation.updateApplication":
		if e.complexity.Mutation.UpdateApplication == nil {
			break
		}

		args, err := ec.field_Mutation_updateApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApplication(childComplexity, args["id"].(string), args["in"].(ApplicationUpdateInput)), true

	case "Mutation.updateApplicationTemplate":
		if e.complexity.Mutation.UpdateApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_updateApplicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApplicationTemplate(childComplexity, args["id"].(string), args["override"].(*bool), args["in"].(ApplicationTemplateUpdateInput)), true

	case "Mutation.updateBundle":
		if e.complexity.Mutation.UpdateBundle == nil {
			break
		}

		args, err := ec.field_Mutation_updateBundle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBundle(childComplexity, args["id"].(string), args["in"].(BundleUpdateInput)), true

	case "Mutation.updateBundleInstanceAuth":
		if e.complexity.Mutation.UpdateBundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Mutation_updateBundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBundleInstanceAuth(childComplexity, args["id"].(string), args["bundleID"].(string), args["in"].(BundleInstanceAuthUpdateInput)), true

	case "Mutation.updateCertificateSubjectMapping":
		if e.complexity.Mutation.UpdateCertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Mutation_updateCertificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCertificateSubjectMapping(childComplexity, args["id"].(string), args["in"].(CertificateSubjectMappingInput)), true

	case "Mutation.updateEventDefinition":
		if e.complexity.Mutation.UpdateEventDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventDefinition(childComplexity, args["id"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.updateEventDefinitionForApplication":
		if e.complexity.Mutation.UpdateEventDefinitionForApplication == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventDefinitionForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventDefinitionForApplication(childComplexity, args["id"].(string), args["in"].(EventDefinitionInput)), true

	case "Mutation.updateFormationConstraint":
		if e.complexity.Mutation.UpdateFormationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_updateFormationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFormationConstraint(childComplexity, args["id"].(string), args["in"].(FormationConstraintUpdateInput)), true

	case "Mutation.updateFormationTemplate":
		if e.complexity.Mutation.UpdateFormationTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_updateFormationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFormationTemplate(childComplexity, args["id"].(string), args["in"].(FormationTemplateInput)), true

	case "Mutation.updateIntegrationSystem":
		if e.complexity.Mutation.UpdateIntegrationSystem == nil {
			break
		}

		args, err := ec.field_Mutation_updateIntegrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateIntegrationSystem(childComplexity, args["id"].(string), args["in"].(IntegrationSystemInput)), true

	case "Mutation.updateLabelDefinition":
		if e.complexity.Mutation.UpdateLabelDefinition == nil {
			break
		}

		args, err := ec.field_Mutation_updateLabelDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLabelDefinition(childComplexity, args["in"].(LabelDefinitionInput)), true

	case "Mutation.updateRuntime":
		if e.complexity.Mutation.UpdateRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_updateRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRuntime(childComplexity, args["id"].(string), args["in"].(RuntimeUpdateInput)), true

	case "Mutation.updateRuntimeContext":
		if e.complexity.Mutation.UpdateRuntimeContext == nil {
			break
		}

		args, err := ec.field_Mutation_updateRuntimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRuntimeContext(childComplexity, args["id"].(string), args["in"].(RuntimeContextInput)), true

	case "Mutation.updateSystemAuth":
		if e.complexity.Mutation.UpdateSystemAuth == nil {
			break
		}

		args, err := ec.field_Mutation_updateSystemAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSystemAuth(childComplexity, args["authID"].(string), args["in"].(AuthInput)), true

	case "Mutation.updateTenant":
		if e.complexity.Mutation.UpdateTenant == nil {
			break
		}

		args, err := ec.field_Mutation_updateTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTenant(childComplexity, args["id"].(string), args["in"].(BusinessTenantMappingInput)), true

	case "Mutation.updateWebhook":
		if e.complexity.Mutation.UpdateWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_updateWebhook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateWebhook(childComplexity, args["webhookID"].(string), args["in"].(WebhookInput)), true

	case "Mutation.writeTenant":
		if e.complexity.Mutation.WriteTenant == nil {
			break
		}

		args, err := ec.field_Mutation_writeTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.WriteTenant(childComplexity, args["in"].(BusinessTenantMappingInput)), true

	case "Mutation.writeTenants":
		if e.complexity.Mutation.WriteTenants == nil {
			break
		}

		args, err := ec.field_Mutation_writeTenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.WriteTenants(childComplexity, args["in"].([]*BusinessTenantMappingInput)), true

	case "OAuthCredentialData.clientId":
		if e.complexity.OAuthCredentialData.ClientID == nil {
			break
		}

		return e.complexity.OAuthCredentialData.ClientID(childComplexity), true

	case "OAuthCredentialData.clientSecret":
		if e.complexity.OAuthCredentialData.ClientSecret == nil {
			break
		}

		return e.complexity.OAuthCredentialData.ClientSecret(childComplexity), true

	case "OAuthCredentialData.url":
		if e.complexity.OAuthCredentialData.URL == nil {
			break
		}

		return e.complexity.OAuthCredentialData.URL(childComplexity), true

	case "OneTimeTokenForApplication.connectorURL":
		if e.complexity.OneTimeTokenForApplication.ConnectorURL == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.ConnectorURL(childComplexity), true

	case "OneTimeTokenForApplication.createdAt":
		if e.complexity.OneTimeTokenForApplication.CreatedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.CreatedAt(childComplexity), true

	case "OneTimeTokenForApplication.expiresAt":
		if e.complexity.OneTimeTokenForApplication.ExpiresAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.ExpiresAt(childComplexity), true

	case "OneTimeTokenForApplication.legacyConnectorURL":
		if e.complexity.OneTimeTokenForApplication.LegacyConnectorURL == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.LegacyConnectorURL(childComplexity), true

	case "OneTimeTokenForApplication.raw":
		if e.complexity.OneTimeTokenForApplication.Raw == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Raw(childComplexity), true

	case "OneTimeTokenForApplication.rawEncoded":
		if e.complexity.OneTimeTokenForApplication.RawEncoded == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.RawEncoded(childComplexity), true

	case "OneTimeTokenForApplication.scenarioGroups":
		if e.complexity.OneTimeTokenForApplication.ScenarioGroups == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.ScenarioGroups(childComplexity), true

	case "OneTimeTokenForApplication.token":
		if e.complexity.OneTimeTokenForApplication.Token == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Token(childComplexity), true

	case "OneTimeTokenForApplication.type":
		if e.complexity.OneTimeTokenForApplication.Type == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Type(childComplexity), true

	case "OneTimeTokenForApplication.used":
		if e.complexity.OneTimeTokenForApplication.Used == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.Used(childComplexity), true

	case "OneTimeTokenForApplication.usedAt":
		if e.complexity.OneTimeTokenForApplication.UsedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForApplication.UsedAt(childComplexity), true

	case "OneTimeTokenForRuntime.connectorURL":
		if e.complexity.OneTimeTokenForRuntime.ConnectorURL == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.ConnectorURL(childComplexity), true

	case "OneTimeTokenForRuntime.createdAt":
		if e.complexity.OneTimeTokenForRuntime.CreatedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.CreatedAt(childComplexity), true

	case "OneTimeTokenForRuntime.expiresAt":
		if e.complexity.OneTimeTokenForRuntime.ExpiresAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.ExpiresAt(childComplexity), true

	case "OneTimeTokenForRuntime.raw":
		if e.complexity.OneTimeTokenForRuntime.Raw == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Raw(childComplexity), true

	case "OneTimeTokenForRuntime.rawEncoded":
		if e.complexity.OneTimeTokenForRuntime.RawEncoded == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.RawEncoded(childComplexity), true

	case "OneTimeTokenForRuntime.token":
		if e.complexity.OneTimeTokenForRuntime.Token == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Token(childComplexity), true

	case "OneTimeTokenForRuntime.type":
		if e.complexity.OneTimeTokenForRuntime.Type == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Type(childComplexity), true

	case "OneTimeTokenForRuntime.used":
		if e.complexity.OneTimeTokenForRuntime.Used == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.Used(childComplexity), true

	case "OneTimeTokenForRuntime.usedAt":
		if e.complexity.OneTimeTokenForRuntime.UsedAt == nil {
			break
		}

		return e.complexity.OneTimeTokenForRuntime.UsedAt(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PlaceholderDefinition.description":
		if e.complexity.PlaceholderDefinition.Description == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.Description(childComplexity), true

	case "PlaceholderDefinition.jsonPath":
		if e.complexity.PlaceholderDefinition.JSONPath == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.JSONPath(childComplexity), true

	case "PlaceholderDefinition.name":
		if e.complexity.PlaceholderDefinition.Name == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.Name(childComplexity), true

	case "PlaceholderDefinition.optional":
		if e.complexity.PlaceholderDefinition.Optional == nil {
			break
		}

		return e.complexity.PlaceholderDefinition.Optional(childComplexity), true

	case "Query.apisForApplication":
		if e.complexity.Query.ApisForApplication == nil {
			break
		}

		args, err := ec.field_Query_apisForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApisForApplication(childComplexity, args["appID"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.application":
		if e.complexity.Query.Application == nil {
			break
		}

		args, err := ec.field_Query_application_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Application(childComplexity, args["id"].(string)), true

	case "Query.applicationByLocalTenantIDAndAppTemplateID":
		if e.complexity.Query.ApplicationByLocalTenantIDAndAppTemplateID == nil {
			break
		}

		args, err := ec.field_Query_applicationByLocalTenantIDAndAppTemplateID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationByLocalTenantIDAndAppTemplateID(childComplexity, args["localTenantID"].(string), args["applicationTemplateID"].(string)), true

	case "Query.applicationBySystemNumber":
		if e.complexity.Query.ApplicationBySystemNumber == nil {
			break
		}

		args, err := ec.field_Query_applicationBySystemNumber_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationBySystemNumber(childComplexity, args["systemNumber"].(string)), true

	case "Query.applicationTemplate":
		if e.complexity.Query.ApplicationTemplate == nil {
			break
		}

		args, err := ec.field_Query_applicationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationTemplate(childComplexity, args["id"].(string)), true

	case "Query.applicationTemplates":
		if e.complexity.Query.ApplicationTemplates == nil {
			break
		}

		args, err := ec.field_Query_applicationTemplates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationTemplates(childComplexity, args["filter"].([]*LabelFilter), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.applications":
		if e.complexity.Query.Applications == nil {
			break
		}

		args, err := ec.field_Query_applications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Applications(childComplexity, args["filter"].([]*LabelFilter), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.applicationsForRuntime":
		if e.complexity.Query.ApplicationsForRuntime == nil {
			break
		}

		args, err := ec.field_Query_applicationsForRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ApplicationsForRuntime(childComplexity, args["runtimeID"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.automaticScenarioAssignmentForScenario":
		if e.complexity.Query.AutomaticScenarioAssignmentForScenario == nil {
			break
		}

		args, err := ec.field_Query_automaticScenarioAssignmentForScenario_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AutomaticScenarioAssignmentForScenario(childComplexity, args["scenarioName"].(string)), true

	case "Query.automaticScenarioAssignments":
		if e.complexity.Query.AutomaticScenarioAssignments == nil {
			break
		}

		args, err := ec.field_Query_automaticScenarioAssignments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AutomaticScenarioAssignments(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.automaticScenarioAssignmentsForSelector":
		if e.complexity.Query.AutomaticScenarioAssignmentsForSelector == nil {
			break
		}

		args, err := ec.field_Query_automaticScenarioAssignmentsForSelector_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AutomaticScenarioAssignmentsForSelector(childComplexity, args["selector"].(LabelSelectorInput)), true

	case "Query.bundleByInstanceAuth":
		if e.complexity.Query.BundleByInstanceAuth == nil {
			break
		}

		args, err := ec.field_Query_bundleByInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BundleByInstanceAuth(childComplexity, args["authID"].(string)), true

	case "Query.bundleInstanceAuth":
		if e.complexity.Query.BundleInstanceAuth == nil {
			break
		}

		args, err := ec.field_Query_bundleInstanceAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BundleInstanceAuth(childComplexity, args["id"].(string)), true

	case "Query.certificateSubjectMapping":
		if e.complexity.Query.CertificateSubjectMapping == nil {
			break
		}

		args, err := ec.field_Query_certificateSubjectMapping_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertificateSubjectMapping(childComplexity, args["id"].(string)), true

	case "Query.certificateSubjectMappings":
		if e.complexity.Query.CertificateSubjectMappings == nil {
			break
		}

		args, err := ec.field_Query_certificateSubjectMappings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertificateSubjectMappings(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.eventsForApplication":
		if e.complexity.Query.EventsForApplication == nil {
			break
		}

		args, err := ec.field_Query_eventsForApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EventsForApplication(childComplexity, args["appID"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formation":
		if e.complexity.Query.Formation == nil {
			break
		}

		args, err := ec.field_Query_formation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Formation(childComplexity, args["id"].(string)), true

	case "Query.formationByName":
		if e.complexity.Query.FormationByName == nil {
			break
		}

		args, err := ec.field_Query_formationByName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationByName(childComplexity, args["name"].(string)), true

	case "Query.formationConstraint":
		if e.complexity.Query.FormationConstraint == nil {
			break
		}

		args, err := ec.field_Query_formationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationConstraint(childComplexity, args["id"].(string)), true

	case "Query.formationConstraints":
		if e.complexity.Query.FormationConstraints == nil {
			break
		}

		return e.complexity.Query.FormationConstraints(childComplexity), true

	case "Query.formationConstraintsByFormationType":
		if e.complexity.Query.FormationConstraintsByFormationType == nil {
			break
		}

		args, err := ec.field_Query_formationConstraintsByFormationType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationConstraintsByFormationType(childComplexity, args["formationTemplateID"].(string)), true

	case "Query.formationTemplate":
		if e.complexity.Query.FormationTemplate == nil {
			break
		}

		args, err := ec.field_Query_formationTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationTemplate(childComplexity, args["id"].(string)), true

	case "Query.formationTemplates":
		if e.complexity.Query.FormationTemplates == nil {
			break
		}

		args, err := ec.field_Query_formationTemplates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationTemplates(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formationTemplatesByName":
		if e.complexity.Query.FormationTemplatesByName == nil {
			break
		}

		args, err := ec.field_Query_formationTemplatesByName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationTemplatesByName(childComplexity, args["name"].(string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formations":
		if e.complexity.Query.Formations == nil {
			break
		}

		args, err := ec.field_Query_formations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Formations(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.formationsForObject":
		if e.complexity.Query.FormationsForObject == nil {
			break
		}

		args, err := ec.field_Query_formationsForObject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FormationsForObject(childComplexity, args["objectID"].(string)), true

	case "Query.healthChecks":
		if e.complexity.Query.HealthChecks == nil {
			break
		}

		args, err := ec.field_Query_healthChecks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HealthChecks(childComplexity, args["types"].([]HealthCheckType), args["origin"].(*string), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.integrationSystem":
		if e.complexity.Query.IntegrationSystem == nil {
			break
		}

		args, err := ec.field_Query_integrationSystem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IntegrationSystem(childComplexity, args["id"].(string)), true

	case "Query.integrationSystems":
		if e.complexity.Query.IntegrationSystems == nil {
			break
		}

		args, err := ec.field_Query_integrationSystems_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IntegrationSystems(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.labelDefinition":
		if e.complexity.Query.LabelDefinition == nil {
			break
		}

		args, err := ec.field_Query_labelDefinition_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LabelDefinition(childComplexity, args["key"].(string)), true

	case "Query.labelDefinitions":
		if e.complexity.Query.LabelDefinitions == nil {
			break
		}

		return e.complexity.Query.LabelDefinitions(childComplexity), true

	case "Query.rootTenants":
		if e.complexity.Query.RootTenants == nil {
			break
		}

		args, err := ec.field_Query_rootTenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RootTenants(childComplexity, args["externalTenant"].(string)), true

	case "Query.runtime":
		if e.complexity.Query.Runtime == nil {
			break
		}

		args, err := ec.field_Query_runtime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Runtime(childComplexity, args["id"].(string)), true

	case "Query.runtimeByTokenIssuer":
		if e.complexity.Query.RuntimeByTokenIssuer == nil {
			break
		}

		args, err := ec.field_Query_runtimeByTokenIssuer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RuntimeByTokenIssuer(childComplexity, args["issuer"].(string)), true

	case "Query.runtimes":
		if e.complexity.Query.Runtimes == nil {
			break
		}

		args, err := ec.field_Query_runtimes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Runtimes(childComplexity, args["filter"].([]*LabelFilter), args["first"].(*int), args["after"].(*PageCursor)), true

	case "Query.systemAuth":
		if e.complexity.Query.SystemAuth == nil {
			break
		}

		args, err := ec.field_Query_systemAuth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SystemAuth(childComplexity, args["id"].(string)), true

	case "Query.systemAuthByToken":
		if e.complexity.Query.SystemAuthByToken == nil {
			break
		}

		args, err := ec.field_Query_systemAuthByToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SystemAuthByToken(childComplexity, args["token"].(string)), true

	case "Query.tenantByExternalID":
		if e.complexity.Query.TenantByExternalID == nil {
			break
		}

		args, err := ec.field_Query_tenantByExternalID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TenantByExternalID(childComplexity, args["id"].(string)), true

	case "Query.tenantByInternalID":
		if e.complexity.Query.TenantByInternalID == nil {
			break
		}

		args, err := ec.field_Query_tenantByInternalID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TenantByInternalID(childComplexity, args["id"].(string)), true

	case "Query.tenantByLowestOwnerForResource":
		if e.complexity.Query.TenantByLowestOwnerForResource == nil {
			break
		}

		args, err := ec.field_Query_tenantByLowestOwnerForResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TenantByLowestOwnerForResource(childComplexity, args["id"].(string), args["resource"].(string)), true

	case "Query.tenants":
		if e.complexity.Query.Tenants == nil {
			break
		}

		args, err := ec.field_Query_tenants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tenants(childComplexity, args["first"].(*int), args["after"].(*PageCursor), args["searchTerm"].(*string)), true

	case "Query.viewer":
		if e.complexity.Query.Viewer == nil {
			break
		}

		return e.complexity.Query.Viewer(childComplexity), true

	case "Runtime.applicationNamespace":
		if e.complexity.Runtime.ApplicationNamespace == nil {
			break
		}

		return e.complexity.Runtime.ApplicationNamespace(childComplexity), true

	case "Runtime.auths":
		if e.complexity.Runtime.Auths == nil {
			break
		}

		return e.complexity.Runtime.Auths(childComplexity), true

	case "Runtime.description":
		if e.complexity.Runtime.Description == nil {
			break
		}

		return e.complexity.Runtime.Description(childComplexity), true

	case "Runtime.eventingConfiguration":
		if e.complexity.Runtime.EventingConfiguration == nil {
			break
		}

		return e.complexity.Runtime.EventingConfiguration(childComplexity), true

	case "Runtime.id":
		if e.complexity.Runtime.ID == nil {
			break
		}

		return e.complexity.Runtime.ID(childComplexity), true

	case "Runtime.labels":
		if e.complexity.Runtime.Labels == nil {
			break
		}

		args, err := ec.field_Runtime_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Runtime.Labels(childComplexity, args["key"].(*string)), true

	case "Runtime.metadata":
		if e.complexity.Runtime.Metadata == nil {
			break
		}

		return e.complexity.Runtime.Metadata(childComplexity), true

	case "Runtime.name":
		if e.complexity.Runtime.Name == nil {
			break
		}

		return e.complexity.Runtime.Name(childComplexity), true

	case "Runtime.runtimeContext":
		if e.complexity.Runtime.RuntimeContext == nil {
			break
		}

		args, err := ec.field_Runtime_runtimeContext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Runtime.RuntimeContext(childComplexity, args["id"].(string)), true

	case "Runtime.runtimeContexts":
		if e.complexity.Runtime.RuntimeContexts == nil {
			break
		}

		args, err := ec.field_Runtime_runtimeContexts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Runtime.RuntimeContexts(childComplexity, args["first"].(*int), args["after"].(*PageCursor)), true

	case "Runtime.status":
		if e.complexity.Runtime.Status == nil {
			break
		}

		return e.complexity.Runtime.Status(childComplexity), true

	case "Runtime.webhooks":
		if e.complexity.Runtime.Webhooks == nil {
			break
		}

		return e.complexity.Runtime.Webhooks(childComplexity), true

	case "RuntimeContext.id":
		if e.complexity.RuntimeContext.ID == nil {
			break
		}

		return e.complexity.RuntimeContext.ID(childComplexity), true

	case "RuntimeContext.key":
		if e.complexity.RuntimeContext.Key == nil {
			break
		}

		return e.complexity.RuntimeContext.Key(childComplexity), true

	case "RuntimeContext.labels":
		if e.complexity.RuntimeContext.Labels == nil {
			break
		}

		args, err := ec.field_RuntimeContext_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RuntimeContext.Labels(childComplexity, args["key"].(*string)), true

	case "RuntimeContext.value":
		if e.complexity.RuntimeContext.Value == nil {
			break
		}

		return e.complexity.RuntimeContext.Value(childComplexity), true

	case "RuntimeContextPage.data":
		if e.complexity.RuntimeContextPage.Data == nil {
			break
		}

		return e.complexity.RuntimeContextPage.Data(childComplexity), true

	case "RuntimeContextPage.pageInfo":
		if e.complexity.RuntimeContextPage.PageInfo == nil {
			break
		}

		return e.complexity.RuntimeContextPage.PageInfo(childComplexity), true

	case "RuntimeContextPage.totalCount":
		if e.complexity.RuntimeContextPage.TotalCount == nil {
			break
		}

		return e.complexity.RuntimeContextPage.TotalCount(childComplexity), true

	case "RuntimeEventingConfiguration.defaultURL":
		if e.complexity.RuntimeEventingConfiguration.DefaultURL == nil {
			break
		}

		return e.complexity.RuntimeEventingConfiguration.DefaultURL(childComplexity), true

	case "RuntimeMetadata.creationTimestamp":
		if e.complexity.RuntimeMetadata.CreationTimestamp == nil {
			break
		}

		return e.complexity.RuntimeMetadata.CreationTimestamp(childComplexity), true

	case "RuntimePage.data":
		if e.complexity.RuntimePage.Data == nil {
			break
		}

		return e.complexity.RuntimePage.Data(childComplexity), true

	case "RuntimePage.pageInfo":
		if e.complexity.RuntimePage.PageInfo == nil {
			break
		}

		return e.complexity.RuntimePage.PageInfo(childComplexity), true

	case "RuntimePage.totalCount":
		if e.complexity.RuntimePage.TotalCount == nil {
			break
		}

		return e.complexity.RuntimePage.TotalCount(childComplexity), true

	case "RuntimeStatus.condition":
		if e.complexity.RuntimeStatus.Condition == nil {
			break
		}

		return e.complexity.RuntimeStatus.Condition(childComplexity), true

	case "RuntimeStatus.timestamp":
		if e.complexity.RuntimeStatus.Timestamp == nil {
			break
		}

		return e.complexity.RuntimeStatus.Timestamp(childComplexity), true

	case "RuntimeSystemAuth.auth":
		if e.complexity.RuntimeSystemAuth.Auth == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.Auth(childComplexity), true

	case "RuntimeSystemAuth.id":
		if e.complexity.RuntimeSystemAuth.ID == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.ID(childComplexity), true

	case "RuntimeSystemAuth.referenceObjectId":
		if e.complexity.RuntimeSystemAuth.ReferenceObjectID == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.ReferenceObjectID(childComplexity), true

	case "RuntimeSystemAuth.tenantId":
		if e.complexity.RuntimeSystemAuth.TenantID == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.TenantID(childComplexity), true

	case "RuntimeSystemAuth.type":
		if e.complexity.RuntimeSystemAuth.Type == nil {
			break
		}

		return e.complexity.RuntimeSystemAuth.Type(childComplexity), true

	case "Tenant.id":
		if e.complexity.Tenant.ID == nil {
			break
		}

		return e.complexity.Tenant.ID(childComplexity), true

	case "Tenant.initialized":
		if e.complexity.Tenant.Initialized == nil {
			break
		}

		return e.complexity.Tenant.Initialized(childComplexity), true

	case "Tenant.internalID":
		if e.complexity.Tenant.InternalID == nil {
			break
		}

		return e.complexity.Tenant.InternalID(childComplexity), true

	case "Tenant.labels":
		if e.complexity.Tenant.Labels == nil {
			break
		}

		args, err := ec.field_Tenant_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tenant.Labels(childComplexity, args["key"].(*string)), true

	case "Tenant.name":
		if e.complexity.Tenant.Name == nil {
			break
		}

		return e.complexity.Tenant.Name(childComplexity), true

	case "Tenant.parents":
		if e.complexity.Tenant.Parents == nil {
			break
		}

		return e.complexity.Tenant.Parents(childComplexity), true

	case "Tenant.provider":
		if e.complexity.Tenant.Provider == nil {
			break
		}

		return e.complexity.Tenant.Provider(childComplexity), true

	case "Tenant.type":
		if e.complexity.Tenant.Type == nil {
			break
		}

		return e.complexity.Tenant.Type(childComplexity), true

	case "TenantAccess.owner":
		if e.complexity.TenantAccess.Owner == nil {
			break
		}

		return e.complexity.TenantAccess.Owner(childComplexity), true

	case "TenantAccess.resourceID":
		if e.complexity.TenantAccess.ResourceID == nil {
			break
		}

		return e.complexity.TenantAccess.ResourceID(childComplexity), true

	case "TenantAccess.resourceType":
		if e.complexity.TenantAccess.ResourceType == nil {
			break
		}

		return e.complexity.TenantAccess.ResourceType(childComplexity), true

	case "TenantAccess.tenantID":
		if e.complexity.TenantAccess.TenantID == nil {
			break
		}

		return e.complexity.TenantAccess.TenantID(childComplexity), true

	case "TenantPage.data":
		if e.complexity.TenantPage.Data == nil {
			break
		}

		return e.complexity.TenantPage.Data(childComplexity), true

	case "TenantPage.pageInfo":
		if e.complexity.TenantPage.PageInfo == nil {
			break
		}

		return e.complexity.TenantPage.PageInfo(childComplexity), true

	case "TenantPage.totalCount":
		if e.complexity.TenantPage.TotalCount == nil {
			break
		}

		return e.complexity.TenantPage.TotalCount(childComplexity), true

	case "Version.deprecated":
		if e.complexity.Version.Deprecated == nil {
			break
		}

		return e.complexity.Version.Deprecated(childComplexity), true

	case "Version.deprecatedSince":
		if e.complexity.Version.DeprecatedSince == nil {
			break
		}

		return e.complexity.Version.DeprecatedSince(childComplexity), true

	case "Version.forRemoval":
		if e.complexity.Version.ForRemoval == nil {
			break
		}

		return e.complexity.Version.ForRemoval(childComplexity), true

	case "Version.value":
		if e.complexity.Version.Value == nil {
			break
		}

		return e.complexity.Version.Value(childComplexity), true

	case "Viewer.id":
		if e.complexity.Viewer.ID == nil {
			break
		}

		return e.complexity.Viewer.ID(childComplexity), true

	case "Viewer.type":
		if e.complexity.Viewer.Type == nil {
			break
		}

		return e.complexity.Viewer.Type(childComplexity), true

	case "Webhook.applicationID":
		if e.complexity.Webhook.ApplicationID == nil {
			break
		}

		return e.complexity.Webhook.ApplicationID(childComplexity), true

	case "Webhook.applicationTemplateID":
		if e.complexity.Webhook.ApplicationTemplateID == nil {
			break
		}

		return e.complexity.Webhook.ApplicationTemplateID(childComplexity), true

	case "Webhook.auth":
		if e.complexity.Webhook.Auth == nil {
			break
		}

		return e.complexity.Webhook.Auth(childComplexity), true

	case "Webhook.correlationIdKey":
		if e.complexity.Webhook.CorrelationIDKey == nil {
			break
		}

		return e.complexity.Webhook.CorrelationIDKey(childComplexity), true

	case "Webhook.createdAt":
		if e.complexity.Webhook.CreatedAt == nil {
			break
		}

		return e.complexity.Webhook.CreatedAt(childComplexity), true

	case "Webhook.formationTemplateID":
		if e.complexity.Webhook.FormationTemplateID == nil {
			break
		}

		return e.complexity.Webhook.FormationTemplateID(childComplexity), true

	case "Webhook.headerTemplate":
		if e.complexity.Webhook.HeaderTemplate == nil {
			break
		}

		return e.complexity.Webhook.HeaderTemplate(childComplexity), true

	case "Webhook.id":
		if e.complexity.Webhook.ID == nil {
			break
		}

		return e.complexity.Webhook.ID(childComplexity), true

	case "Webhook.inputTemplate":
		if e.complexity.Webhook.InputTemplate == nil {
			break
		}

		return e.complexity.Webhook.InputTemplate(childComplexity), true

	case "Webhook.integrationSystemID":
		if e.complexity.Webhook.IntegrationSystemID == nil {
			break
		}

		return e.complexity.Webhook.IntegrationSystemID(childComplexity), true

	case "Webhook.mode":
		if e.complexity.Webhook.Mode == nil {
			break
		}

		return e.complexity.Webhook.Mode(childComplexity), true

	case "Webhook.outputTemplate":
		if e.complexity.Webhook.OutputTemplate == nil {
			break
		}

		return e.complexity.Webhook.OutputTemplate(childComplexity), true

	case "Webhook.retryInterval":
		if e.complexity.Webhook.RetryInterval == nil {
			break
		}

		return e.complexity.Webhook.RetryInterval(childComplexity), true

	case "Webhook.runtimeID":
		if e.complexity.Webhook.RuntimeID == nil {
			break
		}

		return e.complexity.Webhook.RuntimeID(childComplexity), true

	case "Webhook.statusTemplate":
		if e.complexity.Webhook.StatusTemplate == nil {
			break
		}

		return e.complexity.Webhook.StatusTemplate(childComplexity), true

	case "Webhook.timeout":
		if e.complexity.Webhook.Timeout == nil {
			break
		}

		return e.complexity.Webhook.Timeout(childComplexity), true

	case "Webhook.type":
		if e.complexity.Webhook.Type == nil {
			break
		}

		return e.complexity.Webhook.Type(childComplexity), true

	case "Webhook.url":
		if e.complexity.Webhook.URL == nil {
			break
		}

		return e.complexity.Webhook.URL(childComplexity), true

	case "Webhook.urlTemplate":
		if e.complexity.Webhook.URLTemplate == nil {
			break
		}

		return e.complexity.Webhook.URLTemplate(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAPIDefinitionInput,
		ec.unmarshalInputAPISpecInput,
		ec.unmarshalInputApplicationFromTemplateInput,
		ec.unmarshalInputApplicationJSONInput,
		ec.unmarshalInputApplicationRegisterInput,
		ec.unmarshalInputApplicationTemplateInput,
		ec.unmarshalInputApplicationTemplateUpdateInput,
		ec.unmarshalInputApplicationUpdateInput,
		ec.unmarshalInputAspectAPIDefinitionInput,
		ec.unmarshalInputAspectEventDefinitionInput,
		ec.unmarshalInputAspectEventDefinitionSubsetInput,
		ec.unmarshalInputAspectInput,
		ec.unmarshalInputAuthInput,
		ec.unmarshalInputBasicCredentialDataInput,
		ec.unmarshalInputBundleCreateInput,
		ec.unmarshalInputBundleInstanceAuthCreateInput,
		ec.unmarshalInputBundleInstanceAuthRequestInput,
		ec.unmarshalInputBundleInstanceAuthSetInput,
		ec.unmarshalInputBundleInstanceAuthStatusInput,
		ec.unmarshalInputBundleInstanceAuthUpdateInput,
		ec.unmarshalInputBundleUpdateInput,
		ec.unmarshalInputBusinessTenantMappingInput,
		ec.unmarshalInputCSRFTokenCredentialRequestAuthInput,
		ec.unmarshalInputCertificateOAuthCredentialDataInput,
		ec.unmarshalInputCertificateSubjectMappingInput,
		ec.unmarshalInputCredentialDataInput,
		ec.unmarshalInputCredentialRequestAuthInput,
		ec.unmarshalInputDocumentInput,
		ec.unmarshalInputEventDefinitionInput,
		ec.unmarshalInputEventSpecInput,
		ec.unmarshalInputFetchRequestInput,
		ec.unmarshalInputFormationConstraintInput,
		ec.unmarshalInputFormationConstraintUpdateInput,
		ec.unmarshalInputFormationInput,
		ec.unmarshalInputFormationTemplateInput,
		ec.unmarshalInputIntegrationDependencyInput,
		ec.unmarshalInputIntegrationSystemInput,
		ec.unmarshalInputLabelDefinitionInput,
		ec.unmarshalInputLabelFilter,
		ec.unmarshalInputLabelInput,
		ec.unmarshalInputLabelSelectorInput,
		ec.unmarshalInputOAuthCredentialDataInput,
		ec.unmarshalInputOneTimeTokenInput,
		ec.unmarshalInputPlaceholderDefinitionInput,
		ec.unmarshalInputRuntimeContextInput,
		ec.unmarshalInputRuntimeRegisterInput,
		ec.unmarshalInputRuntimeUpdateInput,
		ec.unmarshalInputSystemAuthUpdateInput,
		ec.unmarshalInputTemplateValueInput,
		ec.unmarshalInputTenantAccessInput,
		ec.unmarshalInputVersionInput,
		ec.unmarshalInputWebhookInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphql", Input: sourceData("schema.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_async_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 OperationType
	if tmp, ok := rawArgs["operationType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operationType"))
		arg0, err = ec.unmarshalNOperationType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["operationType"] = arg0
	var arg1 *WebhookType
	if tmp, ok := rawArgs["webhookType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookType"))
		arg1, err = ec.unmarshalOWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["webhookType"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["idField"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idField"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["idField"] = arg2
	return args, nil
}

func (ec *executionContext) dir_hasScenario_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationProvider"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationProvider"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationProvider"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["idField"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idField"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["idField"] = arg1
	return args, nil
}

func (ec *executionContext) dir_hasScopes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) dir_sanitize_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) dir_synchronizeApplicationTenancy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 EventType
	if tmp, ok := rawArgs["eventType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventType"))
		arg0, err = ec.unmarshalNEventType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["eventType"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationTemplate_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_apiDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_bundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_bundles_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Application_eventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Application_integrationDependencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Application_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_apiDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_apiDefinitions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["group"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["group"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Bundle_document_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_documents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Bundle_eventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Bundle_eventDefinitions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["group"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["group"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Bundle_instanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Formation_formationAssignment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Formation_formationAssignments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addAPIDefinitionToApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addAPIDefinitionToBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 BundleCreateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleCreateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleCreateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleCreateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addDocumentToBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 DocumentInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNDocumentInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(DocumentInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.DocumentInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addEventDefinitionToApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addEventDefinitionToBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addIntegrationDependencyToApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 IntegrationDependencyInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNIntegrationDependencyInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependencyInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(IntegrationDependencyInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationDependencyInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addTenantAccess_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 TenantAccessInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalNTenantAccessInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccessInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addWebhook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["applicationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationTemplateID"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationTemplateID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg2, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg3, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg3
	var arg4 WebhookInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(WebhookInput); ok {
			arg4 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.WebhookInput`, tmp))
		}
	}
	args["in"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_assignFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	var arg1 FormationObjectType
	if tmp, ok := rawArgs["objectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectType"))
		arg1, err = ec.unmarshalNFormationObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectType"] = arg1
	var arg2 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg2, err = ec.unmarshalNFormationInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_attachConstraintToFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["constraintID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["constraintID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createApplicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ApplicationTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationTemplateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationTemplateInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplateInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 BundleInstanceAuthCreateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleInstanceAuthCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthCreateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleInstanceAuthCreateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuthCreateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createCertificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CertificateSubjectMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCertificateSubjectMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMappingInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(CertificateSubjectMappingInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMappingInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFormationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationConstraintInput
	if tmp, ok := rawArgs["formationConstraint"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationConstraint"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNFormationConstraintInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraintInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(FormationConstraintInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraintInput`, tmp))
		}
	}
	args["formationConstraint"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNFormationTemplateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(FormationTemplateInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplateInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg0, err = ec.unmarshalNFormationInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLabelDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 LabelDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNLabelDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(LabelDefinitionInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinitionInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAPIDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteApplicationLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteApplicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCertificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDefaultEventingForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDocument_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFormationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg0, err = ec.unmarshalNFormationInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteIntegrationDependency_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRuntimeLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSystemAuthForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSystemAuthForIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSystemAuthForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWebhook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["webhookID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["webhookID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_detachConstraintFromFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["constraintID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["constraintID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_finalizeDraftFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["formationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_invalidateSystemAuthOneTimeToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_mergeApplications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["destinationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("destinationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["destinationID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["sourceID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sourceID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_refetchAPISpec_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["apiID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["apiID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refetchEventDefinitionSpec_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["eventID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["eventID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerApplicationFromTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ApplicationFromTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationFromTemplateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationFromTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationFromTemplateInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationFromTemplateInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ApplicationRegisterInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationRegisterInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationRegisterInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationRegisterInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationRegisterInput`, tmp))
		}
	}
	args["in"] = arg0
	var arg1 *OperationMode
	if tmp, ok := rawArgs["mode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
		arg1, err = ec.unmarshalOOperationMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationMode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_registerIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 IntegrationSystemInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNIntegrationSystemInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystemInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(IntegrationSystemInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystemInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerRuntimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 RuntimeContextInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeContextInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContextInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeContextInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContextInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_registerRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 RuntimeRegisterInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeRegisterInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeRegisterInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeRegisterInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeRegisterInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeTenantAccess_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tenantID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceID"] = arg1
	var arg2 TenantAccessObjectType
	if tmp, ok := rawArgs["resourceType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
		arg2, err = ec.unmarshalNTenantAccessObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccessObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceType"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_requestBundleInstanceAuthCreation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg0
	var arg1 BundleInstanceAuthRequestInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleInstanceAuthRequestInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthRequestInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleInstanceAuthRequestInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuthRequestInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_requestBundleInstanceAuthDeletion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestClientCredentialsForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestClientCredentialsForIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestClientCredentialsForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_requestOneTimeTokenForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["systemAuthID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemAuthID"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["systemAuthID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_requestOneTimeTokenForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["systemAuthID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemAuthID"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["systemAuthID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_resynchronizeFormationNotifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["formationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationID"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["reset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reset"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reset"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setApplicationLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["applicationID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	var arg2 interface{}
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg2, err = ec.unmarshalNAny2interface(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_setBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	var arg1 BundleInstanceAuthSetInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleInstanceAuthSetInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthSetInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleInstanceAuthSetInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuthSetInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setDefaultEventingForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setRuntimeLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	var arg2 interface{}
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg2, err = ec.unmarshalNAny2interface(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_setTenantLabel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tenantID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg1
	var arg2 interface{}
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg2, err = ec.unmarshalNAny2interface(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_subscribeTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["providerID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["subaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subaccountID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subaccountID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["providerSubaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSubaccountID"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerSubaccountID"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["consumerTenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consumerTenantID"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["consumerTenantID"] = arg3
	var arg4 string
	if tmp, ok := rawArgs["region"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
		arg4, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["region"] = arg4
	var arg5 string
	if tmp, ok := rawArgs["subscriptionAppName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionAppName"))
		arg5, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscriptionAppName"] = arg5
	var arg6 string
	if tmp, ok := rawArgs["subscriptionPayload"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionPayload"))
		arg6, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscriptionPayload"] = arg6
	return args, nil
}

func (ec *executionContext) field_Mutation_unassignFormationGlobal_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	var arg1 FormationObjectType
	if tmp, ok := rawArgs["objectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectType"))
		arg1, err = ec.unmarshalNFormationObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectType"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg2, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_unassignFormation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	var arg1 FormationObjectType
	if tmp, ok := rawArgs["objectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectType"))
		arg1, err = ec.unmarshalNFormationObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectType"] = arg1
	var arg2 FormationInput
	if tmp, ok := rawArgs["formation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formation"))
		arg2, err = ec.unmarshalNFormationInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formation"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_unpairApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *OperationMode
	if tmp, ok := rawArgs["mode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
		arg1, err = ec.unmarshalOOperationMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationMode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *OperationMode
	if tmp, ok := rawArgs["mode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
		arg1, err = ec.unmarshalOOperationMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationMode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterRuntimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unsubscribeTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["providerID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["subaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subaccountID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subaccountID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["providerSubaccountID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSubaccountID"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["providerSubaccountID"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["consumerTenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consumerTenantID"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["consumerTenantID"] = arg3
	var arg4 string
	if tmp, ok := rawArgs["region"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
		arg4, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["region"] = arg4
	var arg5 string
	if tmp, ok := rawArgs["subscriptionPayload"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionPayload"))
		arg5, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscriptionPayload"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAPIDefinitionForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAPIDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 APIDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(APIDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateApplicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["override"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("override"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["override"] = arg1
	var arg2 ApplicationTemplateUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationTemplateUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationTemplateUpdateInput); ok {
			arg2 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplateUpdateInput`, tmp))
		}
	}
	args["in"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ApplicationUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNApplicationUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(ApplicationUpdateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationUpdateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["bundleID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundleID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bundleID"] = arg1
	var arg2 BundleInstanceAuthUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg2, err = ec.unmarshalNBundleInstanceAuthUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBundle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 BundleUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNBundleUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(BundleUpdateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleUpdateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCertificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 CertificateSubjectMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCertificateSubjectMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMappingInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(CertificateSubjectMappingInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMappingInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEventDefinitionForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEventDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 EventDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(EventDefinitionInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFormationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 FormationConstraintUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg1, err = ec.unmarshalNFormationConstraintUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraintUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFormationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 FormationTemplateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNFormationTemplateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(FormationTemplateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateIntegrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 IntegrationSystemInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNIntegrationSystemInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystemInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(IntegrationSystemInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystemInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLabelDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 LabelDefinitionInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNLabelDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinitionInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(LabelDefinitionInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinitionInput`, tmp))
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRuntimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 RuntimeContextInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeContextInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContextInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeContextInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContextInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 RuntimeUpdateInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNRuntimeUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeUpdateInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(RuntimeUpdateInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeUpdateInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSystemAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	var arg1 AuthInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg1, err = ec.unmarshalNAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 BusinessTenantMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg1, err = ec.unmarshalNBusinessTenantMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBusinessTenantMappingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateWebhook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["webhookID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["webhookID"] = arg0
	var arg1 WebhookInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(WebhookInput); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.WebhookInput`, tmp))
		}
	}
	args["in"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_writeTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 BusinessTenantMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalNBusinessTenantMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBusinessTenantMappingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_writeTenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*BusinessTenantMappingInput
	if tmp, ok := rawArgs["in"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("in"))
		arg0, err = ec.unmarshalOBusinessTenantMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBusinessTenantMappingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["in"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_apisForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_applicationByLocalTenantIDAndAppTemplateID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["localTenantID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["localTenantID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["applicationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationTemplateID"))
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationTemplateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_applicationBySystemNumber_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["systemNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemNumber"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["systemNumber"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_applicationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_applicationTemplates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*LabelFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLabelFilter2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_application_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_applicationsForRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runtimeID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runtimeID"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_applications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*LabelFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLabelFilter2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_automaticScenarioAssignmentForScenario_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["scenarioName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scenarioName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scenarioName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_automaticScenarioAssignmentsForSelector_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 LabelSelectorInput
	if tmp, ok := rawArgs["selector"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selector"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNLabelSelectorInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelSelectorInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Validate == nil {
				return nil, errors.New("directive validate is not implemented")
			}
			return ec.directives.Validate(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(LabelSelectorInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelSelectorInput`, tmp))
		}
	}
	args["selector"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_automaticScenarioAssignments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_bundleByInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["authID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bundleInstanceAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_certificateSubjectMapping_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_certificateSubjectMappings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_eventsForApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["appID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["appID"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_formationByName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationConstraintsByFormationType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["formationTemplateID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formationTemplateID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["formationTemplateID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationTemplatesByName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_formationTemplates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_formation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formationsForObject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["objectID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_formations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_healthChecks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []HealthCheckType
	if tmp, ok := rawArgs["types"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
		arg0, err = ec.unmarshalOHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["types"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["origin"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("origin"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["origin"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg3, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_integrationSystem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_integrationSystems_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_labelDefinition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_rootTenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["externalTenant"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalTenant"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["externalTenant"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runtimeByTokenIssuer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["issuer"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuer"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["issuer"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runtime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runtimes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*LabelFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOLabelFilter2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_systemAuthByToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["token"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_systemAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tenantByExternalID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tenantByInternalID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tenantByLowestOwnerForResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resource"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resource"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resource"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_tenants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["searchTerm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchTerm"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["searchTerm"] = arg2
	return args, nil
}

func (ec *executionContext) field_RuntimeContext_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Runtime_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field_Runtime_runtimeContext_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Runtime_runtimeContexts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *PageCursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	return args, nil
}

func (ec *executionContext) field_Tenant_labels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["key"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["key"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _APIDefinition_id(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_name(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_description(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_spec(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.APIDefinition().Spec(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APISpec)
	fc.Result = res
	return ec.marshalOAPISpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APISpec_id(ctx, field)
			case "data":
				return ec.fieldContext_APISpec_data(ctx, field)
			case "format":
				return ec.fieldContext_APISpec_format(ctx, field)
			case "type":
				return ec.fieldContext_APISpec_type(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_APISpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APISpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_targetURL(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_targetURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_targetURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_group(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_version(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_Version_value(ctx, field)
			case "deprecated":
				return ec.fieldContext_Version_deprecated(ctx, field)
			case "deprecatedSince":
				return ec.fieldContext_Version_deprecatedSince(ctx, field)
			case "forRemoval":
				return ec.fieldContext_Version_forRemoval(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_created_at(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_updated_at(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_deleted_at(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinition_error(ctx context.Context, field graphql.CollectedField, obj *APIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinition_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinition_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinitionPage_data(ctx context.Context, field graphql.CollectedField, obj *APIDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinitionPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinitionPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *APIDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinitionPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *APIDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIDefinitionPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_id(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_data(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CLOB)
	fc.Result = res
	return ec.marshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CLOB does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_format(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SpecFormat)
	fc.Result = res
	return ec.marshalNSpecFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSpecFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SpecFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_type(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(APISpecType)
	fc.Result = res
	return ec.marshalNAPISpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpecType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type APISpecType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APISpec_fetchRequest(ctx context.Context, field graphql.CollectedField, obj *APISpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APISpec_fetchRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.APISpec().FetchRequest(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.api_spec.fetch_request")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FetchRequest); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FetchRequest`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FetchRequest)
	fc.Result = res
	return ec.marshalOFetchRequest2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APISpec_fetchRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APISpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FetchRequest_url(ctx, field)
			case "auth":
				return ec.fieldContext_FetchRequest_auth(ctx, field)
			case "mode":
				return ec.fieldContext_FetchRequest_mode(ctx, field)
			case "filter":
				return ec.fieldContext_FetchRequest_filter(ctx, field)
			case "status":
				return ec.fieldContext_FetchRequest_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_id(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_auth(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application.auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_type(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SystemAuthReferenceType)
	fc.Result = res
	return ec.marshalOSystemAuthReferenceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuthReferenceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SystemAuthReferenceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AppSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField, obj *AppSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AppSystemAuth_referenceObjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReferenceObjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AppSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AppSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_id(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_name(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_systemNumber(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_systemNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_systemNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_localTenantID(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_localTenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocalTenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_localTenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_baseUrl(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_providerName(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_providerName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_providerName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_description(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_integrationSystemID(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_integrationSystemID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntegrationSystemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_integrationSystemID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_applicationTemplateID(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_applicationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_applicationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_applicationTemplate(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_applicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Application().ApplicationTemplate(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application.application_template")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalOApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_applicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_labels(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_status(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationStatus)
	fc.Result = res
	return ec.marshalNApplicationStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_ApplicationStatus_condition(ctx, field)
			case "timestamp":
				return ec.fieldContext_ApplicationStatus_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_webhooks(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Application().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_healthCheckURL(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_healthCheckURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthCheckURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_healthCheckURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_bundles(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_bundles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Bundles(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BundlePage)
	fc.Result = res
	return ec.marshalOBundlePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundlePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_bundles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_BundlePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BundlePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BundlePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundlePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_bundles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_bundle(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_bundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Bundle(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalOBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_bundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_bundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_apiDefinition(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_apiDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().APIDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalOAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_apiDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_apiDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_eventDefinition(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_eventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().EventDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalOEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_eventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_eventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_integrationDependencies(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_integrationDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().IntegrationDependencies(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IntegrationDependencyPage)
	fc.Result = res
	return ec.marshalOIntegrationDependencyPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependencyPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_integrationDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_IntegrationDependencyPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_IntegrationDependencyPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_IntegrationDependencyPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependencyPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Application_integrationDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Application_auths(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_auths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().Auths(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AppSystemAuth)
	fc.Result = res
	return ec.marshalOAppSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAppSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_auths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AppSystemAuth_id(ctx, field)
			case "auth":
				return ec.fieldContext_AppSystemAuth_auth(ctx, field)
			case "type":
				return ec.fieldContext_AppSystemAuth_type(ctx, field)
			case "tenantId":
				return ec.fieldContext_AppSystemAuth_tenantId(ctx, field)
			case "referenceObjectId":
				return ec.fieldContext_AppSystemAuth_referenceObjectId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AppSystemAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_eventingConfiguration(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_eventingConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Application().EventingConfiguration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationEventingConfiguration)
	fc.Result = res
	return ec.marshalOApplicationEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_eventingConfiguration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEventingConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_applicationNamespace(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_applicationNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_applicationNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_createdAt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_deletedAt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_systemStatus(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_systemStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_systemStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_error(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField, obj *ApplicationEventingConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationEventingConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPage_data(ctx context.Context, field graphql.CollectedField, obj *ApplicationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ApplicationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *ApplicationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationStatus_condition(ctx context.Context, field graphql.CollectedField, obj *ApplicationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationStatusCondition)
	fc.Result = res
	return ec.marshalNApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *ApplicationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_id(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_name(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_description(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_webhooks(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.ApplicationTemplate().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.application_template.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_applicationInput(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_applicationInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_placeholders(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Placeholders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*PlaceholderDefinition)
	fc.Result = res
	return ec.marshalNPlaceholderDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_placeholders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_PlaceholderDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_PlaceholderDefinition_description(ctx, field)
			case "jsonPath":
				return ec.fieldContext_PlaceholderDefinition_jsonPath(ctx, field)
			case "optional":
				return ec.fieldContext_PlaceholderDefinition_optional(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaceholderDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_labels(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationTemplate().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationTemplate_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_accessLevel(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ApplicationTemplateAccessLevel)
	fc.Result = res
	return ec.marshalNApplicationTemplateAccessLevel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateAccessLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_accessLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ApplicationTemplateAccessLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_applicationNamespace(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_applicationNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_createdAt(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplate_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplate_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplatePage_data(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplatePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplatePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplatePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *ApplicationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationTemplatePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_id(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_name(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_description(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_mandatory(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_mandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_mandatory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_apiResources(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_apiResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIResources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AspectAPIDefinition)
	fc.Result = res
	return ec.marshalOAspectAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_apiResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ordID":
				return ec.fieldContext_AspectAPIDefinition_ordID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AspectAPIDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_eventResources(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_eventResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventResources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AspectEventDefinition)
	fc.Result = res
	return ec.marshalOAspectEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_eventResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ordID":
				return ec.fieldContext_AspectEventDefinition_ordID(ctx, field)
			case "subset":
				return ec.fieldContext_AspectEventDefinition_subset(ctx, field)
			case "created_at":
				return ec.fieldContext_AspectEventDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_AspectEventDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_AspectEventDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_AspectEventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AspectEventDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_created_at(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_updated_at(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_deleted_at(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Aspect_error(ctx context.Context, field graphql.CollectedField, obj *Aspect) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Aspect_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Aspect_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Aspect",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectAPIDefinition_ordID(ctx context.Context, field graphql.CollectedField, obj *AspectAPIDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectAPIDefinition_ordID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectAPIDefinition_ordID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectAPIDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_ordID(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_ordID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_ordID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_subset(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_subset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*AspectEventDefinitionSubset)
	fc.Result = res
	return ec.marshalOAspectEventDefinitionSubset2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_subset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventType":
				return ec.fieldContext_AspectEventDefinitionSubset_eventType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AspectEventDefinitionSubset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_created_at(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_updated_at(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_deleted_at(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinition_error(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinition_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinition_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AspectEventDefinitionSubset_eventType(ctx context.Context, field graphql.CollectedField, obj *AspectEventDefinitionSubset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AspectEventDefinitionSubset_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AspectEventDefinitionSubset_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AspectEventDefinitionSubset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_credential(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_credential(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Credential, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(CredentialData)
	fc.Result = res
	return ec.marshalOCredentialData2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_credential(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialData does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_accessStrategy(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_accessStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessStrategy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_accessStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalHeaders(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalHeaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeaders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(HTTPHeaders)
	fc.Result = res
	return ec.marshalOHttpHeaders2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeaders(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalHeaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeaders does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeadersSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HTTPHeadersSerialized)
	fc.Result = res
	return ec.marshalOHttpHeadersSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeadersSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeadersSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalQueryParams(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalQueryParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(QueryParams)
	fc.Result = res
	return ec.marshalOQueryParams2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalQueryParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParams does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParamsSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*QueryParamsSerialized)
	fc.Result = res
	return ec.marshalOQueryParamsSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParamsSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParamsSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_requestAuth(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_requestAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestAuth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CredentialRequestAuth)
	fc.Result = res
	return ec.marshalOCredentialRequestAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialRequestAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_requestAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "csrf":
				return ec.fieldContext_CredentialRequestAuth_csrf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialRequestAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_oneTimeToken(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_oneTimeToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OneTimeToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(OneTimeToken)
	fc.Result = res
	return ec.marshalOOneTimeToken2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_oneTimeToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Auth_certCommonName(ctx context.Context, field graphql.CollectedField, obj *Auth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Auth_certCommonName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CertCommonName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Auth_certCommonName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Auth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignment_scenarioName(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScenarioName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignment_scenarioName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignment_selector(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignment_selector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignmentPage_data(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignmentPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AutomaticScenarioAssignment)
	fc.Result = res
	return ec.marshalNAutomaticScenarioAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignmentPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenarioName":
				return ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
			case "selector":
				return ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignmentPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AutomaticScenarioAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *AutomaticScenarioAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AutomaticScenarioAssignmentPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AutomaticScenarioAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AutomaticScenarioAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BasicCredentialData_username(ctx context.Context, field graphql.CollectedField, obj *BasicCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BasicCredentialData_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BasicCredentialData_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BasicCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BasicCredentialData_password(ctx context.Context, field graphql.CollectedField, obj *BasicCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BasicCredentialData_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BasicCredentialData_password(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BasicCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_id(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_name(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_description(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_instanceAuthRequestInputSchema(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceAuthRequestInputSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSONSchema)
	fc.Result = res
	return ec.marshalOJSONSchema2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSONSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_instanceAuthRequestInputSchema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSONSchema does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_instanceAuth(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_instanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Bundle().InstanceAuth(rctx, obj, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.bundle.instance_auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalOBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_instanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_instanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_instanceAuths(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_instanceAuths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Bundle().InstanceAuths(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.bundle.instance_auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalOBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_instanceAuths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_defaultInstanceAuth(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DefaultInstanceAuth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.bundle.default_instance_auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_defaultInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_apiDefinitions(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_apiDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().APIDefinitions(rctx, obj, fc.Args["group"].(*string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinitionPage)
	fc.Result = res
	return ec.marshalOAPIDefinitionPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_apiDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_APIDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_APIDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_APIDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_apiDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_eventDefinitions(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_eventDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().EventDefinitions(rctx, obj, fc.Args["group"].(*string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinitionPage)
	fc.Result = res
	return ec.marshalOEventDefinitionPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_eventDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_EventDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_eventDefinitions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_documents(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_documents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().Documents(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DocumentPage)
	fc.Result = res
	return ec.marshalODocumentPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_documents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_DocumentPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DocumentPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_DocumentPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_documents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_apiDefinition(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_apiDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().APIDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalOAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_apiDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_apiDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_eventDefinition(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_eventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().EventDefinition(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalOEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_eventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_eventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_correlationIDs(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_correlationIDs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorrelationIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_correlationIDs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_document(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_document(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Bundle().Document(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Document)
	fc.Result = res
	return ec.marshalODocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_document(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Bundle_document_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_createdAt(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_deletedAt(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bundle_error(ctx context.Context, field graphql.CollectedField, obj *Bundle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bundle_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bundle_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bundle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_id(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_context(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_context(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	fc.Result = res
	return ec.marshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_context(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_inputParams(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSON)
	fc.Result = res
	return ec.marshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_inputParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_auth(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Auth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_status(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuthStatus)
	fc.Result = res
	return ec.marshalNBundleInstanceAuthStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_BundleInstanceAuthStatus_condition(ctx, field)
			case "timestamp":
				return ec.fieldContext_BundleInstanceAuthStatus_timestamp(ctx, field)
			case "message":
				return ec.fieldContext_BundleInstanceAuthStatus_message(ctx, field)
			case "reason":
				return ec.fieldContext_BundleInstanceAuthStatus_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuthStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_runtimeID(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_runtimeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuth_runtimeContextID(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeContextID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuth_runtimeContextID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_condition(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BundleInstanceAuthStatusCondition)
	fc.Result = res
	return ec.marshalNBundleInstanceAuthStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BundleInstanceAuthStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_message(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundleInstanceAuthStatus_reason(ctx context.Context, field graphql.CollectedField, obj *BundleInstanceAuthStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundleInstanceAuthStatus_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundleInstanceAuthStatus_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundleInstanceAuthStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundlePage_data(ctx context.Context, field graphql.CollectedField, obj *BundlePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundlePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Bundle)
	fc.Result = res
	return ec.marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundlePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundlePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundlePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *BundlePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundlePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundlePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundlePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BundlePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *BundlePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BundlePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BundlePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BundlePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_credential(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_credential(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Credential, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(CredentialData)
	fc.Result = res
	return ec.marshalOCredentialData2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_credential(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CredentialData does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalHeaders(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeaders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(HTTPHeaders)
	fc.Result = res
	return ec.marshalOHttpHeaders2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeaders(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalHeaders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeaders does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHeadersSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HTTPHeadersSerialized)
	fc.Result = res
	return ec.marshalOHttpHeadersSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeadersSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HttpHeadersSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(QueryParams)
	fc.Result = res
	return ec.marshalOQueryParams2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParams does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField, obj *CSRFTokenCredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalQueryParamsSerialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*QueryParamsSerialized)
	fc.Result = res
	return ec.marshalOQueryParamsSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParamsSerialized(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CSRFTokenCredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type QueryParamsSerialized does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateOAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField, obj *CertificateOAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateOAuthCredentialData_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateOAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateOAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateOAuthCredentialData_certificate(ctx context.Context, field graphql.CollectedField, obj *CertificateOAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateOAuthCredentialData_certificate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Certificate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateOAuthCredentialData_certificate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateOAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateOAuthCredentialData_url(ctx context.Context, field graphql.CollectedField, obj *CertificateOAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateOAuthCredentialData_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateOAuthCredentialData_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateOAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_id(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_subject(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_consumerType(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsumerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_consumerType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_internalConsumerID(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InternalConsumerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_internalConsumerID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMapping_tenantAccessLevels(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMapping) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantAccessLevels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMappingPage_data(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMappingPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMappingPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalNCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMappingPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMappingPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMappingPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMappingPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMappingPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMappingPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMappingPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CertificateSubjectMappingPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *CertificateSubjectMappingPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CertificateSubjectMappingPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CertificateSubjectMappingPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CertificateSubjectMappingPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConstraintReference_constraintID(ctx context.Context, field graphql.CollectedField, obj *ConstraintReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConstraintReference_constraintID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConstraintID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConstraintReference_constraintID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConstraintReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConstraintReference_formationTemplateID(ctx context.Context, field graphql.CollectedField, obj *ConstraintReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConstraintReference_formationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConstraintReference_formationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConstraintReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialRequestAuth_csrf(ctx context.Context, field graphql.CollectedField, obj *CredentialRequestAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialRequestAuth_csrf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csrf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CSRFTokenCredentialRequestAuth)
	fc.Result = res
	return ec.marshalOCSRFTokenCredentialRequestAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCSRFTokenCredentialRequestAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialRequestAuth_csrf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialRequestAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tokenEndpointURL":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx, field)
			case "credential":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_credential(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CSRFTokenCredentialRequestAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_id(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_title(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_displayName(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_description(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_format(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DocumentFormat)
	fc.Result = res
	return ec.marshalNDocumentFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DocumentFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_kind(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_data(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CLOB)
	fc.Result = res
	return ec.marshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CLOB does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_fetchRequest(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_fetchRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Document().FetchRequest(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.document.fetch_request")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FetchRequest); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FetchRequest`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FetchRequest)
	fc.Result = res
	return ec.marshalOFetchRequest2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_fetchRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FetchRequest_url(ctx, field)
			case "auth":
				return ec.fieldContext_FetchRequest_auth(ctx, field)
			case "mode":
				return ec.fieldContext_FetchRequest_mode(ctx, field)
			case "filter":
				return ec.fieldContext_FetchRequest_filter(ctx, field)
			case "status":
				return ec.fieldContext_FetchRequest_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_createdAt(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_deletedAt(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_error(ctx context.Context, field graphql.CollectedField, obj *Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentPage_data(ctx context.Context, field graphql.CollectedField, obj *DocumentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Document)
	fc.Result = res
	return ec.marshalNDocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *DocumentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *DocumentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_id(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_name(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_description(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_group(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_spec(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EventDefinition().Spec(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventSpec)
	fc.Result = res
	return ec.marshalOEventSpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventSpec_id(ctx, field)
			case "data":
				return ec.fieldContext_EventSpec_data(ctx, field)
			case "type":
				return ec.fieldContext_EventSpec_type(ctx, field)
			case "format":
				return ec.fieldContext_EventSpec_format(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_EventSpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_version(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_Version_value(ctx, field)
			case "deprecated":
				return ec.fieldContext_Version_deprecated(ctx, field)
			case "deprecatedSince":
				return ec.fieldContext_Version_deprecatedSince(ctx, field)
			case "forRemoval":
				return ec.fieldContext_Version_forRemoval(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_createdAt(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_updatedAt(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_deletedAt(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinition_error(ctx context.Context, field graphql.CollectedField, obj *EventDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinition_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinition_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinitionPage_data(ctx context.Context, field graphql.CollectedField, obj *EventDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinitionPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinitionPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *EventDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinitionPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinitionPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *EventDefinitionPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventDefinitionPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventDefinitionPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventDefinitionPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_id(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_data(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CLOB)
	fc.Result = res
	return ec.marshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CLOB does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_type(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(EventSpecType)
	fc.Result = res
	return ec.marshalNEventSpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpecType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventSpecType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_format(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SpecFormat)
	fc.Result = res
	return ec.marshalNSpecFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSpecFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SpecFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventSpec_fetchRequest(ctx context.Context, field graphql.CollectedField, obj *EventSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventSpec_fetchRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EventSpec().FetchRequest(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.event_spec.fetch_request")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FetchRequest); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FetchRequest`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FetchRequest)
	fc.Result = res
	return ec.marshalOFetchRequest2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventSpec_fetchRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventSpec",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FetchRequest_url(ctx, field)
			case "auth":
				return ec.fieldContext_FetchRequest_auth(ctx, field)
			case "mode":
				return ec.fieldContext_FetchRequest_mode(ctx, field)
			case "filter":
				return ec.fieldContext_FetchRequest_filter(ctx, field)
			case "status":
				return ec.fieldContext_FetchRequest_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_url(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_auth(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.fetch_request.auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_mode(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FetchMode)
	fc.Result = res
	return ec.marshalNFetchMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FetchMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_filter(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_filter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_filter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequest_status(ctx context.Context, field graphql.CollectedField, obj *FetchRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequest_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FetchRequestStatus)
	fc.Result = res
	return ec.marshalNFetchRequestStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequest_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_FetchRequestStatus_condition(ctx, field)
			case "message":
				return ec.fieldContext_FetchRequestStatus_message(ctx, field)
			case "timestamp":
				return ec.fieldContext_FetchRequestStatus_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FetchRequestStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequestStatus_condition(ctx context.Context, field graphql.CollectedField, obj *FetchRequestStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequestStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FetchRequestStatusCondition)
	fc.Result = res
	return ec.marshalNFetchRequestStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequestStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequestStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FetchRequestStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequestStatus_message(ctx context.Context, field graphql.CollectedField, obj *FetchRequestStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequestStatus_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequestStatus_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequestStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FetchRequestStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *FetchRequestStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FetchRequestStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FetchRequestStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FetchRequestStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_id(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_name(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_formationTemplateId(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_formationTemplateId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_formationTemplateId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_tenantID(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_tenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TenantID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.formation.tenant_id")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_tenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_state(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_error(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(FormationError)
	fc.Result = res
	return ec.marshalOFormationError2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_FormationError_message(ctx, field)
			case "errorCode":
				return ec.fieldContext_FormationError_errorCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_formationAssignment(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_formationAssignment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Formation().FormationAssignment(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationAssignment)
	fc.Result = res
	return ec.marshalOFormationAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_formationAssignment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationAssignment_id(ctx, field)
			case "source":
				return ec.fieldContext_FormationAssignment_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_FormationAssignment_sourceType(ctx, field)
			case "sourceEntity":
				return ec.fieldContext_FormationAssignment_sourceEntity(ctx, field)
			case "target":
				return ec.fieldContext_FormationAssignment_target(ctx, field)
			case "targetType":
				return ec.fieldContext_FormationAssignment_targetType(ctx, field)
			case "targetEntity":
				return ec.fieldContext_FormationAssignment_targetEntity(ctx, field)
			case "state":
				return ec.fieldContext_FormationAssignment_state(ctx, field)
			case "value":
				return ec.fieldContext_FormationAssignment_value(ctx, field)
			case "configuration":
				return ec.fieldContext_FormationAssignment_configuration(ctx, field)
			case "error":
				return ec.fieldContext_FormationAssignment_error(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationAssignment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Formation_formationAssignment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Formation_formationAssignments(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_formationAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Formation().FormationAssignments(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationAssignmentPage)
	fc.Result = res
	return ec.marshalOFormationAssignmentPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignmentPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_formationAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationAssignmentPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationAssignmentPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationAssignmentPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationAssignmentPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Formation_formationAssignments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Formation_status(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Formation().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationStatus)
	fc.Result = res
	return ec.marshalNFormationStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_FormationStatus_condition(ctx, field)
			case "errors":
				return ec.fieldContext_FormationStatus_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastStateChangeTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Formation_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField, obj *Formation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastNotificationSentTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Formation_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Formation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_id(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_source(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_sourceType(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_sourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FormationAssignmentType)
	fc.Result = res
	return ec.marshalNFormationAssignmentType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignmentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_sourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationAssignmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_sourceEntity(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_sourceEntity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FormationAssignment().SourceEntity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(FormationParticipant)
	fc.Result = res
	return ec.marshalOFormationParticipant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationParticipant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_sourceEntity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationParticipant does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_target(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_target(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_targetType(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_targetType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FormationAssignmentType)
	fc.Result = res
	return ec.marshalNFormationAssignmentType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignmentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_targetType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationAssignmentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_targetEntity(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_targetEntity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FormationAssignment().TargetEntity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(FormationParticipant)
	fc.Result = res
	return ec.marshalOFormationParticipant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationParticipant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_targetEntity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationParticipant does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_state(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_value(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_configuration(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_configuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_configuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_error(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastStateChangeTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignment_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField, obj *FormationAssignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastNotificationSentTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignmentPage_data(ctx context.Context, field graphql.CollectedField, obj *FormationAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignmentPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationAssignment)
	fc.Result = res
	return ec.marshalNFormationAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignmentPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationAssignment_id(ctx, field)
			case "source":
				return ec.fieldContext_FormationAssignment_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_FormationAssignment_sourceType(ctx, field)
			case "sourceEntity":
				return ec.fieldContext_FormationAssignment_sourceEntity(ctx, field)
			case "target":
				return ec.fieldContext_FormationAssignment_target(ctx, field)
			case "targetType":
				return ec.fieldContext_FormationAssignment_targetType(ctx, field)
			case "targetEntity":
				return ec.fieldContext_FormationAssignment_targetEntity(ctx, field)
			case "state":
				return ec.fieldContext_FormationAssignment_state(ctx, field)
			case "value":
				return ec.fieldContext_FormationAssignment_value(ctx, field)
			case "configuration":
				return ec.fieldContext_FormationAssignment_configuration(ctx, field)
			case "error":
				return ec.fieldContext_FormationAssignment_error(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_FormationAssignment_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_FormationAssignment_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationAssignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *FormationAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignmentPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignmentPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *FormationAssignmentPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationAssignmentPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationAssignmentPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationAssignmentPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_id(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_name(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_description(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_constraintType(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_constraintType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConstraintType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_constraintType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_targetOperation(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetOperation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_targetOperation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_operator(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_resourceType(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_resourceSubtype(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceSubtype, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_resourceSubtype(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_inputTemplate(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_inputTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_constraintScope(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConstraintScope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_constraintScope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_priority(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationConstraint_createdAt(ctx context.Context, field graphql.CollectedField, obj *FormationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationConstraint_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationConstraint_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationError_message(ctx context.Context, field graphql.CollectedField, obj *FormationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationError_errorCode(ctx context.Context, field graphql.CollectedField, obj *FormationError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationError_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationError_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationPage_data(ctx context.Context, field graphql.CollectedField, obj *FormationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *FormationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *FormationPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatus_condition(ctx context.Context, field graphql.CollectedField, obj *FormationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FormationStatusCondition)
	fc.Result = res
	return ec.marshalNFormationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FormationStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatus_errors(ctx context.Context, field graphql.CollectedField, obj *FormationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatus_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FormationStatusError)
	fc.Result = res
	return ec.marshalOFormationStatusError2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatusError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatus_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentID":
				return ec.fieldContext_FormationStatusError_assignmentID(ctx, field)
			case "message":
				return ec.fieldContext_FormationStatusError_message(ctx, field)
			case "errorCode":
				return ec.fieldContext_FormationStatusError_errorCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationStatusError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatusError_assignmentID(ctx context.Context, field graphql.CollectedField, obj *FormationStatusError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatusError_assignmentID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatusError_assignmentID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatusError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatusError_message(ctx context.Context, field graphql.CollectedField, obj *FormationStatusError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatusError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatusError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatusError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationStatusError_errorCode(ctx context.Context, field graphql.CollectedField, obj *FormationStatusError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationStatusError_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationStatusError_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationStatusError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_id(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_name(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_applicationTypes(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_applicationTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_runtimeTypes(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_runtimeTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_runtimeTypeDisplayName(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeTypeDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_runtimeArtifactKind(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeArtifactKind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ArtifactType)
	fc.Result = res
	return ec.marshalOArtifactType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlArtifactType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_runtimeArtifactKind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArtifactType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_webhooks(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.FormationTemplate().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.formation_template.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_leadingProductIDs(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LeadingProductIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_leadingProductIDs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_formationConstraints(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FormationTemplate().FormationConstraints(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FormationConstraint)
	fc.Result = res
	return ec.marshalOFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_formationConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_supportsReset(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportsReset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_supportsReset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplate_discoveryConsumers(ctx context.Context, field graphql.CollectedField, obj *FormationTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscoveryConsumers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplate_discoveryConsumers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplatePage_data(ctx context.Context, field graphql.CollectedField, obj *FormationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplatePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationTemplate)
	fc.Result = res
	return ec.marshalNFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplatePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *FormationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplatePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplatePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FormationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *FormationTemplatePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FormationTemplatePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FormationTemplatePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FormationTemplatePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_type(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(HealthCheckType)
	fc.Result = res
	return ec.marshalNHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HealthCheckType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_condition(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(HealthCheckStatusCondition)
	fc.Result = res
	return ec.marshalNHealthCheckStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HealthCheckStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_origin(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_origin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_origin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_message(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheck_timestamp(ctx context.Context, field graphql.CollectedField, obj *HealthCheck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheck_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheck_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckPage_data(ctx context.Context, field graphql.CollectedField, obj *HealthCheckPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*HealthCheck)
	fc.Result = res
	return ec.marshalNHealthCheck2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheck(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_HealthCheck_type(ctx, field)
			case "condition":
				return ec.fieldContext_HealthCheck_condition(ctx, field)
			case "origin":
				return ec.fieldContext_HealthCheck_origin(ctx, field)
			case "message":
				return ec.fieldContext_HealthCheck_message(ctx, field)
			case "timestamp":
				return ec.fieldContext_HealthCheck_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheck", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *HealthCheckPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HealthCheckPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *HealthCheckPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HealthCheckPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HealthCheckPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HealthCheckPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_id(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_auth(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.integration_system.auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_type(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SystemAuthReferenceType)
	fc.Result = res
	return ec.marshalOSystemAuthReferenceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuthReferenceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SystemAuthReferenceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntSysSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField, obj *IntSysSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntSysSystemAuth_referenceObjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReferenceObjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntSysSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntSysSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_id(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_name(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_description(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_ordID(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_ordID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_ordID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_partOfPackage(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartOfPackage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_partOfPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_visibility(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_releaseStatus(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleaseStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_releaseStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_mandatory(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_mandatory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_aspects(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_aspects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aspects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Aspect)
	fc.Result = res
	return ec.marshalOAspect2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspect(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_aspects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Aspect_id(ctx, field)
			case "name":
				return ec.fieldContext_Aspect_name(ctx, field)
			case "description":
				return ec.fieldContext_Aspect_description(ctx, field)
			case "mandatory":
				return ec.fieldContext_Aspect_mandatory(ctx, field)
			case "apiResources":
				return ec.fieldContext_Aspect_apiResources(ctx, field)
			case "eventResources":
				return ec.fieldContext_Aspect_eventResources(ctx, field)
			case "created_at":
				return ec.fieldContext_Aspect_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_Aspect_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_Aspect_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_Aspect_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Aspect", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_version(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_Version_value(ctx, field)
			case "deprecated":
				return ec.fieldContext_Version_deprecated(ctx, field)
			case "deprecatedSince":
				return ec.fieldContext_Version_deprecatedSince(ctx, field)
			case "forRemoval":
				return ec.fieldContext_Version_forRemoval(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_labels(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Labels)
	fc.Result = res
	return ec.marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_created_at(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_updated_at(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_deleted_at(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_deleted_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependency_error(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependency_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependency_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependencyPage_data(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependencyPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependencyPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*IntegrationDependency)
	fc.Result = res
	return ec.marshalNIntegrationDependency2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependencyPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependencyPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationDependency_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationDependency_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationDependency_description(ctx, field)
			case "ordID":
				return ec.fieldContext_IntegrationDependency_ordID(ctx, field)
			case "partOfPackage":
				return ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
			case "visibility":
				return ec.fieldContext_IntegrationDependency_visibility(ctx, field)
			case "releaseStatus":
				return ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
			case "mandatory":
				return ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
			case "aspects":
				return ec.fieldContext_IntegrationDependency_aspects(ctx, field)
			case "version":
				return ec.fieldContext_IntegrationDependency_version(ctx, field)
			case "labels":
				return ec.fieldContext_IntegrationDependency_labels(ctx, field)
			case "created_at":
				return ec.fieldContext_IntegrationDependency_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_IntegrationDependency_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependencyPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependencyPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependencyPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependencyPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependencyPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDependencyPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *IntegrationDependencyPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDependencyPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDependencyPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDependencyPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_id(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_name(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_description(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystem_auths(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystem_auths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IntegrationSystem().Auths(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*IntSysSystemAuth)
	fc.Result = res
	return ec.marshalOIntSysSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntSysSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystem_auths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystem",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntSysSystemAuth_id(ctx, field)
			case "auth":
				return ec.fieldContext_IntSysSystemAuth_auth(ctx, field)
			case "type":
				return ec.fieldContext_IntSysSystemAuth_type(ctx, field)
			case "tenantId":
				return ec.fieldContext_IntSysSystemAuth_tenantId(ctx, field)
			case "referenceObjectId":
				return ec.fieldContext_IntSysSystemAuth_referenceObjectId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntSysSystemAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystemPage_data(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystemPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystemPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystemPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystemPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystemPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystemPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystemPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystemPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystemPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationSystemPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *IntegrationSystemPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationSystemPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationSystemPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationSystemPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_key(ctx context.Context, field graphql.CollectedField, obj *Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Label_value(ctx context.Context, field graphql.CollectedField, obj *Label) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Label_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalNAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Label_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Label",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelDefinition_key(ctx context.Context, field graphql.CollectedField, obj *LabelDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelDefinition_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelDefinition_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelDefinition_schema(ctx context.Context, field graphql.CollectedField, obj *LabelDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelDefinition_schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*JSONSchema)
	fc.Result = res
	return ec.marshalOJSONSchema2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSONSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelDefinition_schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSONSchema does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterApplication(rctx, fc.Args["in"].(ApplicationRegisterInput), fc.Args["mode"].(*OperationMode))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationType(ctx, "CREATE")
			if err != nil {
				return nil, err
			}
			webhookType, err := ec.unmarshalOWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx, "REGISTER_APPLICATION")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, webhookType, nil)
		}
		directive3 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventType(ctx, "NEW_APPLICATION")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive2, eventType)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateApplication(rctx, fc.Args["id"].(string), fc.Args["in"].(ApplicationUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationType(ctx, "UPDATE")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalOString2string(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, nil, idField)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterApplication(rctx, fc.Args["id"].(string), fc.Args["mode"].(*OperationMode))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationType(ctx, "DELETE")
			if err != nil {
				return nil, err
			}
			webhookType, err := ec.unmarshalOWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx, "UNREGISTER_APPLICATION")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalOString2string(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, webhookType, idField)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unpairApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unpairApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnpairApplication(rctx, fc.Args["id"].(string), fc.Args["mode"].(*OperationMode))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unpairApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			operationType, err := ec.unmarshalNOperationType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationType(ctx, "UPDATE")
			if err != nil {
				return nil, err
			}
			webhookType, err := ec.unmarshalOWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx, "UNREGISTER_APPLICATION")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalOString2string(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.Async == nil {
				return nil, errors.New("directive async is not implemented")
			}
			return ec.directives.Async(ctx, nil, directive1, operationType, webhookType, idField)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unpairApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unpairApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createApplicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createApplicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateApplicationTemplate(rctx, fc.Args["in"].(ApplicationTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createApplicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createApplicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createApplicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerApplicationFromTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerApplicationFromTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterApplicationFromTemplate(rctx, fc.Args["in"].(ApplicationFromTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerApplicationFromTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventType(ctx, "NEW_APPLICATION")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive1, eventType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerApplicationFromTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerApplicationFromTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateApplicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateApplicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateApplicationTemplate(rctx, fc.Args["id"].(string), fc.Args["override"].(*bool), fc.Args["in"].(ApplicationTemplateUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateApplicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateApplicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateApplicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApplicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApplicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteApplicationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteApplicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApplicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApplicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_mergeApplications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_mergeApplications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MergeApplications(rctx, fc.Args["destinationID"].(string), fc.Args["sourceID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.mergeApplications")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_mergeApplications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_mergeApplications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterRuntime(rctx, fc.Args["in"].(RuntimeRegisterInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRuntime(rctx, fc.Args["id"].(string), fc.Args["in"].(RuntimeUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterRuntime(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerRuntimeContext(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerRuntimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterRuntimeContext(rctx, fc.Args["runtimeID"].(string), fc.Args["in"].(RuntimeContextInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerRuntimeContext")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimeContext); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContext`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerRuntimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerRuntimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRuntimeContext(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRuntimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateRuntimeContext(rctx, fc.Args["id"].(string), fc.Args["in"].(RuntimeContextInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateRuntimeContext")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimeContext); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContext`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRuntimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRuntimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterRuntimeContext(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterRuntimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterRuntimeContext(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterRuntimeContext")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimeContext); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimeContext`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterRuntimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterRuntimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterIntegrationSystem(rctx, fc.Args["in"].(IntegrationSystemInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.registerIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateIntegrationSystem(rctx, fc.Args["id"].(string), fc.Args["in"].(IntegrationSystemInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterIntegrationSystem(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unregisterIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddWebhook(rctx, fc.Args["applicationID"].(*string), fc.Args["applicationTemplateID"].(*string), fc.Args["runtimeID"].(*string), fc.Args["formationTemplateID"].(*string), fc.Args["in"].(WebhookInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addWebhook")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Webhook)
	fc.Result = res
	return ec.marshalNWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateWebhook(rctx, fc.Args["webhookID"].(string), fc.Args["in"].(WebhookInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateWebhook")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Webhook)
	fc.Result = res
	return ec.marshalNWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteWebhook(rctx, fc.Args["webhookID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteWebhook")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Webhook)
	fc.Result = res
	return ec.marshalNWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAPIDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addAPIDefinitionToBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddAPIDefinitionToBundle(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addAPIDefinitionToBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addAPIDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAPIDefinitionToBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAPIDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addAPIDefinitionToApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddAPIDefinitionToApplication(rctx, fc.Args["appID"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addAPIDefinitionToApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addAPIDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAPIDefinitionToApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAPIDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAPIDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAPIDefinition(rctx, fc.Args["id"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateAPIDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAPIDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAPIDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAPIDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAPIDefinitionForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAPIDefinitionForApplication(rctx, fc.Args["id"].(string), fc.Args["in"].(APIDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateAPIDefinitionForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAPIDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAPIDefinitionForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAPIDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAPIDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteAPIDefinition(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteAPIDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APIDefinition)
	fc.Result = res
	return ec.marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAPIDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APIDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_APIDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_APIDefinition_description(ctx, field)
			case "spec":
				return ec.fieldContext_APIDefinition_spec(ctx, field)
			case "targetURL":
				return ec.fieldContext_APIDefinition_targetURL(ctx, field)
			case "group":
				return ec.fieldContext_APIDefinition_group(ctx, field)
			case "version":
				return ec.fieldContext_APIDefinition_version(ctx, field)
			case "created_at":
				return ec.fieldContext_APIDefinition_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_APIDefinition_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_APIDefinition_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_APIDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAPIDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refetchAPISpec(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refetchAPISpec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RefetchAPISpec(rctx, fc.Args["apiID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.refetchAPISpec")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APISpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APISpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*APISpec)
	fc.Result = res
	return ec.marshalNAPISpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refetchAPISpec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_APISpec_id(ctx, field)
			case "data":
				return ec.fieldContext_APISpec_data(ctx, field)
			case "format":
				return ec.fieldContext_APISpec_format(ctx, field)
			case "type":
				return ec.fieldContext_APISpec_type(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_APISpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APISpec", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refetchAPISpec_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addIntegrationDependencyToApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addIntegrationDependencyToApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddIntegrationDependencyToApplication(rctx, fc.Args["appID"].(string), fc.Args["in"].(IntegrationDependencyInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addIntegrationDependencyToApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationDependency); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationDependency`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationDependency)
	fc.Result = res
	return ec.marshalNIntegrationDependency2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addIntegrationDependencyToApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationDependency_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationDependency_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationDependency_description(ctx, field)
			case "ordID":
				return ec.fieldContext_IntegrationDependency_ordID(ctx, field)
			case "partOfPackage":
				return ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
			case "visibility":
				return ec.fieldContext_IntegrationDependency_visibility(ctx, field)
			case "releaseStatus":
				return ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
			case "mandatory":
				return ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
			case "aspects":
				return ec.fieldContext_IntegrationDependency_aspects(ctx, field)
			case "version":
				return ec.fieldContext_IntegrationDependency_version(ctx, field)
			case "labels":
				return ec.fieldContext_IntegrationDependency_labels(ctx, field)
			case "created_at":
				return ec.fieldContext_IntegrationDependency_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_IntegrationDependency_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addIntegrationDependencyToApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteIntegrationDependency(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteIntegrationDependency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteIntegrationDependency(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteIntegrationDependency")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationDependency); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationDependency`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationDependency)
	fc.Result = res
	return ec.marshalNIntegrationDependency2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteIntegrationDependency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationDependency_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationDependency_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationDependency_description(ctx, field)
			case "ordID":
				return ec.fieldContext_IntegrationDependency_ordID(ctx, field)
			case "partOfPackage":
				return ec.fieldContext_IntegrationDependency_partOfPackage(ctx, field)
			case "visibility":
				return ec.fieldContext_IntegrationDependency_visibility(ctx, field)
			case "releaseStatus":
				return ec.fieldContext_IntegrationDependency_releaseStatus(ctx, field)
			case "mandatory":
				return ec.fieldContext_IntegrationDependency_mandatory(ctx, field)
			case "aspects":
				return ec.fieldContext_IntegrationDependency_aspects(ctx, field)
			case "version":
				return ec.fieldContext_IntegrationDependency_version(ctx, field)
			case "labels":
				return ec.fieldContext_IntegrationDependency_labels(ctx, field)
			case "created_at":
				return ec.fieldContext_IntegrationDependency_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_IntegrationDependency_updated_at(ctx, field)
			case "deleted_at":
				return ec.fieldContext_IntegrationDependency_deleted_at(ctx, field)
			case "error":
				return ec.fieldContext_IntegrationDependency_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDependency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteIntegrationDependency_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestOneTimeTokenForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestOneTimeTokenForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestOneTimeTokenForRuntime(rctx, fc.Args["id"].(string), fc.Args["systemAuthID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestOneTimeTokenForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*OneTimeTokenForRuntime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.OneTimeTokenForRuntime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OneTimeTokenForRuntime)
	fc.Result = res
	return ec.marshalNOneTimeTokenForRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenForRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestOneTimeTokenForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_OneTimeTokenForRuntime_token(ctx, field)
			case "connectorURL":
				return ec.fieldContext_OneTimeTokenForRuntime_connectorURL(ctx, field)
			case "used":
				return ec.fieldContext_OneTimeTokenForRuntime_used(ctx, field)
			case "expiresAt":
				return ec.fieldContext_OneTimeTokenForRuntime_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_OneTimeTokenForRuntime_createdAt(ctx, field)
			case "usedAt":
				return ec.fieldContext_OneTimeTokenForRuntime_usedAt(ctx, field)
			case "raw":
				return ec.fieldContext_OneTimeTokenForRuntime_raw(ctx, field)
			case "rawEncoded":
				return ec.fieldContext_OneTimeTokenForRuntime_rawEncoded(ctx, field)
			case "type":
				return ec.fieldContext_OneTimeTokenForRuntime_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OneTimeTokenForRuntime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestOneTimeTokenForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestOneTimeTokenForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestOneTimeTokenForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestOneTimeTokenForApplication(rctx, fc.Args["id"].(string), fc.Args["systemAuthID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestOneTimeTokenForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*OneTimeTokenForApplication); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.OneTimeTokenForApplication`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OneTimeTokenForApplication)
	fc.Result = res
	return ec.marshalNOneTimeTokenForApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenForApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestOneTimeTokenForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_OneTimeTokenForApplication_token(ctx, field)
			case "connectorURL":
				return ec.fieldContext_OneTimeTokenForApplication_connectorURL(ctx, field)
			case "legacyConnectorURL":
				return ec.fieldContext_OneTimeTokenForApplication_legacyConnectorURL(ctx, field)
			case "used":
				return ec.fieldContext_OneTimeTokenForApplication_used(ctx, field)
			case "expiresAt":
				return ec.fieldContext_OneTimeTokenForApplication_expiresAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_OneTimeTokenForApplication_createdAt(ctx, field)
			case "usedAt":
				return ec.fieldContext_OneTimeTokenForApplication_usedAt(ctx, field)
			case "raw":
				return ec.fieldContext_OneTimeTokenForApplication_raw(ctx, field)
			case "rawEncoded":
				return ec.fieldContext_OneTimeTokenForApplication_rawEncoded(ctx, field)
			case "type":
				return ec.fieldContext_OneTimeTokenForApplication_type(ctx, field)
			case "scenarioGroups":
				return ec.fieldContext_OneTimeTokenForApplication_scenarioGroups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OneTimeTokenForApplication", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestOneTimeTokenForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestClientCredentialsForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestClientCredentialsForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestClientCredentialsForRuntime(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestClientCredentialsForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestClientCredentialsForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestClientCredentialsForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestClientCredentialsForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestClientCredentialsForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestClientCredentialsForApplication(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestClientCredentialsForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestClientCredentialsForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestClientCredentialsForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestClientCredentialsForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestClientCredentialsForIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestClientCredentialsForIntegrationSystem(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestClientCredentialsForIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestClientCredentialsForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestClientCredentialsForIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSystemAuthForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSystemAuthForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSystemAuthForRuntime(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteSystemAuthForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSystemAuthForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSystemAuthForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSystemAuthForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSystemAuthForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSystemAuthForApplication(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteSystemAuthForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSystemAuthForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSystemAuthForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSystemAuthForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSystemAuthForIntegrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSystemAuthForIntegrationSystem(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteSystemAuthForIntegrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSystemAuthForIntegrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSystemAuthForIntegrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSystemAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSystemAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSystemAuth(rctx, fc.Args["authID"].(string), fc.Args["in"].(AuthInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateSystemAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSystemAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSystemAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_invalidateSystemAuthOneTimeToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_invalidateSystemAuthOneTimeToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().InvalidateSystemAuthOneTimeToken(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.invalidateSystemAuthOneTimeToken")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_invalidateSystemAuthOneTimeToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_invalidateSystemAuthOneTimeToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addEventDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addEventDefinitionToBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddEventDefinitionToBundle(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addEventDefinitionToBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addEventDefinitionToBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addEventDefinitionToBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addEventDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addEventDefinitionToApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddEventDefinitionToApplication(rctx, fc.Args["appID"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addEventDefinitionToApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addEventDefinitionToApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addEventDefinitionToApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEventDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventDefinition(rctx, fc.Args["id"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateEventDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEventDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEventDefinitionForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEventDefinitionForApplication(rctx, fc.Args["id"].(string), fc.Args["in"].(EventDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateEventDefinitionForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEventDefinitionForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEventDefinitionForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEventDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEventDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEventDefinition(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteEventDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventDefinition)
	fc.Result = res
	return ec.marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEventDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventDefinition_id(ctx, field)
			case "name":
				return ec.fieldContext_EventDefinition_name(ctx, field)
			case "description":
				return ec.fieldContext_EventDefinition_description(ctx, field)
			case "group":
				return ec.fieldContext_EventDefinition_group(ctx, field)
			case "spec":
				return ec.fieldContext_EventDefinition_spec(ctx, field)
			case "version":
				return ec.fieldContext_EventDefinition_version(ctx, field)
			case "createdAt":
				return ec.fieldContext_EventDefinition_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_EventDefinition_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_EventDefinition_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_EventDefinition_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEventDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refetchEventDefinitionSpec(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refetchEventDefinitionSpec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RefetchEventDefinitionSpec(rctx, fc.Args["eventID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.refetchEventDefinitionSpec")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EventSpec)
	fc.Result = res
	return ec.marshalNEventSpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refetchEventDefinitionSpec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventSpec_id(ctx, field)
			case "data":
				return ec.fieldContext_EventSpec_data(ctx, field)
			case "type":
				return ec.fieldContext_EventSpec_type(ctx, field)
			case "format":
				return ec.fieldContext_EventSpec_format(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_EventSpec_fetchRequest(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventSpec", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refetchEventDefinitionSpec_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addDocumentToBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addDocumentToBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddDocumentToBundle(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(DocumentInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addDocumentToBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Document); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Document`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Document)
	fc.Result = res
	return ec.marshalNDocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addDocumentToBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addDocumentToBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDocument(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDocument(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDocument(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteDocument")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Document); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Document`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Document)
	fc.Result = res
	return ec.marshalNDocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDocument(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "title":
				return ec.fieldContext_Document_title(ctx, field)
			case "displayName":
				return ec.fieldContext_Document_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Document_description(ctx, field)
			case "format":
				return ec.fieldContext_Document_format(ctx, field)
			case "kind":
				return ec.fieldContext_Document_kind(ctx, field)
			case "data":
				return ec.fieldContext_Document_data(ctx, field)
			case "fetchRequest":
				return ec.fieldContext_Document_fetchRequest(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Document_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDocument_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateFormation(rctx, fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resynchronizeFormationNotifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resynchronizeFormationNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ResynchronizeFormationNotifications(rctx, fc.Args["formationID"].(string), fc.Args["reset"].(*bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.resynchronizeFormationNotifications")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resynchronizeFormationNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resynchronizeFormationNotifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finalizeDraftFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finalizeDraftFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FinalizeDraftFormation(rctx, fc.Args["formationID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.finalizeDraftFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finalizeDraftFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finalizeDraftFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteFormation(rctx, fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assignFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assignFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AssignFormation(rctx, fc.Args["objectID"].(string), fc.Args["objectType"].(FormationObjectType), fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.assignFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assignFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assignFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignFormation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignFormation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnassignFormation(rctx, fc.Args["objectID"].(string), fc.Args["objectType"].(FormationObjectType), fc.Args["formation"].(FormationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unassignFormation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignFormation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignFormation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignFormationGlobal(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignFormationGlobal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnassignFormationGlobal(rctx, fc.Args["objectID"].(string), fc.Args["objectType"].(FormationObjectType), fc.Args["formation"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unassignFormationGlobal")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignFormationGlobal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignFormationGlobal_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFormationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFormationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateFormationConstraint(rctx, fc.Args["formationConstraint"].(FormationConstraintInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createFormationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFormationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFormationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFormationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFormationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteFormationConstraint(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteFormationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFormationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFormationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFormationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateFormationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateFormationConstraint(rctx, fc.Args["id"].(string), fc.Args["in"].(FormationConstraintUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateFormationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateFormationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFormationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachConstraintToFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachConstraintToFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AttachConstraintToFormationTemplate(rctx, fc.Args["constraintID"].(string), fc.Args["formationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.attachConstraintToFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ConstraintReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ConstraintReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ConstraintReference)
	fc.Result = res
	return ec.marshalNConstraintReference2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachConstraintToFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "constraintID":
				return ec.fieldContext_ConstraintReference_constraintID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_ConstraintReference_formationTemplateID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConstraintReference", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachConstraintToFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachConstraintFromFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachConstraintFromFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DetachConstraintFromFormationTemplate(rctx, fc.Args["constraintID"].(string), fc.Args["formationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.detachConstraintFromFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ConstraintReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ConstraintReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ConstraintReference)
	fc.Result = res
	return ec.marshalNConstraintReference2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachConstraintFromFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "constraintID":
				return ec.fieldContext_ConstraintReference_constraintID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_ConstraintReference_formationTemplateID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConstraintReference", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachConstraintFromFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLabelDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLabelDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateLabelDefinition(rctx, fc.Args["in"].(LabelDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createLabelDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LabelDefinition)
	fc.Result = res
	return ec.marshalNLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLabelDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLabelDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLabelDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLabelDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateLabelDefinition(rctx, fc.Args["in"].(LabelDefinitionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateLabelDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LabelDefinition)
	fc.Result = res
	return ec.marshalNLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLabelDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLabelDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setApplicationLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setApplicationLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetApplicationLabel(rctx, fc.Args["applicationID"].(string), fc.Args["key"].(string),
				func() interface{} {
					if fc.Args["value"] == nil {
						return nil
					}
					return fc.Args["value"].(interface{})
				}())
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setApplicationLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setApplicationLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setApplicationLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTenantLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTenantLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetTenantLabel(rctx, fc.Args["tenantID"].(string), fc.Args["key"].(string),
				func() interface{} {
					if fc.Args["value"] == nil {
						return nil
					}
					return fc.Args["value"].(interface{})
				}())
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setTenantLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTenantLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTenantLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApplicationLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApplicationLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteApplicationLabel(rctx, fc.Args["applicationID"].(string), fc.Args["key"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteApplicationLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApplicationLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApplicationLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setRuntimeLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setRuntimeLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetRuntimeLabel(rctx, fc.Args["runtimeID"].(string), fc.Args["key"].(string),
				func() interface{} {
					if fc.Args["value"] == nil {
						return nil
					}
					return fc.Args["value"].(interface{})
				}())
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setRuntimeLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setRuntimeLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setRuntimeLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRuntimeLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteRuntimeLabel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteRuntimeLabel(rctx, fc.Args["runtimeID"].(string), fc.Args["key"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteRuntimeLabel")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Label); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Label`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Label)
	fc.Result = res
	return ec.marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteRuntimeLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Label_key(ctx, field)
			case "value":
				return ec.fieldContext_Label_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Label", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRuntimeLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setDefaultEventingForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetDefaultEventingForApplication(rctx, fc.Args["appID"].(string), fc.Args["runtimeID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setDefaultEventingForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationEventingConfiguration); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationEventingConfiguration`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationEventingConfiguration)
	fc.Result = res
	return ec.marshalNApplicationEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEventingConfiguration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setDefaultEventingForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDefaultEventingForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDefaultEventingForApplication(rctx, fc.Args["appID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteDefaultEventingForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationEventingConfiguration); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationEventingConfiguration`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationEventingConfiguration)
	fc.Result = res
	return ec.marshalNApplicationEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDefaultEventingForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_ApplicationEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationEventingConfiguration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDefaultEventingForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetBundleInstanceAuth(rctx, fc.Args["authID"].(string), fc.Args["in"].(BundleInstanceAuthSetInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.setBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBundleInstanceAuth(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestBundleInstanceAuthCreation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestBundleInstanceAuthCreation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestBundleInstanceAuthCreation(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(BundleInstanceAuthRequestInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			applicationProvider, err := ec.unmarshalNString2string(ctx, "GetApplicationIDByBundle")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalNString2string(ctx, "bundleID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScenario == nil {
				return nil, errors.New("directive hasScenario is not implemented")
			}
			return ec.directives.HasScenario(ctx, nil, directive0, applicationProvider, idField)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestBundleInstanceAuthCreation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive1, path)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestBundleInstanceAuthCreation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestBundleInstanceAuthCreation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestBundleInstanceAuthDeletion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestBundleInstanceAuthDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestBundleInstanceAuthDeletion(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			applicationProvider, err := ec.unmarshalNString2string(ctx, "GetApplicationIDByBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalNString2string(ctx, "authID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScenario == nil {
				return nil, errors.New("directive hasScenario is not implemented")
			}
			return ec.directives.HasScenario(ctx, nil, directive0, applicationProvider, idField)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.requestBundleInstanceAuthDeletion")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive1, path)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestBundleInstanceAuthDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_requestBundleInstanceAuthDeletion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBundleInstanceAuth(rctx, fc.Args["bundleID"].(string), fc.Args["in"].(BundleInstanceAuthCreateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateBundleInstanceAuth(rctx, fc.Args["id"].(string), fc.Args["bundleID"].(string), fc.Args["in"].(BundleInstanceAuthUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateBundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddBundle(rctx, fc.Args["applicationID"].(string), fc.Args["in"].(BundleCreateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateBundle(rctx, fc.Args["id"].(string), fc.Args["in"].(BundleUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBundle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBundle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBundle(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteBundle")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBundle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBundle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_writeTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_writeTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().WriteTenants(rctx, fc.Args["in"].([]*BusinessTenantMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.writeTenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventType(ctx, "NEW_MULTIPLE_TENANTS")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive1, eventType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_writeTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_writeTenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_writeTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_writeTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().WriteTenant(rctx, fc.Args["in"].(BusinessTenantMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.writeTenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			eventType, err := ec.unmarshalNEventType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventType(ctx, "NEW_SINGLE_TENANT")
			if err != nil {
				return nil, err
			}
			if ec.directives.SynchronizeApplicationTenancy == nil {
				return nil, errors.New("directive synchronizeApplicationTenancy is not implemented")
			}
			return ec.directives.SynchronizeApplicationTenancy(ctx, nil, directive1, eventType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_writeTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_writeTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTenants(rctx, fc.Args["in"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteTenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTenant(rctx, fc.Args["id"].(string), fc.Args["in"].(BusinessTenantMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalNTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_subscribeTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_subscribeTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SubscribeTenant(rctx, fc.Args["providerID"].(string), fc.Args["subaccountID"].(string), fc.Args["providerSubaccountID"].(string), fc.Args["consumerTenantID"].(string), fc.Args["region"].(string), fc.Args["subscriptionAppName"].(string), fc.Args["subscriptionPayload"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.subscribeTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_subscribeTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_subscribeTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unsubscribeTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unsubscribeTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnsubscribeTenant(rctx, fc.Args["providerID"].(string), fc.Args["subaccountID"].(string), fc.Args["providerSubaccountID"].(string), fc.Args["consumerTenantID"].(string), fc.Args["region"].(string), fc.Args["subscriptionPayload"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.unsubscribeTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unsubscribeTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unsubscribeTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateFormationTemplate(rctx, fc.Args["in"].(FormationTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteFormationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFormationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateFormationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateFormationTemplate(rctx, fc.Args["id"].(string), fc.Args["in"].(FormationTemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateFormationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateFormationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFormationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCertificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateCertificateSubjectMapping(rctx, fc.Args["in"].(CertificateSubjectMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.createCertificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalOCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCertificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCertificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateCertificateSubjectMapping(rctx, fc.Args["id"].(string), fc.Args["in"].(CertificateSubjectMappingInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.updateCertificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalOCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCertificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteCertificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteCertificateSubjectMapping(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.deleteCertificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalOCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteCertificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCertificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addTenantAccess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addTenantAccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddTenantAccess(rctx, fc.Args["in"].(TenantAccessInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.addTenantAccess")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TenantAccess); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.TenantAccess`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TenantAccess)
	fc.Result = res
	return ec.marshalOTenantAccess2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addTenantAccess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tenantID":
				return ec.fieldContext_TenantAccess_tenantID(ctx, field)
			case "resourceType":
				return ec.fieldContext_TenantAccess_resourceType(ctx, field)
			case "resourceID":
				return ec.fieldContext_TenantAccess_resourceID(ctx, field)
			case "owner":
				return ec.fieldContext_TenantAccess_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TenantAccess", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addTenantAccess_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeTenantAccess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeTenantAccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveTenantAccess(rctx, fc.Args["tenantID"].(string), fc.Args["resourceID"].(string), fc.Args["resourceType"].(TenantAccessObjectType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.mutation.removeTenantAccess")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TenantAccess); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.TenantAccess`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TenantAccess)
	fc.Result = res
	return ec.marshalOTenantAccess2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeTenantAccess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tenantID":
				return ec.fieldContext_TenantAccess_tenantID(ctx, field)
			case "resourceType":
				return ec.fieldContext_TenantAccess_resourceType(ctx, field)
			case "resourceID":
				return ec.fieldContext_TenantAccess_resourceID(ctx, field)
			case "owner":
				return ec.fieldContext_TenantAccess_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TenantAccess", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeTenantAccess_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _OAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField, obj *OAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthCredentialData_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthCredentialData_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthCredentialData_clientSecret(ctx context.Context, field graphql.CollectedField, obj *OAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthCredentialData_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthCredentialData_clientSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthCredentialData_url(ctx context.Context, field graphql.CollectedField, obj *OAuthCredentialData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthCredentialData_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthCredentialData_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthCredentialData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_token(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_connectorURL(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_connectorURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_connectorURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_legacyConnectorURL(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_legacyConnectorURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LegacyConnectorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_legacyConnectorURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_used(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_expiresAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_createdAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_usedAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_usedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_usedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_raw(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForApplication().Raw(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_rawEncoded(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_rawEncoded(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForApplication().RawEncoded(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_rawEncoded(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_type(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(OneTimeTokenType)
	fc.Result = res
	return ec.marshalOOneTimeTokenType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OneTimeTokenType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForApplication_scenarioGroups(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForApplication) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForApplication_scenarioGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScenarioGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForApplication_scenarioGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForApplication",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_token(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_connectorURL(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_connectorURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_connectorURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_used(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_expiresAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_createdAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_usedAt(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_usedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_usedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_raw(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForRuntime().Raw(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_rawEncoded(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_rawEncoded(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OneTimeTokenForRuntime().RawEncoded(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_rawEncoded(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OneTimeTokenForRuntime_type(ctx context.Context, field graphql.CollectedField, obj *OneTimeTokenForRuntime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OneTimeTokenForRuntime_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(OneTimeTokenType)
	fc.Result = res
	return ec.marshalOOneTimeTokenType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OneTimeTokenForRuntime_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OneTimeTokenForRuntime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OneTimeTokenType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PageCursor)
	fc.Result = res
	return ec.marshalNPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PageCursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PageCursor)
	fc.Result = res
	return ec.marshalNPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PageCursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_name(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_description(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_jsonPath(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_jsonPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_jsonPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaceholderDefinition_optional(ctx context.Context, field graphql.CollectedField, obj *PlaceholderDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaceholderDefinition_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Optional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaceholderDefinition_optional(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaceholderDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_apisForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_apisForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApisForApplication(rctx, fc.Args["appID"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.apisForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*APIDefinitionPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.APIDefinitionPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*APIDefinitionPage)
	fc.Result = res
	return ec.marshalOAPIDefinitionPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_apisForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_APIDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_APIDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_APIDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_apisForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_eventsForApplication(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_eventsForApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().EventsForApplication(rctx, fc.Args["appID"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.eventsForApplication")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EventDefinitionPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.EventDefinitionPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EventDefinitionPage)
	fc.Result = res
	return ec.marshalOEventDefinitionPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_eventsForApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_EventDefinitionPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventDefinitionPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventDefinitionPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventDefinitionPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_eventsForApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Applications(rctx, fc.Args["filter"].([]*LabelFilter), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applications")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationPage)
	fc.Result = res
	return ec.marshalNApplicationPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ApplicationPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ApplicationPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ApplicationPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Application(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			applicationProvider, err := ec.unmarshalNString2string(ctx, "GetApplicationID")
			if err != nil {
				return nil, err
			}
			idField, err := ec.unmarshalNString2string(ctx, "id")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScenario == nil {
				return nil, errors.New("directive hasScenario is not implemented")
			}
			return ec.directives.HasScenario(ctx, nil, directive0, applicationProvider, idField)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.application")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive1, path)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalOApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_application_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationBySystemNumber(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationBySystemNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationBySystemNumber(rctx, fc.Args["systemNumber"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationBySystemNumber")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalOApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationBySystemNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationBySystemNumber_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationByLocalTenantIDAndAppTemplateID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationByLocalTenantIDAndAppTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationByLocalTenantIDAndAppTemplateID(rctx, fc.Args["localTenantID"].(string), fc.Args["applicationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationByLocalTenantIDAndAppTemplateID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Application); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Application`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalOApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationByLocalTenantIDAndAppTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Application_id(ctx, field)
			case "name":
				return ec.fieldContext_Application_name(ctx, field)
			case "systemNumber":
				return ec.fieldContext_Application_systemNumber(ctx, field)
			case "localTenantID":
				return ec.fieldContext_Application_localTenantID(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Application_baseUrl(ctx, field)
			case "providerName":
				return ec.fieldContext_Application_providerName(ctx, field)
			case "description":
				return ec.fieldContext_Application_description(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Application_integrationSystemID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Application_applicationTemplateID(ctx, field)
			case "applicationTemplate":
				return ec.fieldContext_Application_applicationTemplate(ctx, field)
			case "labels":
				return ec.fieldContext_Application_labels(ctx, field)
			case "status":
				return ec.fieldContext_Application_status(ctx, field)
			case "webhooks":
				return ec.fieldContext_Application_webhooks(ctx, field)
			case "healthCheckURL":
				return ec.fieldContext_Application_healthCheckURL(ctx, field)
			case "bundles":
				return ec.fieldContext_Application_bundles(ctx, field)
			case "bundle":
				return ec.fieldContext_Application_bundle(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Application_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Application_eventDefinition(ctx, field)
			case "integrationDependencies":
				return ec.fieldContext_Application_integrationDependencies(ctx, field)
			case "auths":
				return ec.fieldContext_Application_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Application_eventingConfiguration(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Application_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_Application_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Application_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Application_deletedAt(ctx, field)
			case "systemStatus":
				return ec.fieldContext_Application_systemStatus(ctx, field)
			case "error":
				return ec.fieldContext_Application_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationByLocalTenantIDAndAppTemplateID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationsForRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationsForRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationsForRuntime(rctx, fc.Args["runtimeID"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationsForRuntime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationPage)
	fc.Result = res
	return ec.marshalNApplicationPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationsForRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ApplicationPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ApplicationPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ApplicationPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationsForRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationTemplates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationTemplates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationTemplates(rctx, fc.Args["filter"].([]*LabelFilter), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationTemplates")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplatePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplatePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplatePage)
	fc.Result = res
	return ec.marshalNApplicationTemplatePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplatePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationTemplates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ApplicationTemplatePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ApplicationTemplatePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ApplicationTemplatePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplatePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationTemplates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_applicationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_applicationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ApplicationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.applicationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ApplicationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.ApplicationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationTemplate)
	fc.Result = res
	return ec.marshalOApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_applicationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ApplicationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_ApplicationTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationTemplate_description(ctx, field)
			case "webhooks":
				return ec.fieldContext_ApplicationTemplate_webhooks(ctx, field)
			case "applicationInput":
				return ec.fieldContext_ApplicationTemplate_applicationInput(ctx, field)
			case "placeholders":
				return ec.fieldContext_ApplicationTemplate_placeholders(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationTemplate_labels(ctx, field)
			case "accessLevel":
				return ec.fieldContext_ApplicationTemplate_accessLevel(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_ApplicationTemplate_applicationNamespace(ctx, field)
			case "createdAt":
				return ec.fieldContext_ApplicationTemplate_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_ApplicationTemplate_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_applicationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_runtimes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtimes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Runtimes(rctx, fc.Args["filter"].([]*LabelFilter), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.runtimes")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RuntimePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.RuntimePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimePage)
	fc.Result = res
	return ec.marshalNRuntimePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtimes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_RuntimePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RuntimePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RuntimePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runtimes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_runtime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Runtime(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.runtime")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Runtime); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Runtime`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalORuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runtime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_runtimeByTokenIssuer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtimeByTokenIssuer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RuntimeByTokenIssuer(rctx, fc.Args["issuer"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Runtime)
	fc.Result = res
	return ec.marshalORuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtimeByTokenIssuer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runtimeByTokenIssuer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_labelDefinitions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_labelDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().LabelDefinitions(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.labelDefinitions")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*LabelDefinition)
	fc.Result = res
	return ec.marshalNLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_labelDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_labelDefinition(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_labelDefinition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().LabelDefinition(rctx, fc.Args["key"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.labelDefinition")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LabelDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.LabelDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LabelDefinition)
	fc.Result = res
	return ec.marshalOLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_labelDefinition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelDefinition_key(ctx, field)
			case "schema":
				return ec.fieldContext_LabelDefinition_schema(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelDefinition", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_labelDefinition_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bundleByInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bundleByInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BundleByInstanceAuth(rctx, fc.Args["authID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.bundleByInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Bundle); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Bundle`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	fc.Result = res
	return ec.marshalOBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bundleByInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bundle_id(ctx, field)
			case "name":
				return ec.fieldContext_Bundle_name(ctx, field)
			case "description":
				return ec.fieldContext_Bundle_description(ctx, field)
			case "instanceAuthRequestInputSchema":
				return ec.fieldContext_Bundle_instanceAuthRequestInputSchema(ctx, field)
			case "instanceAuth":
				return ec.fieldContext_Bundle_instanceAuth(ctx, field)
			case "instanceAuths":
				return ec.fieldContext_Bundle_instanceAuths(ctx, field)
			case "defaultInstanceAuth":
				return ec.fieldContext_Bundle_defaultInstanceAuth(ctx, field)
			case "apiDefinitions":
				return ec.fieldContext_Bundle_apiDefinitions(ctx, field)
			case "eventDefinitions":
				return ec.fieldContext_Bundle_eventDefinitions(ctx, field)
			case "documents":
				return ec.fieldContext_Bundle_documents(ctx, field)
			case "apiDefinition":
				return ec.fieldContext_Bundle_apiDefinition(ctx, field)
			case "eventDefinition":
				return ec.fieldContext_Bundle_eventDefinition(ctx, field)
			case "correlationIDs":
				return ec.fieldContext_Bundle_correlationIDs(ctx, field)
			case "document":
				return ec.fieldContext_Bundle_document(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bundle_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bundle_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bundle_deletedAt(ctx, field)
			case "error":
				return ec.fieldContext_Bundle_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bundle", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bundleByInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bundleInstanceAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BundleInstanceAuth(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.bundleInstanceAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*BundleInstanceAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.BundleInstanceAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BundleInstanceAuth)
	fc.Result = res
	return ec.marshalOBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bundleInstanceAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BundleInstanceAuth_id(ctx, field)
			case "context":
				return ec.fieldContext_BundleInstanceAuth_context(ctx, field)
			case "inputParams":
				return ec.fieldContext_BundleInstanceAuth_inputParams(ctx, field)
			case "auth":
				return ec.fieldContext_BundleInstanceAuth_auth(ctx, field)
			case "status":
				return ec.fieldContext_BundleInstanceAuth_status(ctx, field)
			case "runtimeID":
				return ec.fieldContext_BundleInstanceAuth_runtimeID(ctx, field)
			case "runtimeContextID":
				return ec.fieldContext_BundleInstanceAuth_runtimeContextID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BundleInstanceAuth", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bundleInstanceAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_healthChecks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_healthChecks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().HealthChecks(rctx, fc.Args["types"].([]HealthCheckType), fc.Args["origin"].(*string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.healthChecks")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*HealthCheckPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.HealthCheckPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HealthCheckPage)
	fc.Result = res
	return ec.marshalNHealthCheckPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_healthChecks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_HealthCheckPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_HealthCheckPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_HealthCheckPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HealthCheckPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_healthChecks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_integrationSystems(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_integrationSystems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IntegrationSystems(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.integrationSystems")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystemPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystemPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystemPage)
	fc.Result = res
	return ec.marshalNIntegrationSystemPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystemPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_integrationSystems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_IntegrationSystemPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_IntegrationSystemPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_IntegrationSystemPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystemPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_integrationSystems_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_integrationSystem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_integrationSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IntegrationSystem(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.integrationSystem")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*IntegrationSystem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.IntegrationSystem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*IntegrationSystem)
	fc.Result = res
	return ec.marshalOIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_integrationSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IntegrationSystem_id(ctx, field)
			case "name":
				return ec.fieldContext_IntegrationSystem_name(ctx, field)
			case "description":
				return ec.fieldContext_IntegrationSystem_description(ctx, field)
			case "auths":
				return ec.fieldContext_IntegrationSystem_auths(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationSystem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_integrationSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Viewer(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.viewer")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Viewer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Viewer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Viewer)
	fc.Result = res
	return ec.marshalNViewer2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "type":
				return ec.fieldContext_Viewer_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Tenants(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor), fc.Args["searchTerm"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TenantPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.TenantPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TenantPage)
	fc.Result = res
	return ec.marshalNTenantPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_TenantPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TenantPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TenantPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TenantPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenantByExternalID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenantByExternalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TenantByExternalID(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenants")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalOTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenantByExternalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenantByExternalID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenantByInternalID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenantByInternalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TenantByInternalID(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenantByInternalID")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tenant)
	fc.Result = res
	return ec.marshalOTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenantByInternalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenantByInternalID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tenantByLowestOwnerForResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tenantByLowestOwnerForResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TenantByLowestOwnerForResource(rctx, fc.Args["id"].(string), fc.Args["resource"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.tenantByLowestOwnerForResource")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tenantByLowestOwnerForResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tenantByLowestOwnerForResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_rootTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_rootTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().RootTenants(rctx, fc.Args["externalTenant"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.rootTenant")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Tenant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tenant)
	fc.Result = res
	return ec.marshalOTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_rootTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_rootTenants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_automaticScenarioAssignmentForScenario(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_automaticScenarioAssignmentForScenario(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AutomaticScenarioAssignmentForScenario(rctx, fc.Args["scenarioName"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.automaticScenarioAssignmentForScenario")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AutomaticScenarioAssignment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.AutomaticScenarioAssignment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AutomaticScenarioAssignment)
	fc.Result = res
	return ec.marshalOAutomaticScenarioAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_automaticScenarioAssignmentForScenario(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenarioName":
				return ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
			case "selector":
				return ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_automaticScenarioAssignmentForScenario_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_automaticScenarioAssignmentsForSelector(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_automaticScenarioAssignmentsForSelector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AutomaticScenarioAssignmentsForSelector(rctx, fc.Args["selector"].(LabelSelectorInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.automaticScenarioAssignmentsForSelector")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AutomaticScenarioAssignment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.AutomaticScenarioAssignment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AutomaticScenarioAssignment)
	fc.Result = res
	return ec.marshalNAutomaticScenarioAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_automaticScenarioAssignmentsForSelector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "scenarioName":
				return ec.fieldContext_AutomaticScenarioAssignment_scenarioName(ctx, field)
			case "selector":
				return ec.fieldContext_AutomaticScenarioAssignment_selector(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_automaticScenarioAssignmentsForSelector_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_automaticScenarioAssignments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_automaticScenarioAssignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AutomaticScenarioAssignments(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.automaticScenarioAssignments")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AutomaticScenarioAssignmentPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.AutomaticScenarioAssignmentPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AutomaticScenarioAssignmentPage)
	fc.Result = res
	return ec.marshalOAutomaticScenarioAssignmentPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignmentPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_automaticScenarioAssignments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_AutomaticScenarioAssignmentPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AutomaticScenarioAssignmentPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_AutomaticScenarioAssignmentPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AutomaticScenarioAssignmentPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_automaticScenarioAssignments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_systemAuth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_systemAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SystemAuth(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.systemAuth")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalOSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_systemAuth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_systemAuth_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_systemAuthByToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_systemAuthByToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SystemAuthByToken(rctx, fc.Args["token"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.systemAuthByToken")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(SystemAuth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.SystemAuth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(SystemAuth)
	fc.Result = res
	return ec.marshalOSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_systemAuthByToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_systemAuthByToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Formation(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formation")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalOFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationByName(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationByName")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Formation)
	fc.Result = res
	return ec.marshalOFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationByName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Formations(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formations")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationPage)
	fc.Result = res
	return ec.marshalNFormationPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationsForObject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationsForObject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationsForObject(rctx, fc.Args["objectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationsForObject")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Formation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Formation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Formation)
	fc.Result = res
	return ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationsForObject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Formation_id(ctx, field)
			case "name":
				return ec.fieldContext_Formation_name(ctx, field)
			case "formationTemplateId":
				return ec.fieldContext_Formation_formationTemplateId(ctx, field)
			case "tenantID":
				return ec.fieldContext_Formation_tenantID(ctx, field)
			case "state":
				return ec.fieldContext_Formation_state(ctx, field)
			case "error":
				return ec.fieldContext_Formation_error(ctx, field)
			case "formationAssignment":
				return ec.fieldContext_Formation_formationAssignment(ctx, field)
			case "formationAssignments":
				return ec.fieldContext_Formation_formationAssignments(ctx, field)
			case "status":
				return ec.fieldContext_Formation_status(ctx, field)
			case "lastStateChangeTimestamp":
				return ec.fieldContext_Formation_lastStateChangeTimestamp(ctx, field)
			case "lastNotificationSentTimestamp":
				return ec.fieldContext_Formation_lastNotificationSentTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Formation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationsForObject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationConstraints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationConstraints(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationConstraints")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationConstraint(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationConstraint")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationConstraintsByFormationType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationConstraintsByFormationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationConstraintsByFormationType(rctx, fc.Args["formationTemplateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationConstraints")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*FormationConstraint); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationConstraint`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*FormationConstraint)
	fc.Result = res
	return ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationConstraintsByFormationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationConstraint_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationConstraint_name(ctx, field)
			case "description":
				return ec.fieldContext_FormationConstraint_description(ctx, field)
			case "constraintType":
				return ec.fieldContext_FormationConstraint_constraintType(ctx, field)
			case "targetOperation":
				return ec.fieldContext_FormationConstraint_targetOperation(ctx, field)
			case "operator":
				return ec.fieldContext_FormationConstraint_operator(ctx, field)
			case "resourceType":
				return ec.fieldContext_FormationConstraint_resourceType(ctx, field)
			case "resourceSubtype":
				return ec.fieldContext_FormationConstraint_resourceSubtype(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_FormationConstraint_inputTemplate(ctx, field)
			case "constraintScope":
				return ec.fieldContext_FormationConstraint_constraintScope(ctx, field)
			case "priority":
				return ec.fieldContext_FormationConstraint_priority(ctx, field)
			case "createdAt":
				return ec.fieldContext_FormationConstraint_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationConstraintsByFormationType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationTemplate(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationTemplate")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FormationTemplate)
	fc.Result = res
	return ec.marshalOFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FormationTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_FormationTemplate_name(ctx, field)
			case "applicationTypes":
				return ec.fieldContext_FormationTemplate_applicationTypes(ctx, field)
			case "runtimeTypes":
				return ec.fieldContext_FormationTemplate_runtimeTypes(ctx, field)
			case "runtimeTypeDisplayName":
				return ec.fieldContext_FormationTemplate_runtimeTypeDisplayName(ctx, field)
			case "runtimeArtifactKind":
				return ec.fieldContext_FormationTemplate_runtimeArtifactKind(ctx, field)
			case "webhooks":
				return ec.fieldContext_FormationTemplate_webhooks(ctx, field)
			case "leadingProductIDs":
				return ec.fieldContext_FormationTemplate_leadingProductIDs(ctx, field)
			case "formationConstraints":
				return ec.fieldContext_FormationTemplate_formationConstraints(ctx, field)
			case "supportsReset":
				return ec.fieldContext_FormationTemplate_supportsReset(ctx, field)
			case "discoveryConsumers":
				return ec.fieldContext_FormationTemplate_discoveryConsumers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationTemplates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationTemplates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationTemplates(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationTemplates")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplatePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplatePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationTemplatePage)
	fc.Result = res
	return ec.marshalNFormationTemplatePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplatePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationTemplates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationTemplatePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationTemplatePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationTemplatePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplatePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationTemplates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_formationTemplatesByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_formationTemplatesByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FormationTemplatesByName(rctx, fc.Args["name"].(string), fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.formationTemplates")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*FormationTemplatePage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.FormationTemplatePage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FormationTemplatePage)
	fc.Result = res
	return ec.marshalNFormationTemplatePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplatePage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_formationTemplatesByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_FormationTemplatePage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_FormationTemplatePage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_FormationTemplatePage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FormationTemplatePage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_formationTemplatesByName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_certificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_certificateSubjectMapping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CertificateSubjectMapping(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.certificateSubjectMapping")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMapping); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMapping`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMapping)
	fc.Result = res
	return ec.marshalNCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_certificateSubjectMapping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CertificateSubjectMapping_id(ctx, field)
			case "subject":
				return ec.fieldContext_CertificateSubjectMapping_subject(ctx, field)
			case "consumerType":
				return ec.fieldContext_CertificateSubjectMapping_consumerType(ctx, field)
			case "internalConsumerID":
				return ec.fieldContext_CertificateSubjectMapping_internalConsumerID(ctx, field)
			case "tenantAccessLevels":
				return ec.fieldContext_CertificateSubjectMapping_tenantAccessLevels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMapping", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_certificateSubjectMapping_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_certificateSubjectMappings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_certificateSubjectMappings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CertificateSubjectMappings(rctx, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.query.certificateSubjectMappings")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasScopes == nil {
				return nil, errors.New("directive hasScopes is not implemented")
			}
			return ec.directives.HasScopes(ctx, nil, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CertificateSubjectMappingPage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.CertificateSubjectMappingPage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*CertificateSubjectMappingPage)
	fc.Result = res
	return ec.marshalNCertificateSubjectMappingPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMappingPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_certificateSubjectMappings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_CertificateSubjectMappingPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CertificateSubjectMappingPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_CertificateSubjectMappingPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CertificateSubjectMappingPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_certificateSubjectMappings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_id(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_metadata(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeMetadata)
	fc.Result = res
	return ec.marshalNRuntimeMetadata2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "creationTimestamp":
				return ec.fieldContext_RuntimeMetadata_creationTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_name(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_description(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_labels(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Runtime_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_webhooks(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_webhooks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Runtime().Webhooks(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.runtime.webhooks")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Webhook); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kyma-incubator/compass/components/director/pkg/graphql.Webhook`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Webhook)
	fc.Result = res
	return ec.marshalOWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "applicationID":
				return ec.fieldContext_Webhook_applicationID(ctx, field)
			case "applicationTemplateID":
				return ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
			case "runtimeID":
				return ec.fieldContext_Webhook_runtimeID(ctx, field)
			case "integrationSystemID":
				return ec.fieldContext_Webhook_integrationSystemID(ctx, field)
			case "formationTemplateID":
				return ec.fieldContext_Webhook_formationTemplateID(ctx, field)
			case "type":
				return ec.fieldContext_Webhook_type(ctx, field)
			case "mode":
				return ec.fieldContext_Webhook_mode(ctx, field)
			case "correlationIdKey":
				return ec.fieldContext_Webhook_correlationIdKey(ctx, field)
			case "retryInterval":
				return ec.fieldContext_Webhook_retryInterval(ctx, field)
			case "timeout":
				return ec.fieldContext_Webhook_timeout(ctx, field)
			case "url":
				return ec.fieldContext_Webhook_url(ctx, field)
			case "auth":
				return ec.fieldContext_Webhook_auth(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_Webhook_urlTemplate(ctx, field)
			case "inputTemplate":
				return ec.fieldContext_Webhook_inputTemplate(ctx, field)
			case "headerTemplate":
				return ec.fieldContext_Webhook_headerTemplate(ctx, field)
			case "outputTemplate":
				return ec.fieldContext_Webhook_outputTemplate(ctx, field)
			case "statusTemplate":
				return ec.fieldContext_Webhook_statusTemplate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_status(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RuntimeStatus)
	fc.Result = res
	return ec.marshalNRuntimeStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "condition":
				return ec.fieldContext_RuntimeStatus_condition(ctx, field)
			case "timestamp":
				return ec.fieldContext_RuntimeStatus_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_auths(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_auths(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().Auths(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*RuntimeSystemAuth)
	fc.Result = res
	return ec.marshalORuntimeSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeSystemAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_auths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeSystemAuth_id(ctx, field)
			case "auth":
				return ec.fieldContext_RuntimeSystemAuth_auth(ctx, field)
			case "type":
				return ec.fieldContext_RuntimeSystemAuth_type(ctx, field)
			case "tenantId":
				return ec.fieldContext_RuntimeSystemAuth_tenantId(ctx, field)
			case "referenceObjectId":
				return ec.fieldContext_RuntimeSystemAuth_referenceObjectId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeSystemAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_eventingConfiguration(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().EventingConfiguration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RuntimeEventingConfiguration)
	fc.Result = res
	return ec.marshalORuntimeEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeEventingConfiguration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_eventingConfiguration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultURL":
				return ec.fieldContext_RuntimeEventingConfiguration_defaultURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeEventingConfiguration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_runtimeContext(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_runtimeContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().RuntimeContext(rctx, obj, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RuntimeContext)
	fc.Result = res
	return ec.marshalORuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_runtimeContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Runtime_runtimeContext_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_runtimeContexts(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_runtimeContexts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().RuntimeContexts(rctx, obj, fc.Args["first"].(*int), fc.Args["after"].(*PageCursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RuntimeContextPage)
	fc.Result = res
	return ec.marshalORuntimeContextPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContextPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_runtimeContexts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_RuntimeContextPage_data(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RuntimeContextPage_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RuntimeContextPage_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContextPage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Runtime_runtimeContexts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Runtime_applicationNamespace(ctx context.Context, field graphql.CollectedField, obj *Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_applicationNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_applicationNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_id(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_key(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_value(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContext_labels(ctx context.Context, field graphql.CollectedField, obj *RuntimeContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContext_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RuntimeContext().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContext_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContext",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RuntimeContext_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContextPage_data(ctx context.Context, field graphql.CollectedField, obj *RuntimeContextPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContextPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*RuntimeContext)
	fc.Result = res
	return ec.marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContextPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContextPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuntimeContext_id(ctx, field)
			case "key":
				return ec.fieldContext_RuntimeContext_key(ctx, field)
			case "value":
				return ec.fieldContext_RuntimeContext_value(ctx, field)
			case "labels":
				return ec.fieldContext_RuntimeContext_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeContext", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContextPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *RuntimeContextPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContextPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContextPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContextPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeContextPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *RuntimeContextPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeContextPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeContextPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeContextPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField, obj *RuntimeEventingConfiguration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeEventingConfiguration_defaultURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeEventingConfiguration_defaultURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeEventingConfiguration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *RuntimeMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeMetadata_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimePage_data(ctx context.Context, field graphql.CollectedField, obj *RuntimePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimePage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Runtime)
	fc.Result = res
	return ec.marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimePage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "metadata":
				return ec.fieldContext_Runtime_metadata(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "labels":
				return ec.fieldContext_Runtime_labels(ctx, field)
			case "webhooks":
				return ec.fieldContext_Runtime_webhooks(ctx, field)
			case "status":
				return ec.fieldContext_Runtime_status(ctx, field)
			case "auths":
				return ec.fieldContext_Runtime_auths(ctx, field)
			case "eventingConfiguration":
				return ec.fieldContext_Runtime_eventingConfiguration(ctx, field)
			case "runtimeContext":
				return ec.fieldContext_Runtime_runtimeContext(ctx, field)
			case "runtimeContexts":
				return ec.fieldContext_Runtime_runtimeContexts(ctx, field)
			case "applicationNamespace":
				return ec.fieldContext_Runtime_applicationNamespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimePage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *RuntimePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimePage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimePage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimePage_totalCount(ctx context.Context, field graphql.CollectedField, obj *RuntimePage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimePage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimePage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimePage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeStatus_condition(ctx context.Context, field graphql.CollectedField, obj *RuntimeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeStatus_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(RuntimeStatusCondition)
	fc.Result = res
	return ec.marshalNRuntimeStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatusCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeStatus_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RuntimeStatusCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *RuntimeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_id(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_auth(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.runtime.auths")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_type(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SystemAuthReferenceType)
	fc.Result = res
	return ec.marshalOSystemAuthReferenceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuthReferenceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SystemAuthReferenceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField, obj *RuntimeSystemAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeSystemAuth_referenceObjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReferenceObjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeSystemAuth_referenceObjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeSystemAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_id(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_internalID(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_internalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_internalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_name(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_type(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_parents(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_parents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_parents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_initialized(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_initialized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Initialized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_initialized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_labels(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tenant().Labels(rctx, obj, fc.Args["key"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Labels)
	fc.Result = res
	return ec.marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Labels does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Tenant_labels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Tenant_provider(ctx context.Context, field graphql.CollectedField, obj *Tenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tenant_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tenant_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_tenantID(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_tenantID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_tenantID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_resourceType(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TenantAccessObjectType)
	fc.Result = res
	return ec.marshalNTenantAccessObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccessObjectType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TenantAccessObjectType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_resourceID(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_resourceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_resourceID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantAccess_owner(ctx context.Context, field graphql.CollectedField, obj *TenantAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantAccess_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantAccess_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantPage_data(ctx context.Context, field graphql.CollectedField, obj *TenantPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantPage_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tenant)
	fc.Result = res
	return ec.marshalNTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantPage_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tenant_id(ctx, field)
			case "internalID":
				return ec.fieldContext_Tenant_internalID(ctx, field)
			case "name":
				return ec.fieldContext_Tenant_name(ctx, field)
			case "type":
				return ec.fieldContext_Tenant_type(ctx, field)
			case "parents":
				return ec.fieldContext_Tenant_parents(ctx, field)
			case "initialized":
				return ec.fieldContext_Tenant_initialized(ctx, field)
			case "labels":
				return ec.fieldContext_Tenant_labels(ctx, field)
			case "provider":
				return ec.fieldContext_Tenant_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tenant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantPage_pageInfo(ctx context.Context, field graphql.CollectedField, obj *TenantPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantPage_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantPage_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TenantPage_totalCount(ctx context.Context, field graphql.CollectedField, obj *TenantPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TenantPage_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TenantPage_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TenantPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_value(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_deprecated(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_deprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deprecated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_deprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_deprecatedSince(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_deprecatedSince(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecatedSince, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_deprecatedSince(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_forRemoval(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_forRemoval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForRemoval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_forRemoval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_id(ctx context.Context, field graphql.CollectedField, obj *Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_type(ctx context.Context, field graphql.CollectedField, obj *Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ViewerType)
	fc.Result = res
	return ec.marshalNViewerType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlViewerType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewerType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_id(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_applicationID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_applicationID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_applicationID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_applicationTemplateID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_applicationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_applicationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_runtimeID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_runtimeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_runtimeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_integrationSystemID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_integrationSystemID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntegrationSystemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_integrationSystemID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_formationTemplateID(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_formationTemplateID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormationTemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_formationTemplateID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_type(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(WebhookType)
	fc.Result = res
	return ec.marshalNWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WebhookType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_mode(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*WebhookMode)
	fc.Result = res
	return ec.marshalOWebhookMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WebhookMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_correlationIdKey(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_correlationIdKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorrelationIDKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_correlationIdKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_retryInterval(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_retryInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetryInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_retryInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_timeout(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_url(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_auth(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Auth, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			path, err := ec.unmarshalNString2string(ctx, "graphql.field.webhooks.auth")
			if err != nil {
				return nil, err
			}
			if ec.directives.Sanitize == nil {
				return nil, errors.New("directive sanitize is not implemented")
			}
			return ec.directives.Sanitize(ctx, obj, directive0, path)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Auth); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kyma-incubator/compass/components/director/pkg/graphql.Auth`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Auth)
	fc.Result = res
	return ec.marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "credential":
				return ec.fieldContext_Auth_credential(ctx, field)
			case "accessStrategy":
				return ec.fieldContext_Auth_accessStrategy(ctx, field)
			case "additionalHeaders":
				return ec.fieldContext_Auth_additionalHeaders(ctx, field)
			case "additionalHeadersSerialized":
				return ec.fieldContext_Auth_additionalHeadersSerialized(ctx, field)
			case "additionalQueryParams":
				return ec.fieldContext_Auth_additionalQueryParams(ctx, field)
			case "additionalQueryParamsSerialized":
				return ec.fieldContext_Auth_additionalQueryParamsSerialized(ctx, field)
			case "requestAuth":
				return ec.fieldContext_Auth_requestAuth(ctx, field)
			case "oneTimeToken":
				return ec.fieldContext_Auth_oneTimeToken(ctx, field)
			case "certCommonName":
				return ec.fieldContext_Auth_certCommonName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Auth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_urlTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_urlTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_urlTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_inputTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_inputTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_inputTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_headerTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_headerTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeaderTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_headerTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_outputTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_outputTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutputTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_outputTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_statusTemplate(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_statusTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StatusTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_statusTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_createdAt(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timestamp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAPIDefinitionInput(ctx context.Context, obj interface{}) (APIDefinitionInput, error) {
	var it APIDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "targetURL", "group", "spec", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "targetURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetURL = data
		case "group":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Group = data
		case "spec":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spec"))
			data, err := ec.unmarshalOAPISpecInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpecInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Spec = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOVersionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAPISpecInput(ctx context.Context, obj interface{}) (APISpecInput, error) {
	var it APISpecInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type", "format", "fetchRequest"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNAPISpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpecType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNSpecFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSpecFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "fetchRequest":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetchRequest"))
			data, err := ec.unmarshalOFetchRequestInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchRequest = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationFromTemplateInput(ctx context.Context, obj interface{}) (ApplicationFromTemplateInput, error) {
	var it ApplicationFromTemplateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "templateName", "values", "placeholdersPayload", "labels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "templateName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("templateName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TemplateName = data
		case "values":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalOTemplateValueInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTemplateValueInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		case "placeholdersPayload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholdersPayload"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlaceholdersPayload = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationJSONInput(ctx context.Context, obj interface{}) (ApplicationJSONInput, error) {
	var it ApplicationJSONInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "providerName", "description", "labels", "webhooks", "healthCheckURL", "baseUrl", "applicationNamespace", "integrationSystemID", "statusCondition", "localTenantID", "bundles"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "providerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "healthCheckURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("healthCheckURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HealthCheckURL = data
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		case "integrationSystemID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("integrationSystemID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntegrationSystemID = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalOApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "localTenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocalTenantID = data
		case "bundles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundles"))
			data, err := ec.unmarshalOBundleCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bundles = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationRegisterInput(ctx context.Context, obj interface{}) (ApplicationRegisterInput, error) {
	var it ApplicationRegisterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "providerName", "description", "labels", "webhooks", "healthCheckURL", "baseUrl", "applicationNamespace", "integrationSystemID", "statusCondition", "localTenantID", "bundles"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "providerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "healthCheckURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("healthCheckURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HealthCheckURL = data
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		case "integrationSystemID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("integrationSystemID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntegrationSystemID = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalOApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "localTenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.application.localTenantID")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.LocalTenantID = data
			} else if tmp == nil {
				it.LocalTenantID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "bundles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bundles"))
			data, err := ec.unmarshalOBundleCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bundles = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationTemplateInput(ctx context.Context, obj interface{}) (ApplicationTemplateInput, error) {
	var it ApplicationTemplateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "webhooks", "description", "labels", "applicationInput", "placeholders", "accessLevel", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "applicationInput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationInput"))
			data, err := ec.unmarshalNApplicationJSONInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationJSONInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationInput = data
		case "placeholders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholders"))
			data, err := ec.unmarshalOPlaceholderDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Placeholders = data
		case "accessLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessLevel"))
			data, err := ec.unmarshalNApplicationTemplateAccessLevel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateAccessLevel(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessLevel = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationTemplateUpdateInput(ctx context.Context, obj interface{}) (ApplicationTemplateUpdateInput, error) {
	var it ApplicationTemplateUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "webhooks", "description", "applicationInput", "placeholders", "labels", "accessLevel", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "applicationInput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationInput"))
			data, err := ec.unmarshalNApplicationJSONInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationJSONInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationInput = data
		case "placeholders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholders"))
			data, err := ec.unmarshalOPlaceholderDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Placeholders = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.application_template.labels")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(Labels); ok {
				it.Labels = data
			} else if tmp == nil {
				it.Labels = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/kyma-incubator/compass/components/director/pkg/graphql.Labels`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "accessLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessLevel"))
			data, err := ec.unmarshalNApplicationTemplateAccessLevel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateAccessLevel(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessLevel = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplicationUpdateInput(ctx context.Context, obj interface{}) (ApplicationUpdateInput, error) {
	var it ApplicationUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"providerName", "description", "healthCheckURL", "baseUrl", "applicationNamespace", "integrationSystemID", "statusCondition", "localTenantID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "providerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "healthCheckURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("healthCheckURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HealthCheckURL = data
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		case "integrationSystemID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("integrationSystemID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntegrationSystemID = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalOApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "localTenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localTenantID"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.application.localTenantID")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.LocalTenantID = data
			} else if tmp == nil {
				it.LocalTenantID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectAPIDefinitionInput(ctx context.Context, obj interface{}) (AspectAPIDefinitionInput, error) {
	var it AspectAPIDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ordId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ordId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrdID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectEventDefinitionInput(ctx context.Context, obj interface{}) (AspectEventDefinitionInput, error) {
	var it AspectEventDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ordId", "subset"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ordId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrdID = data
		case "subset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subset"))
			data, err := ec.unmarshalOAspectEventDefinitionSubsetInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubsetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subset = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectEventDefinitionSubsetInput(ctx context.Context, obj interface{}) (AspectEventDefinitionSubsetInput, error) {
	var it AspectEventDefinitionSubsetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eventType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eventType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAspectInput(ctx context.Context, obj interface{}) (AspectInput, error) {
	var it AspectInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "mandatory", "apiResources", "eventResources"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "mandatory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mandatory"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mandatory = data
		case "apiResources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiResources"))
			data, err := ec.unmarshalOAspectAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIResources = data
		case "eventResources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventResources"))
			data, err := ec.unmarshalOAspectEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventResources = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthInput(ctx context.Context, obj interface{}) (AuthInput, error) {
	var it AuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"credential", "accessStrategy", "additionalHeaders", "additionalHeadersSerialized", "additionalQueryParams", "additionalQueryParamsSerialized", "requestAuth", "certCommonName", "oneTimeToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "credential":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credential"))
			data, err := ec.unmarshalOCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Credential = data
		case "accessStrategy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessStrategy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessStrategy = data
		case "additionalHeaders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeaders"))
			data, err := ec.unmarshalOHttpHeaders2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeaders(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeaders = data
		case "additionalHeadersSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeadersSerialized"))
			data, err := ec.unmarshalOHttpHeadersSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeadersSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeadersSerialized = data
		case "additionalQueryParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParams"))
			data, err := ec.unmarshalOQueryParams2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParams = data
		case "additionalQueryParamsSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParamsSerialized"))
			data, err := ec.unmarshalOQueryParamsSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParamsSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParamsSerialized = data
		case "requestAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestAuth"))
			data, err := ec.unmarshalOCredentialRequestAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialRequestAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.RequestAuth = data
		case "certCommonName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certCommonName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CertCommonName = data
		case "oneTimeToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oneTimeToken"))
			data, err := ec.unmarshalOOneTimeTokenInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.OneTimeToken = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBasicCredentialDataInput(ctx context.Context, obj interface{}) (BasicCredentialDataInput, error) {
	var it BasicCredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleCreateInput(ctx context.Context, obj interface{}) (BundleCreateInput, error) {
	var it BundleCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "instanceAuthRequestInputSchema", "defaultInstanceAuth", "apiDefinitions", "eventDefinitions", "documents", "correlationIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "instanceAuthRequestInputSchema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceAuthRequestInputSchema"))
			data, err := ec.unmarshalOJSONSchema2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSONSchema(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceAuthRequestInputSchema = data
		case "defaultInstanceAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultInstanceAuth"))
			data, err := ec.unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultInstanceAuth = data
		case "apiDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiDefinitions"))
			data, err := ec.unmarshalOAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIDefinitions = data
		case "eventDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventDefinitions"))
			data, err := ec.unmarshalOEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventDefinitions = data
		case "documents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("documents"))
			data, err := ec.unmarshalODocumentInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Documents = data
		case "correlationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("correlationIDs"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CorrelationIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthCreateInput(ctx context.Context, obj interface{}) (BundleInstanceAuthCreateInput, error) {
	var it BundleInstanceAuthCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"context", "inputParams", "auth", "runtimeID", "runtimeContextID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "context":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
			data, err := ec.unmarshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Context = data
		case "inputParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputParams"))
			data, err := ec.unmarshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputParams = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalNAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "runtimeID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeID = data
		case "runtimeContextID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeContextID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeContextID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthRequestInput(ctx context.Context, obj interface{}) (BundleInstanceAuthRequestInput, error) {
	var it BundleInstanceAuthRequestInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "context", "inputParams"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "context":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
			data, err := ec.unmarshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Context = data
		case "inputParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputParams"))
			data, err := ec.unmarshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputParams = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthSetInput(ctx context.Context, obj interface{}) (BundleInstanceAuthSetInput, error) {
	var it BundleInstanceAuthSetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"auth", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBundleInstanceAuthStatusInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthStatusInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthStatusInput(ctx context.Context, obj interface{}) (BundleInstanceAuthStatusInput, error) {
	var it BundleInstanceAuthStatusInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["condition"]; !present {
		asMap["condition"] = "SUCCEEDED"
	}

	fieldsInOrder := [...]string{"condition", "message", "reason"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "condition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("condition"))
			data, err := ec.unmarshalNBundleInstanceAuthSetStatusConditionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthSetStatusConditionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Condition = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "reason":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reason"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Reason = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleInstanceAuthUpdateInput(ctx context.Context, obj interface{}) (BundleInstanceAuthUpdateInput, error) {
	var it BundleInstanceAuthUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"context", "inputParams", "auth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "context":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("context"))
			data, err := ec.unmarshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Context = data
		case "inputParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputParams"))
			data, err := ec.unmarshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputParams = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBundleUpdateInput(ctx context.Context, obj interface{}) (BundleUpdateInput, error) {
	var it BundleUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "instanceAuthRequestInputSchema", "defaultInstanceAuth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "instanceAuthRequestInputSchema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceAuthRequestInputSchema"))
			data, err := ec.unmarshalOJSONSchema2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSONSchema(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceAuthRequestInputSchema = data
		case "defaultInstanceAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultInstanceAuth"))
			data, err := ec.unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultInstanceAuth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBusinessTenantMappingInput(ctx context.Context, obj interface{}) (BusinessTenantMappingInput, error) {
	var it BusinessTenantMappingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "externalTenant", "parents", "subdomain", "region", "type", "provider", "licenseType", "customerId", "costObjectId", "costObjectType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "externalTenant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalTenant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalTenant = data
		case "parents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parents"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parents = data
		case "subdomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subdomain"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subdomain = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "licenseType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenseType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenseType = data
		case "customerId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customerId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomerID = data
		case "costObjectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costObjectId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CostObjectID = data
		case "costObjectType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costObjectType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CostObjectType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCSRFTokenCredentialRequestAuthInput(ctx context.Context, obj interface{}) (CSRFTokenCredentialRequestAuthInput, error) {
	var it CSRFTokenCredentialRequestAuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tokenEndpointURL", "credential", "additionalHeaders", "additionalHeadersSerialized", "additionalQueryParams", "additionalQueryParamsSerialized"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tokenEndpointURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenEndpointURL = data
		case "credential":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credential"))
			data, err := ec.unmarshalOCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Credential = data
		case "additionalHeaders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeaders"))
			data, err := ec.unmarshalOHttpHeaders2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeaders(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeaders = data
		case "additionalHeadersSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHeadersSerialized"))
			data, err := ec.unmarshalOHttpHeadersSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeadersSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalHeadersSerialized = data
		case "additionalQueryParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParams"))
			data, err := ec.unmarshalOQueryParams2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParams = data
		case "additionalQueryParamsSerialized":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalQueryParamsSerialized"))
			data, err := ec.unmarshalOQueryParamsSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParamsSerialized(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalQueryParamsSerialized = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCertificateOAuthCredentialDataInput(ctx context.Context, obj interface{}) (CertificateOAuthCredentialDataInput, error) {
	var it CertificateOAuthCredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientId", "certificate", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "certificate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certificate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Certificate = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCertificateSubjectMappingInput(ctx context.Context, obj interface{}) (CertificateSubjectMappingInput, error) {
	var it CertificateSubjectMappingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subject", "consumerType", "internalConsumerID", "tenantAccessLevels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subject"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subject = data
		case "consumerType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consumerType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConsumerType = data
		case "internalConsumerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("internalConsumerID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InternalConsumerID = data
		case "tenantAccessLevels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantAccessLevels"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TenantAccessLevels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialDataInput(ctx context.Context, obj interface{}) (CredentialDataInput, error) {
	var it CredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"basic", "oauth", "certificateOAuth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "basic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basic"))
			data, err := ec.unmarshalOBasicCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBasicCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Basic = data
		case "oauth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth"))
			data, err := ec.unmarshalOOAuthCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOAuthCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Oauth = data
		case "certificateOAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certificateOAuth"))
			data, err := ec.unmarshalOCertificateOAuthCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateOAuthCredentialDataInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CertificateOAuth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialRequestAuthInput(ctx context.Context, obj interface{}) (CredentialRequestAuthInput, error) {
	var it CredentialRequestAuthInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"csrf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "csrf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("csrf"))
			data, err := ec.unmarshalOCSRFTokenCredentialRequestAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCSRFTokenCredentialRequestAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Csrf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDocumentInput(ctx context.Context, obj interface{}) (DocumentInput, error) {
	var it DocumentInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "displayName", "description", "format", "kind", "data", "fetchRequest"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNDocumentFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "kind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Kind = data
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "fetchRequest":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetchRequest"))
			data, err := ec.unmarshalOFetchRequestInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchRequest = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventDefinitionInput(ctx context.Context, obj interface{}) (EventDefinitionInput, error) {
	var it EventDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "spec", "group", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "spec":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spec"))
			data, err := ec.unmarshalOEventSpecInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpecInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Spec = data
		case "group":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Group = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOVersionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventSpecInput(ctx context.Context, obj interface{}) (EventSpecInput, error) {
	var it EventSpecInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type", "format", "fetchRequest"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNEventSpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpecType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNSpecFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSpecFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "fetchRequest":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetchRequest"))
			data, err := ec.unmarshalOFetchRequestInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchRequest = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFetchRequestInput(ctx context.Context, obj interface{}) (FetchRequestInput, error) {
	var it FetchRequestInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["mode"]; !present {
		asMap["mode"] = "SINGLE"
	}

	fieldsInOrder := [...]string{"url", "auth", "mode", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOFetchMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "filter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationConstraintInput(ctx context.Context, obj interface{}) (FormationConstraintInput, error) {
	var it FormationConstraintInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "constraintType", "targetOperation", "operator", "resourceType", "resourceSubtype", "inputTemplate", "constraintScope", "priority"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "constraintType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintType"))
			data, err := ec.unmarshalNConstraintType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConstraintType = data
		case "targetOperation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetOperation"))
			data, err := ec.unmarshalNTargetOperation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTargetOperation(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetOperation = data
		case "operator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operator"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operator = data
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalNResourceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlResourceType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "resourceSubtype":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceSubtype"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceSubtype = data
		case "inputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputTemplate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputTemplate = data
		case "constraintScope":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("constraintScope"))
			data, err := ec.unmarshalNConstraintScope2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintScope(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConstraintScope = data
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Priority = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationConstraintUpdateInput(ctx context.Context, obj interface{}) (FormationConstraintUpdateInput, error) {
	var it FormationConstraintUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"inputTemplate", "priority", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "inputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputTemplate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputTemplate = data
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Priority = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationInput(ctx context.Context, obj interface{}) (FormationInput, error) {
	var it FormationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "templateName", "state"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "templateName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("templateName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TemplateName = data
		case "state":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				path, err := ec.unmarshalNString2string(ctx, "graphql.input.formation.state")
				if err != nil {
					return nil, err
				}
				if ec.directives.HasScopes == nil {
					return nil, errors.New("directive hasScopes is not implemented")
				}
				return ec.directives.HasScopes(ctx, obj, directive0, path)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.State = data
			} else if tmp == nil {
				it.State = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFormationTemplateInput(ctx context.Context, obj interface{}) (FormationTemplateInput, error) {
	var it FormationTemplateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "applicationTypes", "runtimeTypes", "runtimeTypeDisplayName", "runtimeArtifactKind", "webhooks", "leadingProductIDs", "supportsReset", "discoveryConsumers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "applicationTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationTypes"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationTypes = data
		case "runtimeTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeTypes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeTypes = data
		case "runtimeTypeDisplayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeTypeDisplayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeTypeDisplayName = data
		case "runtimeArtifactKind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeArtifactKind"))
			data, err := ec.unmarshalOArtifactType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlArtifactType(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeArtifactKind = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "leadingProductIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("leadingProductIDs"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LeadingProductIDs = data
		case "supportsReset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("supportsReset"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SupportsReset = data
		case "discoveryConsumers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discoveryConsumers"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DiscoveryConsumers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntegrationDependencyInput(ctx context.Context, obj interface{}) (IntegrationDependencyInput, error) {
	var it IntegrationDependencyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "ordID", "partOfPackage", "visibility", "releaseStatus", "mandatory", "aspects", "version", "labels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "ordID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrdID = data
		case "partOfPackage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("partOfPackage"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PartOfPackage = data
		case "visibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibility"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Visibility = data
		case "releaseStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseStatus"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReleaseStatus = data
		case "mandatory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mandatory"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mandatory = data
		case "aspects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aspects"))
			data, err := ec.unmarshalOAspectInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aspects = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOVersionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntegrationSystemInput(ctx context.Context, obj interface{}) (IntegrationSystemInput, error) {
	var it IntegrationSystemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelDefinitionInput(ctx context.Context, obj interface{}) (LabelDefinitionInput, error) {
	var it LabelDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "schema"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "schema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schema"))
			data, err := ec.unmarshalOJSONSchema2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSONSchema(ctx, v)
			if err != nil {
				return it, err
			}
			it.Schema = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelFilter(ctx context.Context, obj interface{}) (LabelFilter, error) {
	var it LabelFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "query"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "query":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelInput(ctx context.Context, obj interface{}) (LabelInput, error) {
	var it LabelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelSelectorInput(ctx context.Context, obj interface{}) (LabelSelectorInput, error) {
	var it LabelSelectorInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOAuthCredentialDataInput(ctx context.Context, obj interface{}) (OAuthCredentialDataInput, error) {
	var it OAuthCredentialDataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientId", "clientSecret", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecret = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOneTimeTokenInput(ctx context.Context, obj interface{}) (OneTimeTokenInput, error) {
	var it OneTimeTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token", "connectorURL", "used", "expiresAt", "createdAt", "usedAt", "raw", "rawEncoded", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		case "connectorURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorURL = data
		case "used":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("used"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Used = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "usedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usedAt"))
			data, err := ec.unmarshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsedAt = data
		case "raw":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("raw"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Raw = data
		case "rawEncoded":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawEncoded"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RawEncoded = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOOneTimeTokenType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaceholderDefinitionInput(ctx context.Context, obj interface{}) (PlaceholderDefinitionInput, error) {
	var it PlaceholderDefinitionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["optional"]; !present {
		asMap["optional"] = false
	}

	fieldsInOrder := [...]string{"name", "description", "jsonPath", "optional"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "jsonPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jsonPath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.JSONPath = data
		case "optional":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("optional"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Optional = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeContextInput(ctx context.Context, obj interface{}) (RuntimeContextInput, error) {
	var it RuntimeContextInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeRegisterInput(ctx context.Context, obj interface{}) (RuntimeRegisterInput, error) {
	var it RuntimeRegisterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "labels", "webhooks", "statusCondition", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "webhooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhooks"))
			data, err := ec.unmarshalOWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webhooks = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalORuntimeStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeUpdateInput(ctx context.Context, obj interface{}) (RuntimeUpdateInput, error) {
	var it RuntimeUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "labels", "statusCondition", "applicationNamespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "statusCondition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusCondition"))
			data, err := ec.unmarshalORuntimeStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatusCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusCondition = data
		case "applicationNamespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationNamespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ApplicationNamespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSystemAuthUpdateInput(ctx context.Context, obj interface{}) (SystemAuthUpdateInput, error) {
	var it SystemAuthUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"auth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTemplateValueInput(ctx context.Context, obj interface{}) (TemplateValueInput, error) {
	var it TemplateValueInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"placeholder", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "placeholder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placeholder"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Placeholder = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTenantAccessInput(ctx context.Context, obj interface{}) (TenantAccessInput, error) {
	var it TenantAccessInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tenantID", "resourceType", "resourceID", "owner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tenantID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TenantID = data
		case "resourceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceType"))
			data, err := ec.unmarshalNTenantAccessObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccessObjectType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "resourceID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceID = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVersionInput(ctx context.Context, obj interface{}) (VersionInput, error) {
	var it VersionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["deprecated"]; !present {
		asMap["deprecated"] = false
	}
	if _, present := asMap["forRemoval"]; !present {
		asMap["forRemoval"] = false
	}

	fieldsInOrder := [...]string{"value", "deprecated", "deprecatedSince", "forRemoval"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "deprecated":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deprecated"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deprecated = data
		case "deprecatedSince":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deprecatedSince"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeprecatedSince = data
		case "forRemoval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forRemoval"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ForRemoval = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookInput(ctx context.Context, obj interface{}) (WebhookInput, error) {
	var it WebhookInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "url", "auth", "mode", "version", "correlationIdKey", "retryInterval", "timeout", "urlTemplate", "inputTemplate", "headerTemplate", "outputTemplate", "statusTemplate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalOWebhookMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "correlationIdKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("correlationIdKey"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CorrelationIDKey = data
		case "retryInterval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryInterval"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RetryInterval = data
		case "timeout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeout"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timeout = data
		case "urlTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlTemplate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URLTemplate = data
		case "inputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inputTemplate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InputTemplate = data
		case "headerTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headerTemplate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HeaderTemplate = data
		case "outputTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("outputTemplate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OutputTemplate = data
		case "statusTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusTemplate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusTemplate = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _CredentialData(ctx context.Context, sel ast.SelectionSet, obj CredentialData) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case BasicCredentialData:
		return ec._BasicCredentialData(ctx, sel, &obj)
	case *BasicCredentialData:
		if obj == nil {
			return graphql.Null
		}
		return ec._BasicCredentialData(ctx, sel, obj)
	case OAuthCredentialData:
		return ec._OAuthCredentialData(ctx, sel, &obj)
	case *OAuthCredentialData:
		if obj == nil {
			return graphql.Null
		}
		return ec._OAuthCredentialData(ctx, sel, obj)
	case CertificateOAuthCredentialData:
		return ec._CertificateOAuthCredentialData(ctx, sel, &obj)
	case *CertificateOAuthCredentialData:
		if obj == nil {
			return graphql.Null
		}
		return ec._CertificateOAuthCredentialData(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _FormationParticipant(ctx context.Context, sel ast.SelectionSet, obj FormationParticipant) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *Application:
		if obj == nil {
			return graphql.Null
		}
		return ec._Application(ctx, sel, obj)
	case *Runtime:
		if obj == nil {
			return graphql.Null
		}
		return ec._Runtime(ctx, sel, obj)
	case *RuntimeContext:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimeContext(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _OneTimeToken(ctx context.Context, sel ast.SelectionSet, obj OneTimeToken) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *OneTimeTokenForApplication:
		if obj == nil {
			return graphql.Null
		}
		return ec._OneTimeTokenForApplication(ctx, sel, obj)
	case *OneTimeTokenForRuntime:
		if obj == nil {
			return graphql.Null
		}
		return ec._OneTimeTokenForRuntime(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Pageable(ctx context.Context, sel ast.SelectionSet, obj Pageable) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case APIDefinitionPage:
		return ec._APIDefinitionPage(ctx, sel, &obj)
	case *APIDefinitionPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._APIDefinitionPage(ctx, sel, obj)
	case ApplicationPage:
		return ec._ApplicationPage(ctx, sel, &obj)
	case *ApplicationPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationPage(ctx, sel, obj)
	case ApplicationTemplatePage:
		return ec._ApplicationTemplatePage(ctx, sel, &obj)
	case *ApplicationTemplatePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationTemplatePage(ctx, sel, obj)
	case AutomaticScenarioAssignmentPage:
		return ec._AutomaticScenarioAssignmentPage(ctx, sel, &obj)
	case *AutomaticScenarioAssignmentPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._AutomaticScenarioAssignmentPage(ctx, sel, obj)
	case BundlePage:
		return ec._BundlePage(ctx, sel, &obj)
	case *BundlePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._BundlePage(ctx, sel, obj)
	case CertificateSubjectMappingPage:
		return ec._CertificateSubjectMappingPage(ctx, sel, &obj)
	case *CertificateSubjectMappingPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._CertificateSubjectMappingPage(ctx, sel, obj)
	case DocumentPage:
		return ec._DocumentPage(ctx, sel, &obj)
	case *DocumentPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._DocumentPage(ctx, sel, obj)
	case EventDefinitionPage:
		return ec._EventDefinitionPage(ctx, sel, &obj)
	case *EventDefinitionPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._EventDefinitionPage(ctx, sel, obj)
	case FormationAssignmentPage:
		return ec._FormationAssignmentPage(ctx, sel, &obj)
	case *FormationAssignmentPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._FormationAssignmentPage(ctx, sel, obj)
	case FormationPage:
		return ec._FormationPage(ctx, sel, &obj)
	case *FormationPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._FormationPage(ctx, sel, obj)
	case FormationTemplatePage:
		return ec._FormationTemplatePage(ctx, sel, &obj)
	case *FormationTemplatePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._FormationTemplatePage(ctx, sel, obj)
	case HealthCheckPage:
		return ec._HealthCheckPage(ctx, sel, &obj)
	case *HealthCheckPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._HealthCheckPage(ctx, sel, obj)
	case IntegrationDependencyPage:
		return ec._IntegrationDependencyPage(ctx, sel, &obj)
	case *IntegrationDependencyPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._IntegrationDependencyPage(ctx, sel, obj)
	case IntegrationSystemPage:
		return ec._IntegrationSystemPage(ctx, sel, &obj)
	case *IntegrationSystemPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._IntegrationSystemPage(ctx, sel, obj)
	case RuntimeContextPage:
		return ec._RuntimeContextPage(ctx, sel, &obj)
	case *RuntimeContextPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimeContextPage(ctx, sel, obj)
	case RuntimePage:
		return ec._RuntimePage(ctx, sel, &obj)
	case *RuntimePage:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimePage(ctx, sel, obj)
	case TenantPage:
		return ec._TenantPage(ctx, sel, &obj)
	case *TenantPage:
		if obj == nil {
			return graphql.Null
		}
		return ec._TenantPage(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SystemAuth(ctx context.Context, sel ast.SelectionSet, obj SystemAuth) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case AppSystemAuth:
		return ec._AppSystemAuth(ctx, sel, &obj)
	case *AppSystemAuth:
		if obj == nil {
			return graphql.Null
		}
		return ec._AppSystemAuth(ctx, sel, obj)
	case IntSysSystemAuth:
		return ec._IntSysSystemAuth(ctx, sel, &obj)
	case *IntSysSystemAuth:
		if obj == nil {
			return graphql.Null
		}
		return ec._IntSysSystemAuth(ctx, sel, obj)
	case RuntimeSystemAuth:
		return ec._RuntimeSystemAuth(ctx, sel, &obj)
	case *RuntimeSystemAuth:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuntimeSystemAuth(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aPIDefinitionImplementors = []string{"APIDefinition"}

func (ec *executionContext) _APIDefinition(ctx context.Context, sel ast.SelectionSet, obj *APIDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPIDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIDefinition")
		case "id":
			out.Values[i] = ec._APIDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._APIDefinition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._APIDefinition_description(ctx, field, obj)
		case "spec":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._APIDefinition_spec(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "targetURL":
			out.Values[i] = ec._APIDefinition_targetURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "group":
			out.Values[i] = ec._APIDefinition_group(ctx, field, obj)
		case "version":
			out.Values[i] = ec._APIDefinition_version(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._APIDefinition_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._APIDefinition_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._APIDefinition_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._APIDefinition_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aPIDefinitionPageImplementors = []string{"APIDefinitionPage", "Pageable"}

func (ec *executionContext) _APIDefinitionPage(ctx context.Context, sel ast.SelectionSet, obj *APIDefinitionPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPIDefinitionPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIDefinitionPage")
		case "data":
			out.Values[i] = ec._APIDefinitionPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._APIDefinitionPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._APIDefinitionPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aPISpecImplementors = []string{"APISpec"}

func (ec *executionContext) _APISpec(ctx context.Context, sel ast.SelectionSet, obj *APISpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPISpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APISpec")
		case "id":
			out.Values[i] = ec._APISpec_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._APISpec_data(ctx, field, obj)
		case "format":
			out.Values[i] = ec._APISpec_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._APISpec_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fetchRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._APISpec_fetchRequest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var appSystemAuthImplementors = []string{"AppSystemAuth", "SystemAuth"}

func (ec *executionContext) _AppSystemAuth(ctx context.Context, sel ast.SelectionSet, obj *AppSystemAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, appSystemAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AppSystemAuth")
		case "id":
			out.Values[i] = ec._AppSystemAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._AppSystemAuth_auth(ctx, field, obj)
		case "type":
			out.Values[i] = ec._AppSystemAuth_type(ctx, field, obj)
		case "tenantId":
			out.Values[i] = ec._AppSystemAuth_tenantId(ctx, field, obj)
		case "referenceObjectId":
			out.Values[i] = ec._AppSystemAuth_referenceObjectId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationImplementors = []string{"Application", "FormationParticipant"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "id":
			out.Values[i] = ec._Application_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Application_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "systemNumber":
			out.Values[i] = ec._Application_systemNumber(ctx, field, obj)
		case "localTenantID":
			out.Values[i] = ec._Application_localTenantID(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._Application_baseUrl(ctx, field, obj)
		case "providerName":
			out.Values[i] = ec._Application_providerName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Application_description(ctx, field, obj)
		case "integrationSystemID":
			out.Values[i] = ec._Application_integrationSystemID(ctx, field, obj)
		case "applicationTemplateID":
			out.Values[i] = ec._Application_applicationTemplateID(ctx, field, obj)
		case "applicationTemplate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_applicationTemplate(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Application_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "healthCheckURL":
			out.Values[i] = ec._Application_healthCheckURL(ctx, field, obj)
		case "bundles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_bundles(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bundle":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_bundle(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "apiDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_apiDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_eventDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "integrationDependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_integrationDependencies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "auths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_auths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventingConfiguration":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Application_eventingConfiguration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applicationNamespace":
			out.Values[i] = ec._Application_applicationNamespace(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Application_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Application_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Application_deletedAt(ctx, field, obj)
		case "systemStatus":
			out.Values[i] = ec._Application_systemStatus(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Application_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationEventingConfigurationImplementors = []string{"ApplicationEventingConfiguration"}

func (ec *executionContext) _ApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, obj *ApplicationEventingConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationEventingConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationEventingConfiguration")
		case "defaultURL":
			out.Values[i] = ec._ApplicationEventingConfiguration_defaultURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationPageImplementors = []string{"ApplicationPage", "Pageable"}

func (ec *executionContext) _ApplicationPage(ctx context.Context, sel ast.SelectionSet, obj *ApplicationPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationPage")
		case "data":
			out.Values[i] = ec._ApplicationPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ApplicationPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ApplicationPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationStatusImplementors = []string{"ApplicationStatus"}

func (ec *executionContext) _ApplicationStatus(ctx context.Context, sel ast.SelectionSet, obj *ApplicationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationStatus")
		case "condition":
			out.Values[i] = ec._ApplicationStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ApplicationStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationTemplateImplementors = []string{"ApplicationTemplate"}

func (ec *executionContext) _ApplicationTemplate(ctx context.Context, sel ast.SelectionSet, obj *ApplicationTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationTemplate")
		case "id":
			out.Values[i] = ec._ApplicationTemplate_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ApplicationTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._ApplicationTemplate_description(ctx, field, obj)
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationTemplate_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applicationInput":
			out.Values[i] = ec._ApplicationTemplate_applicationInput(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "placeholders":
			out.Values[i] = ec._ApplicationTemplate_placeholders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationTemplate_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accessLevel":
			out.Values[i] = ec._ApplicationTemplate_accessLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "applicationNamespace":
			out.Values[i] = ec._ApplicationTemplate_applicationNamespace(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ApplicationTemplate_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._ApplicationTemplate_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationTemplatePageImplementors = []string{"ApplicationTemplatePage", "Pageable"}

func (ec *executionContext) _ApplicationTemplatePage(ctx context.Context, sel ast.SelectionSet, obj *ApplicationTemplatePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationTemplatePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationTemplatePage")
		case "data":
			out.Values[i] = ec._ApplicationTemplatePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ApplicationTemplatePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ApplicationTemplatePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectImplementors = []string{"Aspect"}

func (ec *executionContext) _Aspect(ctx context.Context, sel ast.SelectionSet, obj *Aspect) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Aspect")
		case "id":
			out.Values[i] = ec._Aspect_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Aspect_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Aspect_description(ctx, field, obj)
		case "mandatory":
			out.Values[i] = ec._Aspect_mandatory(ctx, field, obj)
		case "apiResources":
			out.Values[i] = ec._Aspect_apiResources(ctx, field, obj)
		case "eventResources":
			out.Values[i] = ec._Aspect_eventResources(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._Aspect_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._Aspect_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._Aspect_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Aspect_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectAPIDefinitionImplementors = []string{"AspectAPIDefinition"}

func (ec *executionContext) _AspectAPIDefinition(ctx context.Context, sel ast.SelectionSet, obj *AspectAPIDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectAPIDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AspectAPIDefinition")
		case "ordID":
			out.Values[i] = ec._AspectAPIDefinition_ordID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectEventDefinitionImplementors = []string{"AspectEventDefinition"}

func (ec *executionContext) _AspectEventDefinition(ctx context.Context, sel ast.SelectionSet, obj *AspectEventDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectEventDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AspectEventDefinition")
		case "ordID":
			out.Values[i] = ec._AspectEventDefinition_ordID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subset":
			out.Values[i] = ec._AspectEventDefinition_subset(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._AspectEventDefinition_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._AspectEventDefinition_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._AspectEventDefinition_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._AspectEventDefinition_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aspectEventDefinitionSubsetImplementors = []string{"AspectEventDefinitionSubset"}

func (ec *executionContext) _AspectEventDefinitionSubset(ctx context.Context, sel ast.SelectionSet, obj *AspectEventDefinitionSubset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aspectEventDefinitionSubsetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AspectEventDefinitionSubset")
		case "eventType":
			out.Values[i] = ec._AspectEventDefinitionSubset_eventType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authImplementors = []string{"Auth"}

func (ec *executionContext) _Auth(ctx context.Context, sel ast.SelectionSet, obj *Auth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Auth")
		case "credential":
			out.Values[i] = ec._Auth_credential(ctx, field, obj)
		case "accessStrategy":
			out.Values[i] = ec._Auth_accessStrategy(ctx, field, obj)
		case "additionalHeaders":
			out.Values[i] = ec._Auth_additionalHeaders(ctx, field, obj)
		case "additionalHeadersSerialized":
			out.Values[i] = ec._Auth_additionalHeadersSerialized(ctx, field, obj)
		case "additionalQueryParams":
			out.Values[i] = ec._Auth_additionalQueryParams(ctx, field, obj)
		case "additionalQueryParamsSerialized":
			out.Values[i] = ec._Auth_additionalQueryParamsSerialized(ctx, field, obj)
		case "requestAuth":
			out.Values[i] = ec._Auth_requestAuth(ctx, field, obj)
		case "oneTimeToken":
			out.Values[i] = ec._Auth_oneTimeToken(ctx, field, obj)
		case "certCommonName":
			out.Values[i] = ec._Auth_certCommonName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var automaticScenarioAssignmentImplementors = []string{"AutomaticScenarioAssignment"}

func (ec *executionContext) _AutomaticScenarioAssignment(ctx context.Context, sel ast.SelectionSet, obj *AutomaticScenarioAssignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, automaticScenarioAssignmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AutomaticScenarioAssignment")
		case "scenarioName":
			out.Values[i] = ec._AutomaticScenarioAssignment_scenarioName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selector":
			out.Values[i] = ec._AutomaticScenarioAssignment_selector(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var automaticScenarioAssignmentPageImplementors = []string{"AutomaticScenarioAssignmentPage", "Pageable"}

func (ec *executionContext) _AutomaticScenarioAssignmentPage(ctx context.Context, sel ast.SelectionSet, obj *AutomaticScenarioAssignmentPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, automaticScenarioAssignmentPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AutomaticScenarioAssignmentPage")
		case "data":
			out.Values[i] = ec._AutomaticScenarioAssignmentPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._AutomaticScenarioAssignmentPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._AutomaticScenarioAssignmentPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var basicCredentialDataImplementors = []string{"BasicCredentialData", "CredentialData"}

func (ec *executionContext) _BasicCredentialData(ctx context.Context, sel ast.SelectionSet, obj *BasicCredentialData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, basicCredentialDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BasicCredentialData")
		case "username":
			out.Values[i] = ec._BasicCredentialData_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "password":
			out.Values[i] = ec._BasicCredentialData_password(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundleImplementors = []string{"Bundle"}

func (ec *executionContext) _Bundle(ctx context.Context, sel ast.SelectionSet, obj *Bundle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bundle")
		case "id":
			out.Values[i] = ec._Bundle_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Bundle_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Bundle_description(ctx, field, obj)
		case "instanceAuthRequestInputSchema":
			out.Values[i] = ec._Bundle_instanceAuthRequestInputSchema(ctx, field, obj)
		case "instanceAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_instanceAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "instanceAuths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_instanceAuths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "defaultInstanceAuth":
			out.Values[i] = ec._Bundle_defaultInstanceAuth(ctx, field, obj)
		case "apiDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_apiDefinitions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_eventDefinitions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "documents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_documents(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "apiDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_apiDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_eventDefinition(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "correlationIDs":
			out.Values[i] = ec._Bundle_correlationIDs(ctx, field, obj)
		case "document":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Bundle_document(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Bundle_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Bundle_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Bundle_deletedAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Bundle_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundleInstanceAuthImplementors = []string{"BundleInstanceAuth"}

func (ec *executionContext) _BundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, obj *BundleInstanceAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundleInstanceAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BundleInstanceAuth")
		case "id":
			out.Values[i] = ec._BundleInstanceAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "context":
			out.Values[i] = ec._BundleInstanceAuth_context(ctx, field, obj)
		case "inputParams":
			out.Values[i] = ec._BundleInstanceAuth_inputParams(ctx, field, obj)
		case "auth":
			out.Values[i] = ec._BundleInstanceAuth_auth(ctx, field, obj)
		case "status":
			out.Values[i] = ec._BundleInstanceAuth_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runtimeID":
			out.Values[i] = ec._BundleInstanceAuth_runtimeID(ctx, field, obj)
		case "runtimeContextID":
			out.Values[i] = ec._BundleInstanceAuth_runtimeContextID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundleInstanceAuthStatusImplementors = []string{"BundleInstanceAuthStatus"}

func (ec *executionContext) _BundleInstanceAuthStatus(ctx context.Context, sel ast.SelectionSet, obj *BundleInstanceAuthStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundleInstanceAuthStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BundleInstanceAuthStatus")
		case "condition":
			out.Values[i] = ec._BundleInstanceAuthStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._BundleInstanceAuthStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._BundleInstanceAuthStatus_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._BundleInstanceAuthStatus_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bundlePageImplementors = []string{"BundlePage", "Pageable"}

func (ec *executionContext) _BundlePage(ctx context.Context, sel ast.SelectionSet, obj *BundlePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bundlePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BundlePage")
		case "data":
			out.Values[i] = ec._BundlePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._BundlePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._BundlePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cSRFTokenCredentialRequestAuthImplementors = []string{"CSRFTokenCredentialRequestAuth"}

func (ec *executionContext) _CSRFTokenCredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, obj *CSRFTokenCredentialRequestAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cSRFTokenCredentialRequestAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CSRFTokenCredentialRequestAuth")
		case "tokenEndpointURL":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_tokenEndpointURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "credential":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_credential(ctx, field, obj)
		case "additionalHeaders":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalHeaders(ctx, field, obj)
		case "additionalHeadersSerialized":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalHeadersSerialized(ctx, field, obj)
		case "additionalQueryParams":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalQueryParams(ctx, field, obj)
		case "additionalQueryParamsSerialized":
			out.Values[i] = ec._CSRFTokenCredentialRequestAuth_additionalQueryParamsSerialized(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var certificateOAuthCredentialDataImplementors = []string{"CertificateOAuthCredentialData", "CredentialData"}

func (ec *executionContext) _CertificateOAuthCredentialData(ctx context.Context, sel ast.SelectionSet, obj *CertificateOAuthCredentialData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, certificateOAuthCredentialDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CertificateOAuthCredentialData")
		case "clientId":
			out.Values[i] = ec._CertificateOAuthCredentialData_clientId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "certificate":
			out.Values[i] = ec._CertificateOAuthCredentialData_certificate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._CertificateOAuthCredentialData_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var certificateSubjectMappingImplementors = []string{"CertificateSubjectMapping"}

func (ec *executionContext) _CertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, obj *CertificateSubjectMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, certificateSubjectMappingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CertificateSubjectMapping")
		case "id":
			out.Values[i] = ec._CertificateSubjectMapping_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subject":
			out.Values[i] = ec._CertificateSubjectMapping_subject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consumerType":
			out.Values[i] = ec._CertificateSubjectMapping_consumerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "internalConsumerID":
			out.Values[i] = ec._CertificateSubjectMapping_internalConsumerID(ctx, field, obj)
		case "tenantAccessLevels":
			out.Values[i] = ec._CertificateSubjectMapping_tenantAccessLevels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var certificateSubjectMappingPageImplementors = []string{"CertificateSubjectMappingPage", "Pageable"}

func (ec *executionContext) _CertificateSubjectMappingPage(ctx context.Context, sel ast.SelectionSet, obj *CertificateSubjectMappingPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, certificateSubjectMappingPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CertificateSubjectMappingPage")
		case "data":
			out.Values[i] = ec._CertificateSubjectMappingPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._CertificateSubjectMappingPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._CertificateSubjectMappingPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var constraintReferenceImplementors = []string{"ConstraintReference"}

func (ec *executionContext) _ConstraintReference(ctx context.Context, sel ast.SelectionSet, obj *ConstraintReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, constraintReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConstraintReference")
		case "constraintID":
			out.Values[i] = ec._ConstraintReference_constraintID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "formationTemplateID":
			out.Values[i] = ec._ConstraintReference_formationTemplateID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var credentialRequestAuthImplementors = []string{"CredentialRequestAuth"}

func (ec *executionContext) _CredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, obj *CredentialRequestAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialRequestAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialRequestAuth")
		case "csrf":
			out.Values[i] = ec._CredentialRequestAuth_csrf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var documentImplementors = []string{"Document"}

func (ec *executionContext) _Document(ctx context.Context, sel ast.SelectionSet, obj *Document) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Document")
		case "id":
			out.Values[i] = ec._Document_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Document_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._Document_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Document_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "format":
			out.Values[i] = ec._Document_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "kind":
			out.Values[i] = ec._Document_kind(ctx, field, obj)
		case "data":
			out.Values[i] = ec._Document_data(ctx, field, obj)
		case "fetchRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Document_fetchRequest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Document_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Document_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Document_deletedAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Document_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var documentPageImplementors = []string{"DocumentPage", "Pageable"}

func (ec *executionContext) _DocumentPage(ctx context.Context, sel ast.SelectionSet, obj *DocumentPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocumentPage")
		case "data":
			out.Values[i] = ec._DocumentPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._DocumentPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._DocumentPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventDefinitionImplementors = []string{"EventDefinition"}

func (ec *executionContext) _EventDefinition(ctx context.Context, sel ast.SelectionSet, obj *EventDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventDefinition")
		case "id":
			out.Values[i] = ec._EventDefinition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._EventDefinition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._EventDefinition_description(ctx, field, obj)
		case "group":
			out.Values[i] = ec._EventDefinition_group(ctx, field, obj)
		case "spec":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventDefinition_spec(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			out.Values[i] = ec._EventDefinition_version(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._EventDefinition_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._EventDefinition_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._EventDefinition_deletedAt(ctx, field, obj)
		case "error":
			out.Values[i] = ec._EventDefinition_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventDefinitionPageImplementors = []string{"EventDefinitionPage", "Pageable"}

func (ec *executionContext) _EventDefinitionPage(ctx context.Context, sel ast.SelectionSet, obj *EventDefinitionPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventDefinitionPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventDefinitionPage")
		case "data":
			out.Values[i] = ec._EventDefinitionPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._EventDefinitionPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._EventDefinitionPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventSpecImplementors = []string{"EventSpec"}

func (ec *executionContext) _EventSpec(ctx context.Context, sel ast.SelectionSet, obj *EventSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventSpec")
		case "id":
			out.Values[i] = ec._EventSpec_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._EventSpec_data(ctx, field, obj)
		case "type":
			out.Values[i] = ec._EventSpec_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "format":
			out.Values[i] = ec._EventSpec_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fetchRequest":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventSpec_fetchRequest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fetchRequestImplementors = []string{"FetchRequest"}

func (ec *executionContext) _FetchRequest(ctx context.Context, sel ast.SelectionSet, obj *FetchRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fetchRequestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FetchRequest")
		case "url":
			out.Values[i] = ec._FetchRequest_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._FetchRequest_auth(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._FetchRequest_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filter":
			out.Values[i] = ec._FetchRequest_filter(ctx, field, obj)
		case "status":
			out.Values[i] = ec._FetchRequest_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fetchRequestStatusImplementors = []string{"FetchRequestStatus"}

func (ec *executionContext) _FetchRequestStatus(ctx context.Context, sel ast.SelectionSet, obj *FetchRequestStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fetchRequestStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FetchRequestStatus")
		case "condition":
			out.Values[i] = ec._FetchRequestStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._FetchRequestStatus_message(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._FetchRequestStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationImplementors = []string{"Formation"}

func (ec *executionContext) _Formation(ctx context.Context, sel ast.SelectionSet, obj *Formation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Formation")
		case "id":
			out.Values[i] = ec._Formation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Formation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "formationTemplateId":
			out.Values[i] = ec._Formation_formationTemplateId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tenantID":
			out.Values[i] = ec._Formation_tenantID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "state":
			out.Values[i] = ec._Formation_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error":
			out.Values[i] = ec._Formation_error(ctx, field, obj)
		case "formationAssignment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Formation_formationAssignment(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "formationAssignments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Formation_formationAssignments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Formation_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastStateChangeTimestamp":
			out.Values[i] = ec._Formation_lastStateChangeTimestamp(ctx, field, obj)
		case "lastNotificationSentTimestamp":
			out.Values[i] = ec._Formation_lastNotificationSentTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationAssignmentImplementors = []string{"FormationAssignment"}

func (ec *executionContext) _FormationAssignment(ctx context.Context, sel ast.SelectionSet, obj *FormationAssignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationAssignmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationAssignment")
		case "id":
			out.Values[i] = ec._FormationAssignment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source":
			out.Values[i] = ec._FormationAssignment_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sourceType":
			out.Values[i] = ec._FormationAssignment_sourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sourceEntity":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationAssignment_sourceEntity(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "target":
			out.Values[i] = ec._FormationAssignment_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetType":
			out.Values[i] = ec._FormationAssignment_targetType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetEntity":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationAssignment_targetEntity(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "state":
			out.Values[i] = ec._FormationAssignment_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "value":
			out.Values[i] = ec._FormationAssignment_value(ctx, field, obj)
		case "configuration":
			out.Values[i] = ec._FormationAssignment_configuration(ctx, field, obj)
		case "error":
			out.Values[i] = ec._FormationAssignment_error(ctx, field, obj)
		case "lastStateChangeTimestamp":
			out.Values[i] = ec._FormationAssignment_lastStateChangeTimestamp(ctx, field, obj)
		case "lastNotificationSentTimestamp":
			out.Values[i] = ec._FormationAssignment_lastNotificationSentTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationAssignmentPageImplementors = []string{"FormationAssignmentPage", "Pageable"}

func (ec *executionContext) _FormationAssignmentPage(ctx context.Context, sel ast.SelectionSet, obj *FormationAssignmentPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationAssignmentPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationAssignmentPage")
		case "data":
			out.Values[i] = ec._FormationAssignmentPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._FormationAssignmentPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._FormationAssignmentPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationConstraintImplementors = []string{"FormationConstraint"}

func (ec *executionContext) _FormationConstraint(ctx context.Context, sel ast.SelectionSet, obj *FormationConstraint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationConstraintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationConstraint")
		case "id":
			out.Values[i] = ec._FormationConstraint_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FormationConstraint_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._FormationConstraint_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "constraintType":
			out.Values[i] = ec._FormationConstraint_constraintType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "targetOperation":
			out.Values[i] = ec._FormationConstraint_targetOperation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operator":
			out.Values[i] = ec._FormationConstraint_operator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._FormationConstraint_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceSubtype":
			out.Values[i] = ec._FormationConstraint_resourceSubtype(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "inputTemplate":
			out.Values[i] = ec._FormationConstraint_inputTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "constraintScope":
			out.Values[i] = ec._FormationConstraint_constraintScope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._FormationConstraint_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._FormationConstraint_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationErrorImplementors = []string{"FormationError"}

func (ec *executionContext) _FormationError(ctx context.Context, sel ast.SelectionSet, obj *FormationError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationError")
		case "message":
			out.Values[i] = ec._FormationError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCode":
			out.Values[i] = ec._FormationError_errorCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationPageImplementors = []string{"FormationPage", "Pageable"}

func (ec *executionContext) _FormationPage(ctx context.Context, sel ast.SelectionSet, obj *FormationPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationPage")
		case "data":
			out.Values[i] = ec._FormationPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._FormationPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._FormationPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationStatusImplementors = []string{"FormationStatus"}

func (ec *executionContext) _FormationStatus(ctx context.Context, sel ast.SelectionSet, obj *FormationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationStatus")
		case "condition":
			out.Values[i] = ec._FormationStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._FormationStatus_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationStatusErrorImplementors = []string{"FormationStatusError"}

func (ec *executionContext) _FormationStatusError(ctx context.Context, sel ast.SelectionSet, obj *FormationStatusError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationStatusErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationStatusError")
		case "assignmentID":
			out.Values[i] = ec._FormationStatusError_assignmentID(ctx, field, obj)
		case "message":
			out.Values[i] = ec._FormationStatusError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCode":
			out.Values[i] = ec._FormationStatusError_errorCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationTemplateImplementors = []string{"FormationTemplate"}

func (ec *executionContext) _FormationTemplate(ctx context.Context, sel ast.SelectionSet, obj *FormationTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationTemplate")
		case "id":
			out.Values[i] = ec._FormationTemplate_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._FormationTemplate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "applicationTypes":
			out.Values[i] = ec._FormationTemplate_applicationTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "runtimeTypes":
			out.Values[i] = ec._FormationTemplate_runtimeTypes(ctx, field, obj)
		case "runtimeTypeDisplayName":
			out.Values[i] = ec._FormationTemplate_runtimeTypeDisplayName(ctx, field, obj)
		case "runtimeArtifactKind":
			out.Values[i] = ec._FormationTemplate_runtimeArtifactKind(ctx, field, obj)
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationTemplate_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "leadingProductIDs":
			out.Values[i] = ec._FormationTemplate_leadingProductIDs(ctx, field, obj)
		case "formationConstraints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FormationTemplate_formationConstraints(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "supportsReset":
			out.Values[i] = ec._FormationTemplate_supportsReset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "discoveryConsumers":
			out.Values[i] = ec._FormationTemplate_discoveryConsumers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var formationTemplatePageImplementors = []string{"FormationTemplatePage", "Pageable"}

func (ec *executionContext) _FormationTemplatePage(ctx context.Context, sel ast.SelectionSet, obj *FormationTemplatePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, formationTemplatePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FormationTemplatePage")
		case "data":
			out.Values[i] = ec._FormationTemplatePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._FormationTemplatePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._FormationTemplatePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthCheckImplementors = []string{"HealthCheck"}

func (ec *executionContext) _HealthCheck(ctx context.Context, sel ast.SelectionSet, obj *HealthCheck) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthCheck")
		case "type":
			out.Values[i] = ec._HealthCheck_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "condition":
			out.Values[i] = ec._HealthCheck_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "origin":
			out.Values[i] = ec._HealthCheck_origin(ctx, field, obj)
		case "message":
			out.Values[i] = ec._HealthCheck_message(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._HealthCheck_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var healthCheckPageImplementors = []string{"HealthCheckPage", "Pageable"}

func (ec *executionContext) _HealthCheckPage(ctx context.Context, sel ast.SelectionSet, obj *HealthCheckPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthCheckPage")
		case "data":
			out.Values[i] = ec._HealthCheckPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._HealthCheckPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._HealthCheckPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var intSysSystemAuthImplementors = []string{"IntSysSystemAuth", "SystemAuth"}

func (ec *executionContext) _IntSysSystemAuth(ctx context.Context, sel ast.SelectionSet, obj *IntSysSystemAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, intSysSystemAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntSysSystemAuth")
		case "id":
			out.Values[i] = ec._IntSysSystemAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._IntSysSystemAuth_auth(ctx, field, obj)
		case "type":
			out.Values[i] = ec._IntSysSystemAuth_type(ctx, field, obj)
		case "tenantId":
			out.Values[i] = ec._IntSysSystemAuth_tenantId(ctx, field, obj)
		case "referenceObjectId":
			out.Values[i] = ec._IntSysSystemAuth_referenceObjectId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationDependencyImplementors = []string{"IntegrationDependency"}

func (ec *executionContext) _IntegrationDependency(ctx context.Context, sel ast.SelectionSet, obj *IntegrationDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationDependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationDependency")
		case "id":
			out.Values[i] = ec._IntegrationDependency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._IntegrationDependency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._IntegrationDependency_description(ctx, field, obj)
		case "ordID":
			out.Values[i] = ec._IntegrationDependency_ordID(ctx, field, obj)
		case "partOfPackage":
			out.Values[i] = ec._IntegrationDependency_partOfPackage(ctx, field, obj)
		case "visibility":
			out.Values[i] = ec._IntegrationDependency_visibility(ctx, field, obj)
		case "releaseStatus":
			out.Values[i] = ec._IntegrationDependency_releaseStatus(ctx, field, obj)
		case "mandatory":
			out.Values[i] = ec._IntegrationDependency_mandatory(ctx, field, obj)
		case "aspects":
			out.Values[i] = ec._IntegrationDependency_aspects(ctx, field, obj)
		case "version":
			out.Values[i] = ec._IntegrationDependency_version(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._IntegrationDependency_labels(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._IntegrationDependency_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._IntegrationDependency_updated_at(ctx, field, obj)
		case "deleted_at":
			out.Values[i] = ec._IntegrationDependency_deleted_at(ctx, field, obj)
		case "error":
			out.Values[i] = ec._IntegrationDependency_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationDependencyPageImplementors = []string{"IntegrationDependencyPage", "Pageable"}

func (ec *executionContext) _IntegrationDependencyPage(ctx context.Context, sel ast.SelectionSet, obj *IntegrationDependencyPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationDependencyPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationDependencyPage")
		case "data":
			out.Values[i] = ec._IntegrationDependencyPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._IntegrationDependencyPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._IntegrationDependencyPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationSystemImplementors = []string{"IntegrationSystem"}

func (ec *executionContext) _IntegrationSystem(ctx context.Context, sel ast.SelectionSet, obj *IntegrationSystem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationSystemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationSystem")
		case "id":
			out.Values[i] = ec._IntegrationSystem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._IntegrationSystem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._IntegrationSystem_description(ctx, field, obj)
		case "auths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IntegrationSystem_auths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationSystemPageImplementors = []string{"IntegrationSystemPage", "Pageable"}

func (ec *executionContext) _IntegrationSystemPage(ctx context.Context, sel ast.SelectionSet, obj *IntegrationSystemPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationSystemPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationSystemPage")
		case "data":
			out.Values[i] = ec._IntegrationSystemPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._IntegrationSystemPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._IntegrationSystemPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var labelImplementors = []string{"Label"}

func (ec *executionContext) _Label(ctx context.Context, sel ast.SelectionSet, obj *Label) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Label")
		case "key":
			out.Values[i] = ec._Label_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Label_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var labelDefinitionImplementors = []string{"LabelDefinition"}

func (ec *executionContext) _LabelDefinition(ctx context.Context, sel ast.SelectionSet, obj *LabelDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelDefinition")
		case "key":
			out.Values[i] = ec._LabelDefinition_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schema":
			out.Values[i] = ec._LabelDefinition_schema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "registerApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unpairApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unpairApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createApplicationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createApplicationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerApplicationFromTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerApplicationFromTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateApplicationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateApplicationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteApplicationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApplicationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeApplications":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_mergeApplications(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerRuntimeContext":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerRuntimeContext(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRuntimeContext":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRuntimeContext(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterRuntimeContext":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterRuntimeContext(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "registerIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unregisterIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addAPIDefinitionToBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAPIDefinitionToBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addAPIDefinitionToApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAPIDefinitionToApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAPIDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAPIDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAPIDefinitionForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAPIDefinitionForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteAPIDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAPIDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refetchAPISpec":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refetchAPISpec(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addIntegrationDependencyToApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addIntegrationDependencyToApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteIntegrationDependency":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteIntegrationDependency(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestOneTimeTokenForRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestOneTimeTokenForRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestOneTimeTokenForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestOneTimeTokenForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestClientCredentialsForRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestClientCredentialsForRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestClientCredentialsForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestClientCredentialsForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestClientCredentialsForIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestClientCredentialsForIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSystemAuthForRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSystemAuthForRuntime(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSystemAuthForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSystemAuthForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSystemAuthForIntegrationSystem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSystemAuthForIntegrationSystem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSystemAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSystemAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invalidateSystemAuthOneTimeToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_invalidateSystemAuthOneTimeToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addEventDefinitionToBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addEventDefinitionToBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addEventDefinitionToApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addEventDefinitionToApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEventDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEventDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEventDefinitionForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEventDefinitionForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEventDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEventDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refetchEventDefinitionSpec":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refetchEventDefinitionSpec(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addDocumentToBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addDocumentToBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDocument":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDocument(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resynchronizeFormationNotifications":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resynchronizeFormationNotifications(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finalizeDraftFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finalizeDraftFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assignFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignFormation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignFormation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignFormationGlobal":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignFormationGlobal(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFormationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFormationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFormationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFormationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFormationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFormationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachConstraintToFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachConstraintToFormationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachConstraintFromFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachConstraintFromFormationTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createLabelDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLabelDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateLabelDefinition":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLabelDefinition(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setApplicationLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setApplicationLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTenantLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTenantLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteApplicationLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApplicationLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setRuntimeLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setRuntimeLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteRuntimeLabel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRuntimeLabel(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setDefaultEventingForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setDefaultEventingForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDefaultEventingForApplication":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDefaultEventingForApplication(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestBundleInstanceAuthCreation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestBundleInstanceAuthCreation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestBundleInstanceAuthDeletion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestBundleInstanceAuthDeletion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBundleInstanceAuth":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBundleInstanceAuth(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBundle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBundle(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "writeTenants":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_writeTenants(ctx, field)
			})
		case "writeTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_writeTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTenants":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTenants(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subscribeTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_subscribeTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unsubscribeTenant":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unsubscribeTenant(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFormationTemplate(ctx, field)
			})
		case "deleteFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFormationTemplate(ctx, field)
			})
		case "updateFormationTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFormationTemplate(ctx, field)
			})
		case "createCertificateSubjectMapping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCertificateSubjectMapping(ctx, field)
			})
		case "updateCertificateSubjectMapping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCertificateSubjectMapping(ctx, field)
			})
		case "deleteCertificateSubjectMapping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCertificateSubjectMapping(ctx, field)
			})
		case "addTenantAccess":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addTenantAccess(ctx, field)
			})
		case "removeTenantAccess":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeTenantAccess(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuthCredentialDataImplementors = []string{"OAuthCredentialData", "CredentialData"}

func (ec *executionContext) _OAuthCredentialData(ctx context.Context, sel ast.SelectionSet, obj *OAuthCredentialData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuthCredentialDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthCredentialData")
		case "clientId":
			out.Values[i] = ec._OAuthCredentialData_clientId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientSecret":
			out.Values[i] = ec._OAuthCredentialData_clientSecret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._OAuthCredentialData_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oneTimeTokenForApplicationImplementors = []string{"OneTimeTokenForApplication", "OneTimeToken"}

func (ec *executionContext) _OneTimeTokenForApplication(ctx context.Context, sel ast.SelectionSet, obj *OneTimeTokenForApplication) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oneTimeTokenForApplicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OneTimeTokenForApplication")
		case "token":
			out.Values[i] = ec._OneTimeTokenForApplication_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "connectorURL":
			out.Values[i] = ec._OneTimeTokenForApplication_connectorURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "legacyConnectorURL":
			out.Values[i] = ec._OneTimeTokenForApplication_legacyConnectorURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._OneTimeTokenForApplication_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiresAt":
			out.Values[i] = ec._OneTimeTokenForApplication_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._OneTimeTokenForApplication_createdAt(ctx, field, obj)
		case "usedAt":
			out.Values[i] = ec._OneTimeTokenForApplication_usedAt(ctx, field, obj)
		case "raw":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForApplication_raw(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rawEncoded":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForApplication_rawEncoded(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._OneTimeTokenForApplication_type(ctx, field, obj)
		case "scenarioGroups":
			out.Values[i] = ec._OneTimeTokenForApplication_scenarioGroups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oneTimeTokenForRuntimeImplementors = []string{"OneTimeTokenForRuntime", "OneTimeToken"}

func (ec *executionContext) _OneTimeTokenForRuntime(ctx context.Context, sel ast.SelectionSet, obj *OneTimeTokenForRuntime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oneTimeTokenForRuntimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OneTimeTokenForRuntime")
		case "token":
			out.Values[i] = ec._OneTimeTokenForRuntime_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "connectorURL":
			out.Values[i] = ec._OneTimeTokenForRuntime_connectorURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._OneTimeTokenForRuntime_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiresAt":
			out.Values[i] = ec._OneTimeTokenForRuntime_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._OneTimeTokenForRuntime_createdAt(ctx, field, obj)
		case "usedAt":
			out.Values[i] = ec._OneTimeTokenForRuntime_usedAt(ctx, field, obj)
		case "raw":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForRuntime_raw(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rawEncoded":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OneTimeTokenForRuntime_rawEncoded(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._OneTimeTokenForRuntime_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var placeholderDefinitionImplementors = []string{"PlaceholderDefinition"}

func (ec *executionContext) _PlaceholderDefinition(ctx context.Context, sel ast.SelectionSet, obj *PlaceholderDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, placeholderDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaceholderDefinition")
		case "name":
			out.Values[i] = ec._PlaceholderDefinition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._PlaceholderDefinition_description(ctx, field, obj)
		case "jsonPath":
			out.Values[i] = ec._PlaceholderDefinition_jsonPath(ctx, field, obj)
		case "optional":
			out.Values[i] = ec._PlaceholderDefinition_optional(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "apisForApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_apisForApplication(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "eventsForApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_eventsForApplication(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applications(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_application(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationBySystemNumber":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationBySystemNumber(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationByLocalTenantIDAndAppTemplateID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationByLocalTenantIDAndAppTemplateID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationsForRuntime":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationsForRuntime(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationTemplates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationTemplates(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "applicationTemplate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applicationTemplate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "runtimes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runtimes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "runtime":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runtime(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "runtimeByTokenIssuer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runtimeByTokenIssuer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "labelDefinitions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_labelDefinitions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "labelDefinition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_labelDefinition(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bundleByInstanceAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bundleByInstanceAuth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bundleInstanceAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bundleInstanceAuth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "healthChecks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_healthChecks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "integrationSystems":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_integrationSystems(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "integrationSystem":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_integrationSystem(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "viewer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewer(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenants":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenants(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenantByExternalID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenantByExternalID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenantByInternalID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenantByInternalID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tenantByLowestOwnerForResource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tenantByLowestOwnerForResource(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "rootTenants":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_rootTenants(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "automaticScenarioAssignmentForScenario":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_automaticScenarioAssignmentForScenario(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "automaticScenarioAssignmentsForSelector":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_automaticScenarioAssignmentsForSelector(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "automaticScenarioAssignments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_automaticScenarioAssignments(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "systemAuth":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_systemAuth(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "systemAuthByToken":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_systemAuthByToken(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formation(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationByName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationByName(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationsForObject":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationsForObject(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationConstraints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationConstraints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationConstraint":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationConstraint(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationConstraintsByFormationType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationConstraintsByFormationType(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationTemplate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationTemplate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationTemplates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationTemplates(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "formationTemplatesByName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_formationTemplatesByName(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "certificateSubjectMapping":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_certificateSubjectMapping(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "certificateSubjectMappings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_certificateSubjectMappings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeImplementors = []string{"Runtime", "FormationParticipant"}

func (ec *executionContext) _Runtime(ctx context.Context, sel ast.SelectionSet, obj *Runtime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Runtime")
		case "id":
			out.Values[i] = ec._Runtime_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Runtime_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Runtime_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Runtime_description(ctx, field, obj)
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_webhooks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Runtime_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "auths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_auths(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventingConfiguration":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_eventingConfiguration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "runtimeContext":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_runtimeContext(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "runtimeContexts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Runtime_runtimeContexts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applicationNamespace":
			out.Values[i] = ec._Runtime_applicationNamespace(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeContextImplementors = []string{"RuntimeContext", "FormationParticipant"}

func (ec *executionContext) _RuntimeContext(ctx context.Context, sel ast.SelectionSet, obj *RuntimeContext) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeContextImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeContext")
		case "id":
			out.Values[i] = ec._RuntimeContext_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "key":
			out.Values[i] = ec._RuntimeContext_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "value":
			out.Values[i] = ec._RuntimeContext_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RuntimeContext_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeContextPageImplementors = []string{"RuntimeContextPage", "Pageable"}

func (ec *executionContext) _RuntimeContextPage(ctx context.Context, sel ast.SelectionSet, obj *RuntimeContextPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeContextPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeContextPage")
		case "data":
			out.Values[i] = ec._RuntimeContextPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._RuntimeContextPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._RuntimeContextPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeEventingConfigurationImplementors = []string{"RuntimeEventingConfiguration"}

func (ec *executionContext) _RuntimeEventingConfiguration(ctx context.Context, sel ast.SelectionSet, obj *RuntimeEventingConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeEventingConfigurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeEventingConfiguration")
		case "defaultURL":
			out.Values[i] = ec._RuntimeEventingConfiguration_defaultURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeMetadataImplementors = []string{"RuntimeMetadata"}

func (ec *executionContext) _RuntimeMetadata(ctx context.Context, sel ast.SelectionSet, obj *RuntimeMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeMetadata")
		case "creationTimestamp":
			out.Values[i] = ec._RuntimeMetadata_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimePageImplementors = []string{"RuntimePage", "Pageable"}

func (ec *executionContext) _RuntimePage(ctx context.Context, sel ast.SelectionSet, obj *RuntimePage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimePageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimePage")
		case "data":
			out.Values[i] = ec._RuntimePage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._RuntimePage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._RuntimePage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeStatusImplementors = []string{"RuntimeStatus"}

func (ec *executionContext) _RuntimeStatus(ctx context.Context, sel ast.SelectionSet, obj *RuntimeStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeStatus")
		case "condition":
			out.Values[i] = ec._RuntimeStatus_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._RuntimeStatus_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeSystemAuthImplementors = []string{"RuntimeSystemAuth", "SystemAuth"}

func (ec *executionContext) _RuntimeSystemAuth(ctx context.Context, sel ast.SelectionSet, obj *RuntimeSystemAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeSystemAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeSystemAuth")
		case "id":
			out.Values[i] = ec._RuntimeSystemAuth_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "auth":
			out.Values[i] = ec._RuntimeSystemAuth_auth(ctx, field, obj)
		case "type":
			out.Values[i] = ec._RuntimeSystemAuth_type(ctx, field, obj)
		case "tenantId":
			out.Values[i] = ec._RuntimeSystemAuth_tenantId(ctx, field, obj)
		case "referenceObjectId":
			out.Values[i] = ec._RuntimeSystemAuth_referenceObjectId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tenantImplementors = []string{"Tenant"}

func (ec *executionContext) _Tenant(ctx context.Context, sel ast.SelectionSet, obj *Tenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tenantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tenant")
		case "id":
			out.Values[i] = ec._Tenant_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "internalID":
			out.Values[i] = ec._Tenant_internalID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Tenant_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Tenant_type(ctx, field, obj)
		case "parents":
			out.Values[i] = ec._Tenant_parents(ctx, field, obj)
		case "initialized":
			out.Values[i] = ec._Tenant_initialized(ctx, field, obj)
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tenant_labels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "provider":
			out.Values[i] = ec._Tenant_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tenantAccessImplementors = []string{"TenantAccess"}

func (ec *executionContext) _TenantAccess(ctx context.Context, sel ast.SelectionSet, obj *TenantAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tenantAccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TenantAccess")
		case "tenantID":
			out.Values[i] = ec._TenantAccess_tenantID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TenantAccess_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceID":
			out.Values[i] = ec._TenantAccess_resourceID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "owner":
			out.Values[i] = ec._TenantAccess_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tenantPageImplementors = []string{"TenantPage", "Pageable"}

func (ec *executionContext) _TenantPage(ctx context.Context, sel ast.SelectionSet, obj *TenantPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tenantPageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TenantPage")
		case "data":
			out.Values[i] = ec._TenantPage_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._TenantPage_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TenantPage_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "value":
			out.Values[i] = ec._Version_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecated":
			out.Values[i] = ec._Version_deprecated(ctx, field, obj)
		case "deprecatedSince":
			out.Values[i] = ec._Version_deprecatedSince(ctx, field, obj)
		case "forRemoval":
			out.Values[i] = ec._Version_forRemoval(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var viewerImplementors = []string{"Viewer"}

func (ec *executionContext) _Viewer(ctx context.Context, sel ast.SelectionSet, obj *Viewer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Viewer")
		case "id":
			out.Values[i] = ec._Viewer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Viewer_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookImplementors = []string{"Webhook"}

func (ec *executionContext) _Webhook(ctx context.Context, sel ast.SelectionSet, obj *Webhook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Webhook")
		case "id":
			out.Values[i] = ec._Webhook_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applicationID":
			out.Values[i] = ec._Webhook_applicationID(ctx, field, obj)
		case "applicationTemplateID":
			out.Values[i] = ec._Webhook_applicationTemplateID(ctx, field, obj)
		case "runtimeID":
			out.Values[i] = ec._Webhook_runtimeID(ctx, field, obj)
		case "integrationSystemID":
			out.Values[i] = ec._Webhook_integrationSystemID(ctx, field, obj)
		case "formationTemplateID":
			out.Values[i] = ec._Webhook_formationTemplateID(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Webhook_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mode":
			out.Values[i] = ec._Webhook_mode(ctx, field, obj)
		case "correlationIdKey":
			out.Values[i] = ec._Webhook_correlationIdKey(ctx, field, obj)
		case "retryInterval":
			out.Values[i] = ec._Webhook_retryInterval(ctx, field, obj)
		case "timeout":
			out.Values[i] = ec._Webhook_timeout(ctx, field, obj)
		case "url":
			out.Values[i] = ec._Webhook_url(ctx, field, obj)
		case "auth":
			out.Values[i] = ec._Webhook_auth(ctx, field, obj)
		case "urlTemplate":
			out.Values[i] = ec._Webhook_urlTemplate(ctx, field, obj)
		case "inputTemplate":
			out.Values[i] = ec._Webhook_inputTemplate(ctx, field, obj)
		case "headerTemplate":
			out.Values[i] = ec._Webhook_headerTemplate(ctx, field, obj)
		case "outputTemplate":
			out.Values[i] = ec._Webhook_outputTemplate(ctx, field, obj)
		case "statusTemplate":
			out.Values[i] = ec._Webhook_statusTemplate(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Webhook_createdAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx context.Context, sel ast.SelectionSet, v APIDefinition) graphql.Marshaler {
	return ec._APIDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx context.Context, sel ast.SelectionSet, v []*APIDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx context.Context, sel ast.SelectionSet, v *APIDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._APIDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx context.Context, v interface{}) (APIDefinitionInput, error) {
	res, err := ec.unmarshalInputAPIDefinitionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx context.Context, v interface{}) (*APIDefinitionInput, error) {
	res, err := ec.unmarshalInputAPIDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAPISpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpec(ctx context.Context, sel ast.SelectionSet, v APISpec) graphql.Marshaler {
	return ec._APISpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNAPISpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpec(ctx context.Context, sel ast.SelectionSet, v *APISpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._APISpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAPISpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpecType(ctx context.Context, v interface{}) (APISpecType, error) {
	var res APISpecType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAPISpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpecType(ctx context.Context, sel ast.SelectionSet, v APISpecType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNAppSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAppSystemAuth(ctx context.Context, sel ast.SelectionSet, v *AppSystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AppSystemAuth(ctx, sel, v)
}

func (ec *executionContext) marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx context.Context, sel ast.SelectionSet, v Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx context.Context, sel ast.SelectionSet, v []*Application) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx context.Context, sel ast.SelectionSet, v *Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v ApplicationEventingConfiguration) graphql.Marshaler {
	return ec._ApplicationEventingConfiguration(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v *ApplicationEventingConfiguration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationEventingConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationFromTemplateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationFromTemplateInput(ctx context.Context, v interface{}) (ApplicationFromTemplateInput, error) {
	res, err := ec.unmarshalInputApplicationFromTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNApplicationJSONInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationJSONInput(ctx context.Context, v interface{}) (*ApplicationJSONInput, error) {
	res, err := ec.unmarshalInputApplicationJSONInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationPage(ctx context.Context, sel ast.SelectionSet, v ApplicationPage) graphql.Marshaler {
	return ec._ApplicationPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationPage(ctx context.Context, sel ast.SelectionSet, v *ApplicationPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationRegisterInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationRegisterInput(ctx context.Context, v interface{}) (ApplicationRegisterInput, error) {
	res, err := ec.unmarshalInputApplicationRegisterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatus(ctx context.Context, sel ast.SelectionSet, v *ApplicationStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx context.Context, v interface{}) (ApplicationStatusCondition, error) {
	var res ApplicationStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx context.Context, sel ast.SelectionSet, v ApplicationStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx context.Context, sel ast.SelectionSet, v ApplicationTemplate) graphql.Marshaler {
	return ec._ApplicationTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx context.Context, sel ast.SelectionSet, v []*ApplicationTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx context.Context, sel ast.SelectionSet, v *ApplicationTemplate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationTemplateAccessLevel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateAccessLevel(ctx context.Context, v interface{}) (ApplicationTemplateAccessLevel, error) {
	var res ApplicationTemplateAccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationTemplateAccessLevel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateAccessLevel(ctx context.Context, sel ast.SelectionSet, v ApplicationTemplateAccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNApplicationTemplateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateInput(ctx context.Context, v interface{}) (ApplicationTemplateInput, error) {
	res, err := ec.unmarshalInputApplicationTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNApplicationTemplatePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplatePage(ctx context.Context, sel ast.SelectionSet, v ApplicationTemplatePage) graphql.Marshaler {
	return ec._ApplicationTemplatePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationTemplatePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplatePage(ctx context.Context, sel ast.SelectionSet, v *ApplicationTemplatePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationTemplatePage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNApplicationTemplateUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplateUpdateInput(ctx context.Context, v interface{}) (ApplicationTemplateUpdateInput, error) {
	res, err := ec.unmarshalInputApplicationTemplateUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNApplicationUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationUpdateInput(ctx context.Context, v interface{}) (ApplicationUpdateInput, error) {
	res, err := ec.unmarshalInputApplicationUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAspect2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspect(ctx context.Context, sel ast.SelectionSet, v *Aspect) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Aspect(ctx, sel, v)
}

func (ec *executionContext) marshalNAspectAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinition(ctx context.Context, sel ast.SelectionSet, v *AspectAPIDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AspectAPIDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAspectAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinitionInput(ctx context.Context, v interface{}) (*AspectAPIDefinitionInput, error) {
	res, err := ec.unmarshalInputAspectAPIDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAspectEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinition(ctx context.Context, sel ast.SelectionSet, v *AspectEventDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AspectEventDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAspectEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionInput(ctx context.Context, v interface{}) (*AspectEventDefinitionInput, error) {
	res, err := ec.unmarshalInputAspectEventDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAspectEventDefinitionSubset2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubset(ctx context.Context, sel ast.SelectionSet, v *AspectEventDefinitionSubset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AspectEventDefinitionSubset(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAspectInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectInput(ctx context.Context, v interface{}) (*AspectInput, error) {
	res, err := ec.unmarshalInputAspectInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx context.Context, v interface{}) (AuthInput, error) {
	res, err := ec.unmarshalInputAuthInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx context.Context, v interface{}) (*AuthInput, error) {
	res, err := ec.unmarshalInputAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAutomaticScenarioAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignment(ctx context.Context, sel ast.SelectionSet, v []*AutomaticScenarioAssignment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAutomaticScenarioAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAutomaticScenarioAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignment(ctx context.Context, sel ast.SelectionSet, v *AutomaticScenarioAssignment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AutomaticScenarioAssignment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx context.Context, sel ast.SelectionSet, v Bundle) graphql.Marshaler {
	return ec._Bundle(ctx, sel, &v)
}

func (ec *executionContext) marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx context.Context, sel ast.SelectionSet, v []*Bundle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx context.Context, sel ast.SelectionSet, v *Bundle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Bundle(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBundleCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleCreateInput(ctx context.Context, v interface{}) (BundleCreateInput, error) {
	res, err := ec.unmarshalInputBundleCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleCreateInput(ctx context.Context, v interface{}) (*BundleCreateInput, error) {
	res, err := ec.unmarshalInputBundleCreateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, v BundleInstanceAuth) graphql.Marshaler {
	return ec._BundleInstanceAuth(ctx, sel, &v)
}

func (ec *executionContext) marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, v *BundleInstanceAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BundleInstanceAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthCreateInput(ctx context.Context, v interface{}) (BundleInstanceAuthCreateInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthRequestInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthRequestInput(ctx context.Context, v interface{}) (BundleInstanceAuthRequestInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthRequestInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthSetInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthSetInput(ctx context.Context, v interface{}) (BundleInstanceAuthSetInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthSetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthSetStatusConditionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthSetStatusConditionInput(ctx context.Context, v interface{}) (BundleInstanceAuthSetStatusConditionInput, error) {
	var res BundleInstanceAuthSetStatusConditionInput
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBundleInstanceAuthSetStatusConditionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthSetStatusConditionInput(ctx context.Context, sel ast.SelectionSet, v BundleInstanceAuthSetStatusConditionInput) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBundleInstanceAuthStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthStatus(ctx context.Context, sel ast.SelectionSet, v *BundleInstanceAuthStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BundleInstanceAuthStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBundleInstanceAuthStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthStatusCondition(ctx context.Context, v interface{}) (BundleInstanceAuthStatusCondition, error) {
	var res BundleInstanceAuthStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBundleInstanceAuthStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthStatusCondition(ctx context.Context, sel ast.SelectionSet, v BundleInstanceAuthStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBundleInstanceAuthUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthUpdateInput(ctx context.Context, v interface{}) (BundleInstanceAuthUpdateInput, error) {
	res, err := ec.unmarshalInputBundleInstanceAuthUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBundleUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleUpdateInput(ctx context.Context, v interface{}) (BundleUpdateInput, error) {
	res, err := ec.unmarshalInputBundleUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBusinessTenantMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBusinessTenantMappingInput(ctx context.Context, v interface{}) (BusinessTenantMappingInput, error) {
	res, err := ec.unmarshalInputBusinessTenantMappingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBusinessTenantMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBusinessTenantMappingInput(ctx context.Context, v interface{}) (*BusinessTenantMappingInput, error) {
	res, err := ec.unmarshalInputBusinessTenantMappingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, v CertificateSubjectMapping) graphql.Marshaler {
	return ec._CertificateSubjectMapping(ctx, sel, &v)
}

func (ec *executionContext) marshalNCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, v []*CertificateSubjectMapping) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, v *CertificateSubjectMapping) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CertificateSubjectMapping(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCertificateSubjectMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMappingInput(ctx context.Context, v interface{}) (CertificateSubjectMappingInput, error) {
	res, err := ec.unmarshalInputCertificateSubjectMappingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCertificateSubjectMappingPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMappingPage(ctx context.Context, sel ast.SelectionSet, v CertificateSubjectMappingPage) graphql.Marshaler {
	return ec._CertificateSubjectMappingPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNCertificateSubjectMappingPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMappingPage(ctx context.Context, sel ast.SelectionSet, v *CertificateSubjectMappingPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CertificateSubjectMappingPage(ctx, sel, v)
}

func (ec *executionContext) marshalNConstraintReference2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintReference(ctx context.Context, sel ast.SelectionSet, v ConstraintReference) graphql.Marshaler {
	return ec._ConstraintReference(ctx, sel, &v)
}

func (ec *executionContext) marshalNConstraintReference2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintReference(ctx context.Context, sel ast.SelectionSet, v *ConstraintReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConstraintReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConstraintScope2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintScope(ctx context.Context, v interface{}) (ConstraintScope, error) {
	var res ConstraintScope
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConstraintScope2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintScope(ctx context.Context, sel ast.SelectionSet, v ConstraintScope) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNConstraintType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintType(ctx context.Context, v interface{}) (ConstraintType, error) {
	var res ConstraintType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConstraintType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlConstraintType(ctx context.Context, sel ast.SelectionSet, v ConstraintType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx context.Context, sel ast.SelectionSet, v Document) graphql.Marshaler {
	return ec._Document(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx context.Context, sel ast.SelectionSet, v []*Document) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx context.Context, sel ast.SelectionSet, v *Document) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Document(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDocumentFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentFormat(ctx context.Context, v interface{}) (DocumentFormat, error) {
	var res DocumentFormat
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDocumentFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentFormat(ctx context.Context, sel ast.SelectionSet, v DocumentFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDocumentInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentInput(ctx context.Context, v interface{}) (DocumentInput, error) {
	res, err := ec.unmarshalInputDocumentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDocumentInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentInput(ctx context.Context, v interface{}) (*DocumentInput, error) {
	res, err := ec.unmarshalInputDocumentInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx context.Context, sel ast.SelectionSet, v EventDefinition) graphql.Marshaler {
	return ec._EventDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx context.Context, sel ast.SelectionSet, v []*EventDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx context.Context, sel ast.SelectionSet, v *EventDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx context.Context, v interface{}) (EventDefinitionInput, error) {
	res, err := ec.unmarshalInputEventDefinitionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx context.Context, v interface{}) (*EventDefinitionInput, error) {
	res, err := ec.unmarshalInputEventDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventSpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpec(ctx context.Context, sel ast.SelectionSet, v EventSpec) graphql.Marshaler {
	return ec._EventSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventSpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpec(ctx context.Context, sel ast.SelectionSet, v *EventSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventSpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpecType(ctx context.Context, v interface{}) (EventSpecType, error) {
	var res EventSpecType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventSpecType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpecType(ctx context.Context, sel ast.SelectionSet, v EventSpecType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventType(ctx context.Context, v interface{}) (EventType, error) {
	var res EventType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventType(ctx context.Context, sel ast.SelectionSet, v EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFetchMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchMode(ctx context.Context, v interface{}) (FetchMode, error) {
	var res FetchMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFetchMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchMode(ctx context.Context, sel ast.SelectionSet, v FetchMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFetchRequestStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestStatus(ctx context.Context, sel ast.SelectionSet, v *FetchRequestStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FetchRequestStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFetchRequestStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestStatusCondition(ctx context.Context, v interface{}) (FetchRequestStatusCondition, error) {
	var res FetchRequestStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFetchRequestStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestStatusCondition(ctx context.Context, sel ast.SelectionSet, v FetchRequestStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx context.Context, sel ast.SelectionSet, v Formation) graphql.Marshaler {
	return ec._Formation(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx context.Context, sel ast.SelectionSet, v []*Formation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx context.Context, sel ast.SelectionSet, v *Formation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Formation(ctx, sel, v)
}

func (ec *executionContext) marshalNFormationAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignment(ctx context.Context, sel ast.SelectionSet, v []*FormationAssignment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormationAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignment(ctx context.Context, sel ast.SelectionSet, v *FormationAssignment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationAssignment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationAssignmentType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignmentType(ctx context.Context, v interface{}) (FormationAssignmentType, error) {
	var res FormationAssignmentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationAssignmentType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignmentType(ctx context.Context, sel ast.SelectionSet, v FormationAssignmentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx context.Context, sel ast.SelectionSet, v FormationConstraint) graphql.Marshaler {
	return ec._FormationConstraint(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx context.Context, sel ast.SelectionSet, v []*FormationConstraint) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx context.Context, sel ast.SelectionSet, v *FormationConstraint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationConstraint(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationConstraintInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraintInput(ctx context.Context, v interface{}) (FormationConstraintInput, error) {
	res, err := ec.unmarshalInputFormationConstraintInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFormationConstraintUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraintUpdateInput(ctx context.Context, v interface{}) (FormationConstraintUpdateInput, error) {
	res, err := ec.unmarshalInputFormationConstraintUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFormationInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationInput(ctx context.Context, v interface{}) (FormationInput, error) {
	res, err := ec.unmarshalInputFormationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFormationObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationObjectType(ctx context.Context, v interface{}) (FormationObjectType, error) {
	var res FormationObjectType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationObjectType(ctx context.Context, sel ast.SelectionSet, v FormationObjectType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormationPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationPage(ctx context.Context, sel ast.SelectionSet, v FormationPage) graphql.Marshaler {
	return ec._FormationPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationPage(ctx context.Context, sel ast.SelectionSet, v *FormationPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationPage(ctx, sel, v)
}

func (ec *executionContext) marshalNFormationStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatus(ctx context.Context, sel ast.SelectionSet, v FormationStatus) graphql.Marshaler {
	return ec._FormationStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatus(ctx context.Context, sel ast.SelectionSet, v *FormationStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatusCondition(ctx context.Context, v interface{}) (FormationStatusCondition, error) {
	var res FormationStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatusCondition(ctx context.Context, sel ast.SelectionSet, v FormationStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFormationStatusError2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatusError(ctx context.Context, sel ast.SelectionSet, v *FormationStatusError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationStatusError(ctx, sel, v)
}

func (ec *executionContext) marshalNFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx context.Context, sel ast.SelectionSet, v []*FormationTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx context.Context, sel ast.SelectionSet, v *FormationTemplate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFormationTemplateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplateInput(ctx context.Context, v interface{}) (FormationTemplateInput, error) {
	res, err := ec.unmarshalInputFormationTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFormationTemplatePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplatePage(ctx context.Context, sel ast.SelectionSet, v FormationTemplatePage) graphql.Marshaler {
	return ec._FormationTemplatePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNFormationTemplatePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplatePage(ctx context.Context, sel ast.SelectionSet, v *FormationTemplatePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FormationTemplatePage(ctx, sel, v)
}

func (ec *executionContext) marshalNHealthCheck2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheck(ctx context.Context, sel ast.SelectionSet, v []*HealthCheck) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHealthCheck2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheck(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHealthCheck2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheck(ctx context.Context, sel ast.SelectionSet, v *HealthCheck) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthCheck(ctx, sel, v)
}

func (ec *executionContext) marshalNHealthCheckPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckPage(ctx context.Context, sel ast.SelectionSet, v HealthCheckPage) graphql.Marshaler {
	return ec._HealthCheckPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNHealthCheckPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckPage(ctx context.Context, sel ast.SelectionSet, v *HealthCheckPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HealthCheckPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHealthCheckStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckStatusCondition(ctx context.Context, v interface{}) (HealthCheckStatusCondition, error) {
	var res HealthCheckStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHealthCheckStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckStatusCondition(ctx context.Context, sel ast.SelectionSet, v HealthCheckStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx context.Context, v interface{}) (HealthCheckType, error) {
	var res HealthCheckType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx context.Context, sel ast.SelectionSet, v HealthCheckType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIntSysSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntSysSystemAuth(ctx context.Context, sel ast.SelectionSet, v *IntSysSystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntSysSystemAuth(ctx, sel, v)
}

func (ec *executionContext) marshalNIntegrationDependency2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependency(ctx context.Context, sel ast.SelectionSet, v IntegrationDependency) graphql.Marshaler {
	return ec._IntegrationDependency(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationDependency2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependency(ctx context.Context, sel ast.SelectionSet, v []*IntegrationDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntegrationDependency2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIntegrationDependency2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependency(ctx context.Context, sel ast.SelectionSet, v *IntegrationDependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationDependency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIntegrationDependencyInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependencyInput(ctx context.Context, v interface{}) (IntegrationDependencyInput, error) {
	res, err := ec.unmarshalInputIntegrationDependencyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx context.Context, sel ast.SelectionSet, v IntegrationSystem) graphql.Marshaler {
	return ec._IntegrationSystem(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx context.Context, sel ast.SelectionSet, v []*IntegrationSystem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx context.Context, sel ast.SelectionSet, v *IntegrationSystem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationSystem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIntegrationSystemInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystemInput(ctx context.Context, v interface{}) (IntegrationSystemInput, error) {
	res, err := ec.unmarshalInputIntegrationSystemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIntegrationSystemPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystemPage(ctx context.Context, sel ast.SelectionSet, v IntegrationSystemPage) graphql.Marshaler {
	return ec._IntegrationSystemPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationSystemPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystemPage(ctx context.Context, sel ast.SelectionSet, v *IntegrationSystemPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationSystemPage(ctx, sel, v)
}

func (ec *executionContext) marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx context.Context, sel ast.SelectionSet, v Label) graphql.Marshaler {
	return ec._Label(ctx, sel, &v)
}

func (ec *executionContext) marshalNLabel2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabel(ctx context.Context, sel ast.SelectionSet, v *Label) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Label(ctx, sel, v)
}

func (ec *executionContext) marshalNLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx context.Context, sel ast.SelectionSet, v LabelDefinition) graphql.Marshaler {
	return ec._LabelDefinition(ctx, sel, &v)
}

func (ec *executionContext) marshalNLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx context.Context, sel ast.SelectionSet, v []*LabelDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx context.Context, sel ast.SelectionSet, v *LabelDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LabelDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLabelDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinitionInput(ctx context.Context, v interface{}) (LabelDefinitionInput, error) {
	res, err := ec.unmarshalInputLabelDefinitionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLabelFilter2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelFilter(ctx context.Context, v interface{}) (*LabelFilter, error) {
	res, err := ec.unmarshalInputLabelFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLabelSelectorInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelSelectorInput(ctx context.Context, v interface{}) (LabelSelectorInput, error) {
	res, err := ec.unmarshalInputLabelSelectorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOneTimeTokenForApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenForApplication(ctx context.Context, sel ast.SelectionSet, v OneTimeTokenForApplication) graphql.Marshaler {
	return ec._OneTimeTokenForApplication(ctx, sel, &v)
}

func (ec *executionContext) marshalNOneTimeTokenForApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenForApplication(ctx context.Context, sel ast.SelectionSet, v *OneTimeTokenForApplication) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OneTimeTokenForApplication(ctx, sel, v)
}

func (ec *executionContext) marshalNOneTimeTokenForRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenForRuntime(ctx context.Context, sel ast.SelectionSet, v OneTimeTokenForRuntime) graphql.Marshaler {
	return ec._OneTimeTokenForRuntime(ctx, sel, &v)
}

func (ec *executionContext) marshalNOneTimeTokenForRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenForRuntime(ctx context.Context, sel ast.SelectionSet, v *OneTimeTokenForRuntime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OneTimeTokenForRuntime(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOperationType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationType(ctx context.Context, v interface{}) (OperationType, error) {
	var res OperationType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOperationType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationType(ctx context.Context, sel ast.SelectionSet, v OperationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx context.Context, v interface{}) (PageCursor, error) {
	var res PageCursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx context.Context, sel ast.SelectionSet, v PageCursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageInfo(ctx context.Context, sel ast.SelectionSet, v *PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNPlaceholderDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinition(ctx context.Context, sel ast.SelectionSet, v []*PlaceholderDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlaceholderDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPlaceholderDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinition(ctx context.Context, sel ast.SelectionSet, v *PlaceholderDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlaceholderDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPlaceholderDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinitionInput(ctx context.Context, v interface{}) (*PlaceholderDefinitionInput, error) {
	res, err := ec.unmarshalInputPlaceholderDefinitionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNResourceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlResourceType(ctx context.Context, v interface{}) (ResourceType, error) {
	var res ResourceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlResourceType(ctx context.Context, sel ast.SelectionSet, v ResourceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx context.Context, sel ast.SelectionSet, v Runtime) graphql.Marshaler {
	return ec._Runtime(ctx, sel, &v)
}

func (ec *executionContext) marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx context.Context, sel ast.SelectionSet, v []*Runtime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx context.Context, sel ast.SelectionSet, v *Runtime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Runtime(ctx, sel, v)
}

func (ec *executionContext) marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx context.Context, sel ast.SelectionSet, v RuntimeContext) graphql.Marshaler {
	return ec._RuntimeContext(ctx, sel, &v)
}

func (ec *executionContext) marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx context.Context, sel ast.SelectionSet, v []*RuntimeContext) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx context.Context, sel ast.SelectionSet, v *RuntimeContext) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeContext(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeContextInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContextInput(ctx context.Context, v interface{}) (RuntimeContextInput, error) {
	res, err := ec.unmarshalInputRuntimeContextInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntimeMetadata2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeMetadata(ctx context.Context, sel ast.SelectionSet, v *RuntimeMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNRuntimePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimePage(ctx context.Context, sel ast.SelectionSet, v RuntimePage) graphql.Marshaler {
	return ec._RuntimePage(ctx, sel, &v)
}

func (ec *executionContext) marshalNRuntimePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimePage(ctx context.Context, sel ast.SelectionSet, v *RuntimePage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimePage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeRegisterInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeRegisterInput(ctx context.Context, v interface{}) (RuntimeRegisterInput, error) {
	res, err := ec.unmarshalInputRuntimeRegisterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntimeStatus2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatus(ctx context.Context, sel ast.SelectionSet, v *RuntimeStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatusCondition(ctx context.Context, v interface{}) (RuntimeStatusCondition, error) {
	var res RuntimeStatusCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntimeStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatusCondition(ctx context.Context, sel ast.SelectionSet, v RuntimeStatusCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRuntimeSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeSystemAuth(ctx context.Context, sel ast.SelectionSet, v *RuntimeSystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuntimeSystemAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuntimeUpdateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeUpdateInput(ctx context.Context, v interface{}) (RuntimeUpdateInput, error) {
	res, err := ec.unmarshalInputRuntimeUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSpecFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSpecFormat(ctx context.Context, v interface{}) (SpecFormat, error) {
	var res SpecFormat
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpecFormat2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSpecFormat(ctx context.Context, sel ast.SelectionSet, v SpecFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx context.Context, sel ast.SelectionSet, v SystemAuth) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SystemAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTargetOperation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTargetOperation(ctx context.Context, v interface{}) (TargetOperation, error) {
	var res TargetOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTargetOperation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTargetOperation(ctx context.Context, sel ast.SelectionSet, v TargetOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx context.Context, sel ast.SelectionSet, v Tenant) graphql.Marshaler {
	return ec._Tenant(ctx, sel, &v)
}

func (ec *executionContext) marshalNTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx context.Context, sel ast.SelectionSet, v []*Tenant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx context.Context, sel ast.SelectionSet, v *Tenant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tenant(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTenantAccessInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccessInput(ctx context.Context, v interface{}) (TenantAccessInput, error) {
	res, err := ec.unmarshalInputTenantAccessInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTenantAccessObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccessObjectType(ctx context.Context, v interface{}) (TenantAccessObjectType, error) {
	var res TenantAccessObjectType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTenantAccessObjectType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccessObjectType(ctx context.Context, sel ast.SelectionSet, v TenantAccessObjectType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTenantPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantPage(ctx context.Context, sel ast.SelectionSet, v TenantPage) graphql.Marshaler {
	return ec._TenantPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNTenantPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantPage(ctx context.Context, sel ast.SelectionSet, v *TenantPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TenantPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx context.Context, v interface{}) (Timestamp, error) {
	var res Timestamp
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx context.Context, sel ast.SelectionSet, v Timestamp) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx context.Context, v interface{}) (*Timestamp, error) {
	var res = new(Timestamp)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx context.Context, sel ast.SelectionSet, v *Timestamp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNViewer2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlViewer(ctx context.Context, sel ast.SelectionSet, v Viewer) graphql.Marshaler {
	return ec._Viewer(ctx, sel, &v)
}

func (ec *executionContext) marshalNViewer2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlViewer(ctx context.Context, sel ast.SelectionSet, v *Viewer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Viewer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNViewerType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlViewerType(ctx context.Context, v interface{}) (ViewerType, error) {
	var res ViewerType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNViewerType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlViewerType(ctx context.Context, sel ast.SelectionSet, v ViewerType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx context.Context, sel ast.SelectionSet, v Webhook) graphql.Marshaler {
	return ec._Webhook(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx context.Context, sel ast.SelectionSet, v *Webhook) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Webhook(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx context.Context, v interface{}) (WebhookInput, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx context.Context, v interface{}) (*WebhookInput, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx context.Context, v interface{}) (WebhookType, error) {
	var res WebhookType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx context.Context, sel ast.SelectionSet, v WebhookType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinition(ctx context.Context, sel ast.SelectionSet, v *APIDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APIDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx context.Context, v interface{}) ([]*APIDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*APIDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAPIDefinitionPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPIDefinitionPage(ctx context.Context, sel ast.SelectionSet, v *APIDefinitionPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APIDefinitionPage(ctx, sel, v)
}

func (ec *executionContext) marshalOAPISpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpec(ctx context.Context, sel ast.SelectionSet, v *APISpec) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APISpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAPISpecInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAPISpecInput(ctx context.Context, v interface{}) (*APISpecInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAPISpecInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAppSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAppSystemAuth(ctx context.Context, sel ast.SelectionSet, v []*AppSystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAppSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAppSystemAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOApplication2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplication(ctx context.Context, sel ast.SelectionSet, v *Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v *ApplicationEventingConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationEventingConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalOApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx context.Context, v interface{}) (*ApplicationStatusCondition, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ApplicationStatusCondition)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOApplicationStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationStatusCondition(ctx context.Context, sel ast.SelectionSet, v *ApplicationStatusCondition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOApplicationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlApplicationTemplate(ctx context.Context, sel ast.SelectionSet, v *ApplicationTemplate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalOArtifactType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlArtifactType(ctx context.Context, v interface{}) (*ArtifactType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ArtifactType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOArtifactType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlArtifactType(ctx context.Context, sel ast.SelectionSet, v *ArtifactType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAspect2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspect(ctx context.Context, sel ast.SelectionSet, v []*Aspect) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspect2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspect(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAspectAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinition(ctx context.Context, sel ast.SelectionSet, v []*AspectAPIDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspectAPIDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAspectAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinitionInput(ctx context.Context, v interface{}) ([]*AspectAPIDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectAPIDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAspectAPIDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectAPIDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAspectEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinition(ctx context.Context, sel ast.SelectionSet, v []*AspectEventDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspectEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAspectEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionInput(ctx context.Context, v interface{}) ([]*AspectEventDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectEventDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAspectEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAspectEventDefinitionSubset2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubset(ctx context.Context, sel ast.SelectionSet, v []*AspectEventDefinitionSubset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAspectEventDefinitionSubset2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAspectEventDefinitionSubsetInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubsetInput(ctx context.Context, v interface{}) ([]*AspectEventDefinitionSubsetInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectEventDefinitionSubsetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOAspectEventDefinitionSubsetInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubsetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAspectEventDefinitionSubsetInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectEventDefinitionSubsetInput(ctx context.Context, v interface{}) (*AspectEventDefinitionSubsetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAspectEventDefinitionSubsetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAspectInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectInput(ctx context.Context, v interface{}) ([]*AspectInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*AspectInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAspectInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAspectInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuth(ctx context.Context, sel ast.SelectionSet, v *Auth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Auth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAuthInput(ctx context.Context, v interface{}) (*AuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAutomaticScenarioAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignment(ctx context.Context, sel ast.SelectionSet, v *AutomaticScenarioAssignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AutomaticScenarioAssignment(ctx, sel, v)
}

func (ec *executionContext) marshalOAutomaticScenarioAssignmentPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlAutomaticScenarioAssignmentPage(ctx context.Context, sel ast.SelectionSet, v *AutomaticScenarioAssignmentPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AutomaticScenarioAssignmentPage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBasicCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBasicCredentialDataInput(ctx context.Context, v interface{}) (*BasicCredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBasicCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOBundle2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundle(ctx context.Context, sel ast.SelectionSet, v *Bundle) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Bundle(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBundleCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleCreateInput(ctx context.Context, v interface{}) ([]*BundleCreateInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*BundleCreateInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBundleCreateInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleCreateInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, v []*BundleInstanceAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOBundleInstanceAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuth(ctx context.Context, sel ast.SelectionSet, v *BundleInstanceAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BundleInstanceAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBundleInstanceAuthStatusInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundleInstanceAuthStatusInput(ctx context.Context, v interface{}) (*BundleInstanceAuthStatusInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBundleInstanceAuthStatusInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBundlePage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBundlePage(ctx context.Context, sel ast.SelectionSet, v *BundlePage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BundlePage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBusinessTenantMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBusinessTenantMappingInput(ctx context.Context, v interface{}) ([]*BusinessTenantMappingInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*BusinessTenantMappingInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBusinessTenantMappingInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlBusinessTenantMappingInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx context.Context, v interface{}) (*CLOB, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(CLOB)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCLOB2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCLOB(ctx context.Context, sel ast.SelectionSet, v *CLOB) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOCSRFTokenCredentialRequestAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCSRFTokenCredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, v *CSRFTokenCredentialRequestAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CSRFTokenCredentialRequestAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCSRFTokenCredentialRequestAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCSRFTokenCredentialRequestAuthInput(ctx context.Context, v interface{}) (*CSRFTokenCredentialRequestAuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCSRFTokenCredentialRequestAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCertificateOAuthCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateOAuthCredentialDataInput(ctx context.Context, v interface{}) (*CertificateOAuthCredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCertificateOAuthCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCertificateSubjectMapping2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCertificateSubjectMapping(ctx context.Context, sel ast.SelectionSet, v *CertificateSubjectMapping) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CertificateSubjectMapping(ctx, sel, v)
}

func (ec *executionContext) marshalOCredentialData2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialData(ctx context.Context, sel ast.SelectionSet, v CredentialData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CredentialData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialDataInput(ctx context.Context, v interface{}) (*CredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCredentialRequestAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialRequestAuth(ctx context.Context, sel ast.SelectionSet, v *CredentialRequestAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CredentialRequestAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCredentialRequestAuthInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlCredentialRequestAuthInput(ctx context.Context, v interface{}) (*CredentialRequestAuthInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCredentialRequestAuthInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODocument2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocument(ctx context.Context, sel ast.SelectionSet, v *Document) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Document(ctx, sel, v)
}

func (ec *executionContext) unmarshalODocumentInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentInput(ctx context.Context, v interface{}) ([]*DocumentInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*DocumentInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDocumentInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODocumentPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlDocumentPage(ctx context.Context, sel ast.SelectionSet, v *DocumentPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DocumentPage(ctx, sel, v)
}

func (ec *executionContext) marshalOEventDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinition(ctx context.Context, sel ast.SelectionSet, v *EventDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx context.Context, v interface{}) ([]*EventDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*EventDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEventDefinitionPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventDefinitionPage(ctx context.Context, sel ast.SelectionSet, v *EventDefinitionPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventDefinitionPage(ctx, sel, v)
}

func (ec *executionContext) marshalOEventSpec2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpec(ctx context.Context, sel ast.SelectionSet, v *EventSpec) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventSpecInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlEventSpecInput(ctx context.Context, v interface{}) (*EventSpecInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventSpecInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFetchMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchMode(ctx context.Context, v interface{}) (*FetchMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FetchMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFetchMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchMode(ctx context.Context, sel ast.SelectionSet, v *FetchMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFetchRequest2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequest(ctx context.Context, sel ast.SelectionSet, v *FetchRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FetchRequest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFetchRequestInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFetchRequestInput(ctx context.Context, v interface{}) (*FetchRequestInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFetchRequestInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFormation2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormation(ctx context.Context, sel ast.SelectionSet, v *Formation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Formation(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationAssignment2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignment(ctx context.Context, sel ast.SelectionSet, v *FormationAssignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationAssignment(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationAssignmentPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationAssignmentPage(ctx context.Context, sel ast.SelectionSet, v *FormationAssignmentPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationAssignmentPage(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx context.Context, sel ast.SelectionSet, v []*FormationConstraint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationConstraint2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationConstraint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFormationError2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationError(ctx context.Context, sel ast.SelectionSet, v FormationError) graphql.Marshaler {
	return ec._FormationError(ctx, sel, &v)
}

func (ec *executionContext) marshalOFormationParticipant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationParticipant(ctx context.Context, sel ast.SelectionSet, v FormationParticipant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationParticipant(ctx, sel, v)
}

func (ec *executionContext) marshalOFormationStatusError2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatusError(ctx context.Context, sel ast.SelectionSet, v []*FormationStatusError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFormationStatusError2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationStatusError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFormationTemplate2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlFormationTemplate(ctx context.Context, sel ast.SelectionSet, v *FormationTemplate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FormationTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx context.Context, v interface{}) ([]HealthCheckType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]HealthCheckType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx context.Context, sel ast.SelectionSet, v []HealthCheckType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHealthCheckType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHealthCheckType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHttpHeaders2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeaders(ctx context.Context, v interface{}) (HTTPHeaders, error) {
	if v == nil {
		return nil, nil
	}
	var res HTTPHeaders
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHttpHeaders2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeaders(ctx context.Context, sel ast.SelectionSet, v HTTPHeaders) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOHttpHeadersSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeadersSerialized(ctx context.Context, v interface{}) (*HTTPHeadersSerialized, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := HTTPHeadersSerialized(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHttpHeadersSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlHTTPHeadersSerialized(ctx context.Context, sel ast.SelectionSet, v *HTTPHeadersSerialized) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	return res
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOIntSysSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntSysSystemAuth(ctx context.Context, sel ast.SelectionSet, v []*IntSysSystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntSysSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntSysSystemAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOIntegrationDependencyPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationDependencyPage(ctx context.Context, sel ast.SelectionSet, v *IntegrationDependencyPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IntegrationDependencyPage(ctx, sel, v)
}

func (ec *executionContext) marshalOIntegrationSystem2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlIntegrationSystem(ctx context.Context, sel ast.SelectionSet, v *IntegrationSystem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IntegrationSystem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx context.Context, v interface{}) (*JSON, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(JSON)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSON(ctx context.Context, sel ast.SelectionSet, v *JSON) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOJSONSchema2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSONSchema(ctx context.Context, v interface{}) (*JSONSchema, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(JSONSchema)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSONSchema2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlJSONSchema(ctx context.Context, sel ast.SelectionSet, v *JSONSchema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOLabelDefinition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelDefinition(ctx context.Context, sel ast.SelectionSet, v *LabelDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LabelDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLabelFilter2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelFilter(ctx context.Context, v interface{}) ([]*LabelFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*LabelFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLabelFilter2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabelFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx context.Context, v interface{}) (Labels, error) {
	if v == nil {
		return nil, nil
	}
	var res Labels
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx context.Context, sel ast.SelectionSet, v Labels) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx context.Context, v interface{}) (*Labels, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(Labels)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLabels2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlLabels(ctx context.Context, sel ast.SelectionSet, v *Labels) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOAuthCredentialDataInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOAuthCredentialDataInput(ctx context.Context, v interface{}) (*OAuthCredentialDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOAuthCredentialDataInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOneTimeToken2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeToken(ctx context.Context, sel ast.SelectionSet, v OneTimeToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OneTimeToken(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOneTimeTokenInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenInput(ctx context.Context, v interface{}) (*OneTimeTokenInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOneTimeTokenInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOneTimeTokenType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenType(ctx context.Context, v interface{}) (OneTimeTokenType, error) {
	var res OneTimeTokenType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOneTimeTokenType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenType(ctx context.Context, sel ast.SelectionSet, v OneTimeTokenType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOOneTimeTokenType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenType(ctx context.Context, v interface{}) (*OneTimeTokenType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(OneTimeTokenType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOneTimeTokenType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOneTimeTokenType(ctx context.Context, sel ast.SelectionSet, v *OneTimeTokenType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOperationMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationMode(ctx context.Context, v interface{}) (*OperationMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(OperationMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOperationMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlOperationMode(ctx context.Context, sel ast.SelectionSet, v *OperationMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx context.Context, v interface{}) (*PageCursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(PageCursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPageCursor2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPageCursor(ctx context.Context, sel ast.SelectionSet, v *PageCursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPlaceholderDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinitionInput(ctx context.Context, v interface{}) ([]*PlaceholderDefinitionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*PlaceholderDefinitionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPlaceholderDefinitionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlPlaceholderDefinitionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOQueryParams2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParams(ctx context.Context, v interface{}) (QueryParams, error) {
	if v == nil {
		return nil, nil
	}
	var res QueryParams
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOQueryParams2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParams(ctx context.Context, sel ast.SelectionSet, v QueryParams) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOQueryParamsSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParamsSerialized(ctx context.Context, v interface{}) (*QueryParamsSerialized, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := QueryParamsSerialized(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOQueryParamsSerialized2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlQueryParamsSerialized(ctx context.Context, sel ast.SelectionSet, v *QueryParamsSerialized) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalORuntime2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntime(ctx context.Context, sel ast.SelectionSet, v *Runtime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Runtime(ctx, sel, v)
}

func (ec *executionContext) marshalORuntimeContext2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContext(ctx context.Context, sel ast.SelectionSet, v *RuntimeContext) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeContext(ctx, sel, v)
}

func (ec *executionContext) marshalORuntimeContextPage2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeContextPage(ctx context.Context, sel ast.SelectionSet, v *RuntimeContextPage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeContextPage(ctx, sel, v)
}

func (ec *executionContext) marshalORuntimeEventingConfiguration2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeEventingConfiguration(ctx context.Context, sel ast.SelectionSet, v *RuntimeEventingConfiguration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeEventingConfiguration(ctx, sel, v)
}

func (ec *executionContext) unmarshalORuntimeStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatusCondition(ctx context.Context, v interface{}) (*RuntimeStatusCondition, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(RuntimeStatusCondition)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORuntimeStatusCondition2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeStatusCondition(ctx context.Context, sel ast.SelectionSet, v *RuntimeStatusCondition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORuntimeSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeSystemAuth(ctx context.Context, sel ast.SelectionSet, v []*RuntimeSystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuntimeSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlRuntimeSystemAuth(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOSystemAuth2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuth(ctx context.Context, sel ast.SelectionSet, v SystemAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SystemAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSystemAuthReferenceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuthReferenceType(ctx context.Context, v interface{}) (*SystemAuthReferenceType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SystemAuthReferenceType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSystemAuthReferenceType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlSystemAuthReferenceType(ctx context.Context, sel ast.SelectionSet, v *SystemAuthReferenceType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTemplateValueInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTemplateValueInput(ctx context.Context, v interface{}) ([]*TemplateValueInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*TemplateValueInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTemplateValueInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTemplateValueInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTemplateValueInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTemplateValueInput(ctx context.Context, v interface{}) (*TemplateValueInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTemplateValueInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx context.Context, sel ast.SelectionSet, v []*Tenant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTenant2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenant(ctx context.Context, sel ast.SelectionSet, v *Tenant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tenant(ctx, sel, v)
}

func (ec *executionContext) marshalOTenantAccess2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTenantAccess(ctx context.Context, sel ast.SelectionSet, v *TenantAccess) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TenantAccess(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx context.Context, v interface{}) (*Timestamp, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(Timestamp)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTimestamp2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlTimestamp(ctx context.Context, sel ast.SelectionSet, v *Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOVersion2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersion(ctx context.Context, sel ast.SelectionSet, v *Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVersionInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlVersionInput(ctx context.Context, v interface{}) (*VersionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVersionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx context.Context, sel ast.SelectionSet, v []*Webhook) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhook2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhook(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx context.Context, v interface{}) ([]*WebhookInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*WebhookInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWebhookInput2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWebhookMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookMode(ctx context.Context, v interface{}) (*WebhookMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(WebhookMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookMode2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookMode(ctx context.Context, sel ast.SelectionSet, v *WebhookMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx context.Context, v interface{}) (*WebhookType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(WebhookType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookType2githubcomkymaincubatorcompasscomponentsdirectorpkggraphqlWebhookType(ctx context.Context, sel ast.SelectionSet, v *WebhookType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
