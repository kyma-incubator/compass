package tenantfetchersvc

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/kyma-incubator/compass/components/director/internal/model"
	"github.com/kyma-incubator/compass/components/director/pkg/apperrors"
	"github.com/kyma-incubator/compass/components/director/pkg/log"
	tenantEntity "github.com/kyma-incubator/compass/components/director/pkg/tenant"
	"github.com/pkg/errors"
)

const regionLabelKey = "region"

//go:generate mockery --name=TenantService --output=automock --outpkg=automock --case=underscore --unroll-variadic=False
type TenantService interface {
	GetInternalTenant(ctx context.Context, externalTenant string) (string, error)
	CreateManyIfNotExists(ctx context.Context, tenantInputs ...model.BusinessTenantMappingInput) error
	SetLabel(ctx context.Context, labelInput *model.LabelInput) error
}

type provisioner struct {
	tenantSvc TenantService
}

func NewTenantProvisioner(tenantSvc TenantService) *provisioner {
	return &provisioner{
		tenantSvc: tenantSvc,
	}
}

func (p *provisioner) ProvisionTenant(ctx context.Context, tenant model.BusinessTenantMappingInput) error {
	return p.createTenant(ctx, tenant)
}

func (p *provisioner) ProvisionRegionalTenant(ctx context.Context, tenant model.BusinessTenantMappingInput, region string) error {
	if err := p.createTenant(ctx, tenant); err != nil {
		return err
	}

	intTenantID, err := p.tenantSvc.GetInternalTenant(ctx, tenant.ExternalTenant)
	if err != nil {
		return err
	}

	label := &model.LabelInput{
		Key:        regionLabelKey,
		Value:      region,
		ObjectID:   intTenantID,
		ObjectType: model.TenantLabelableObject,
	}
	if err := p.tenantSvc.SetLabel(ctx, label); err != nil {
		return errors.Wrapf(err, "while setting region label for tenant with external ID %s", tenant.ExternalTenant)
	}

	return nil
}

func (p *provisioner) createTenant(ctx context.Context, newTenant model.BusinessTenantMappingInput) error {
	externalTenantID := newTenant.ExternalTenant
	parentExternalID := newTenant.Parent
	if len(parentExternalID) > 0 {
		parentInternalID, err := p.ensureParentExists(ctx, newTenant)
		if err != nil {
			return errors.Wrapf(err, "while ensuring parent tenant with ID %s exists", parentExternalID)
		}
		newTenant.Parent = parentInternalID
	}

	if err := p.tenantSvc.CreateManyIfNotExists(ctx, newTenant); err != nil {
		if !apperrors.IsNotUniqueError(err) {
			return errors.Wrapf(err, tenantCreationFailureMsgFmt, externalTenantID)
		}
	}

	return nil
}

func (p *provisioner) ensureParentExists(ctx context.Context, childTenant model.BusinessTenantMappingInput) (string, error) {
	parentTenantID := childTenant.Parent
	log.C(ctx).Infof("Ensuring parent tenant with external ID %s for tenant with external ID %s exists", childTenant.Parent, childTenant.ExternalTenant)
	id, err := p.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	if err != nil && !apperrors.IsNotFoundError(err) && err != sql.ErrNoRows {
		return "", errors.Wrapf(err, "failed to retrieve internal ID of parent with external ID %s", parentTenantID)
	}
	if id != "" {
		log.C(ctx).Infof("Parent tenant with external ID %s already exists", parentTenantID)
		return id, nil
	}

	if !automaticParentCreationEnabled(childTenant) {
		return "", fmt.Errorf("parent tenant with external ID %s does not exist", parentTenantID)
	}

	log.C(ctx).Infof("Creating parent tenant with external ID %s", parentTenantID)
	err = p.tenantSvc.CreateManyIfNotExists(ctx, p.customerTenant(parentTenantID))
	if err != nil && apperrors.IsNotUniqueError(err) {
		log.C(ctx).Infof("Parent tenant with external ID %s already exists", parentTenantID)
		return p.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	} else if err != nil {
		return "", errors.Wrapf(err, "failed to create parent tenant with ID %s", parentTenantID)
	}

	internalID, err := p.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	if err != nil {
		return "", errors.Wrapf(err, "failed to retrieve internal ID of parent with external ID %s", parentTenantID)
	}

	log.C(ctx).Infof("Successfully created parent tenant with external ID %s and internal ID %s", parentTenantID, internalID)
	return internalID, nil
}

func (p *provisioner) customerTenant(tenantID string) model.BusinessTenantMappingInput {
	return model.BusinessTenantMappingInput{
		Name:           tenantID,
		ExternalTenant: tenantID,
		Parent:         "",
		Subdomain:      "",
		Type:           tenantEntity.TypeToStr(tenantEntity.Customer),
		Provider:       autogeneratedTenantProvider,
	}
}

func automaticParentCreationEnabled(tenant model.BusinessTenantMappingInput) bool {
	return tenant.Type == tenantEntity.TypeToStr(tenantEntity.Account)
}
