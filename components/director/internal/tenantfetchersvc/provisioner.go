package tenantfetchersvc

import (
	"context"
	"fmt"

	"github.com/kyma-incubator/compass/components/director/internal/model"
	"github.com/kyma-incubator/compass/components/director/pkg/apperrors"
	"github.com/kyma-incubator/compass/components/director/pkg/log"
	tenantEntity "github.com/kyma-incubator/compass/components/director/pkg/tenant"
	"github.com/pkg/errors"
)

const autogeneratedTenantProvider = "autogenerated"

//go:generate mockery --name=TenantService --output=automock --outpkg=automock --case=underscore --unroll-variadic=False
type TenantService interface {
	GetInternalTenant(ctx context.Context, externalTenant string) (string, error)
	CreateManyIfNotExists(ctx context.Context, tenantInputs ...model.BusinessTenantMappingInput) error
}

type TenantProvisioningRequest struct {
	AccountTenantID    string
	SubaccountTenantID string
	CustomerTenantID   string
	Subdomain          string
	Region             string
}

type provisioner struct {
	tenantSvc      TenantService
	tenantProvider string
}

func NewTenantProvisioner(tenantSvc TenantService, tenantProvider string) *provisioner {
	return &provisioner{
		tenantSvc:      tenantSvc,
		tenantProvider: tenantProvider,
	}
}

func (p *provisioner) ProvisionTenants(ctx context.Context, request TenantProvisioningRequest) error {
	if len(request.SubaccountTenantID) > 0 {
		return fmt.Errorf("tenant with ID %s is of type %s and supports only regional provisioning", request.SubaccountTenantID, tenantEntity.Subaccount)
	}

	tenants, err := p.tenantsFromRequest(ctx, request)
	if err != nil {
		return err
	}

	return p.tenantSvc.CreateManyIfNotExists(ctx, tenants...)
}

func (p *provisioner) ProvisionRegionalTenants(ctx context.Context, request TenantProvisioningRequest) error {
	tenants, err := p.tenantsFromRequest(ctx, request)
	if err != nil {
		return err
	}
	return p.tenantSvc.CreateManyIfNotExists(ctx, tenants...)
}

func (p *provisioner) tenantsFromRequest(ctx context.Context, request TenantProvisioningRequest) ([]model.BusinessTenantMappingInput, error) {
	tenants := make([]model.BusinessTenantMappingInput, 0)

	accountTenant := p.newAccountTenant(request.AccountTenantID, request.CustomerTenantID, request.Subdomain, request.Region)

	if len(request.SubaccountTenantID) > 0 {
		intTenantID, err := p.tenantSvc.GetInternalTenant(ctx, request.AccountTenantID)
		if err != nil && !apperrors.IsNotFoundError(err) {
			return nil, errors.Wrapf(err, "while checking if parent of type account already exists")
		}
		subaccountTenant := p.newSubaccountTenant(request.SubaccountTenantID, request.AccountTenantID, request.Subdomain, request.Region)
		if len(intTenantID) > 0 {
			log.C(ctx).Infof("Parent tenant with internal ID %s is already present", intTenantID)
			subaccountTenant.Parent = intTenantID
			return []model.BusinessTenantMappingInput{subaccountTenant}, nil
		}

		accountTenant.Subdomain = ""
		accountTenant.Region = ""
		tenants = append(tenants, subaccountTenant)
	}

	if len(request.CustomerTenantID) > 0 {
		intTenantID, err := p.tenantSvc.GetInternalTenant(ctx, request.CustomerTenantID)
		if err != nil && !apperrors.IsNotFoundError(err) {
			return nil, errors.Wrapf(err, "while checking if parent of type customer already exists")
		}
		if len(intTenantID) > 0 {
			request.CustomerTenantID = intTenantID
		} else {
			tenants = append(tenants, p.newCustomerTenant(request.CustomerTenantID))
		}
	}

	tenants = append(tenants, accountTenant)
	return tenants, nil
}

func (p *provisioner) newCustomerTenant(tenantID string) model.BusinessTenantMappingInput {
	return p.newTenant(tenantID, "", "", "", autogeneratedTenantProvider, tenantEntity.Customer)
}
func (p *provisioner) newAccountTenant(tenantID, parent, subdomain, region string) model.BusinessTenantMappingInput {
	return p.newTenant(tenantID, parent, subdomain, region, p.tenantProvider, tenantEntity.Account)
}

func (p *provisioner) newSubaccountTenant(tenantID, parent, subdomain, region string) model.BusinessTenantMappingInput {
	return p.newTenant(tenantID, parent, subdomain, region, p.tenantProvider, tenantEntity.Subaccount)
}

func (p *provisioner) newTenant(tenantID, parent, subdomain, region, provider string, tenantType tenantEntity.Type) model.BusinessTenantMappingInput {
	return model.BusinessTenantMappingInput{
		Name:           tenantID,
		ExternalTenant: tenantID,
		Parent:         parent,
		Subdomain:      subdomain,
		Region:         region,
		Type:           tenantEntity.TypeToStr(tenantType),
		Provider:       provider,
	}
}
