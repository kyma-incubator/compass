package tenant

import (
	"context"
	"database/sql"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/sirupsen/logrus"

	"github.com/kyma-incubator/compass/components/director/pkg/apperrors"

	"github.com/kyma-incubator/compass/components/director/pkg/log"
	tenantEntity "github.com/kyma-incubator/compass/components/director/pkg/tenant"
	"github.com/tidwall/gjson"

	"github.com/kyma-incubator/compass/components/director/internal/model"
	"github.com/kyma-incubator/compass/components/director/pkg/persistence"
	"github.com/pkg/errors"
)

const (
	GenericDatabaseError               = "Something went wrong with our database"
	ParentTenantConfigureDatabaseError = "Something went wrong while configuring parent tenant"
	CreateTenantDatabaseError          = "Something went wrong while creating tenant"
	GetTenantDatabaseError             = "Something went wrong while getting tenant"
	UpdateTenantDatabaseError          = "Something went wrong while updating tenant"

	autogeneratedTenantProvider = "autogenerated"
)

//go:generate mockery --name=TenantService --output=automock --outpkg=automock --case=underscore
type TenantService interface {
	Create(ctx context.Context, item model.TenantModel) error
	DeleteByExternalID(ctx context.Context, tenantId string) error
}

//go:generate mockery --name=UIDService --output=automock --outpkg=automock --case=underscore
type UIDService interface {
	Generate() string
}

type service struct {
	repository TenantRepository
	transact   persistence.Transactioner
	uidService UIDService
	config     Config
}

func NewService(tenant TenantRepository, transact persistence.Transactioner, uidService UIDService, config Config) *service {
	return &service{
		repository: tenant,
		transact:   transact,
		uidService: uidService,
		config:     config,
	}
}

func (s *service) Create(writer http.ResponseWriter, request *http.Request) {
	ctx := request.Context()
	logger := log.C(ctx)

	body, err := extractBody(request, writer)
	if err != nil {
		logger.WithError(err).Errorf("while extracting request body: %v", err)
		http.Error(writer, err.Error(), http.StatusInternalServerError)
		return
	}

	customerId := gjson.GetBytes(body, s.config.TenantProviderCustomerIdProperty)
	tenantId := gjson.GetBytes(body, s.config.TenantProviderTenantIdProperty)
	if !tenantId.Exists() || tenantId.Type != gjson.String || len(tenantId.String()) == 0 {
		logger.Errorf("Property %q not found in body or it is not of String type", s.config.TenantProviderTenantIdProperty)
		http.Error(writer, fmt.Sprintf("Property %q not found in body or it is not of String type", s.config.TenantProviderTenantIdProperty), http.StatusInternalServerError)
		return
	}

	warnOnEmptyGJsonProperty(logger, customerId, s.config.TenantProviderCustomerIdProperty)
	warnOnEmptyGJsonProperty(logger, tenantId, s.config.TenantProviderTenantIdProperty)

	var tenantsToCreate []model.TenantModel

	if len(customerId.String()) > 0 {
		customerTenant := model.TenantModel{
			ID:               s.uidService.Generate(),
			Name:             customerId.String(),
			TenantId:         customerId.String(),
			ParentExternalId: "",
			Type:             tenantEntity.Customer,
			Provider:         s.config.TenantProvider,
			Status:           tenantEntity.Active,
		}
		tenantsToCreate = append(tenantsToCreate, customerTenant)
	}

	accountTenant := model.TenantModel{
		ID:               s.uidService.Generate(),
		Name:             tenantId.String(),
		TenantId:         tenantId.String(),
		ParentExternalId: customerId.String(),
		Type:             tenantEntity.Account,
		Provider:         s.config.TenantProvider,
		Status:           tenantEntity.Active,
	}
	tenantsToCreate = append(tenantsToCreate, accountTenant)

	tx, err := s.transact.Begin()
	if err != nil {
		logger.WithError(err).Errorf("while beginning db transaction: %v", err)
		http.Error(writer, GenericDatabaseError, http.StatusInternalServerError)
		return
	}
	defer s.transact.RollbackUnlessCommitted(ctx, tx)

	ctx = persistence.SaveToContext(ctx, tx)

	for _, t := range tenantsToCreate {
		parentTenantInternalID, err := s.getParentTenantInternalID(ctx, t)
		if err != nil {
			logger.WithError(err).Errorf("while getting parent tenant ID for tenant with ID %s: %v", t.TenantId, err)
			http.Error(writer, ParentTenantConfigureDatabaseError, http.StatusInternalServerError)
			return
		}
		t.ParentInternalId = parentTenantInternalID

		if _, err := s.repository.GetByExternalID(ctx, t.TenantId); err != nil {
			if !apperrors.IsNotFoundError(err) && err != sql.ErrNoRows {
				logger.WithError(err).Errorf("while getting tenant with ID %s: %v", t.TenantId, err)
				http.Error(writer, GetTenantDatabaseError, http.StatusInternalServerError)
				return
			}

			if err := s.repository.Create(ctx, t); err != nil {
				if !apperrors.IsNotUniqueError(err) {
					logger.WithError(err).Errorf("while creating tenant: %v", err)
					http.Error(writer, CreateTenantDatabaseError, http.StatusInternalServerError)
					return
				}
			}

			continue
		}
		if err := s.repository.Update(ctx, t); err != nil {
			logger.WithError(err).Errorf("while updating tenant: %v", err)
			http.Error(writer, UpdateTenantDatabaseError, http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		logger.WithError(err).Errorf("while committing transaction : %v", err)
		http.Error(writer, GenericDatabaseError, http.StatusInternalServerError)
		return
	}

	writer.Header().Set("Content-Type", "text/plain")
	writer.WriteHeader(http.StatusOK)
	if _, err := writer.Write([]byte(compassURL)); err != nil {
		logger.WithError(err).Errorf("while writing response body: %v", err)
		http.Error(writer, err.Error(), http.StatusInternalServerError)
		return
	}
}

func (s *service) DeleteByExternalID(writer http.ResponseWriter, _ *http.Request) {
	writer.WriteHeader(http.StatusOK)
}

func (s *service) getParentTenantInternalID(ctx context.Context, tenant model.TenantModel) (string, error) {
	if len(tenant.ParentInternalId) > 0 || len(tenant.ParentExternalId) <= 0 {
		return tenant.ParentInternalId, nil
	}

	parentTenant, err := s.repository.GetByExternalID(ctx, tenant.ParentExternalId)
	if err == nil {
		return parentTenant.ID, nil
	}

	if !apperrors.IsNotFoundError(err) && err != sql.ErrNoRows {
		return "", errors.Wrapf(err, "while getting tenant with ID %s", tenant.TenantId)
	}

	autogeneratedParentTenant := model.TenantModel{
		ID:       s.uidService.Generate(),
		Name:     tenant.ParentExternalId,
		TenantId: tenant.ParentExternalId,
		Type:     tenantEntity.Unknown,
		Provider: autogeneratedTenantProvider,
		Status:   tenantEntity.Active,
	}
	if err = s.repository.Create(ctx, autogeneratedParentTenant); err != nil {
		return "", errors.Wrapf(err, "while creating autogenerated parent tenant for tenant with ID %s", tenant.TenantId)
	}

	return autogeneratedParentTenant.ID, nil
}

func extractBody(r *http.Request, w http.ResponseWriter) ([]byte, error) {
	logger := log.C(r.Context())

	buf, bodyErr := ioutil.ReadAll(r.Body)
	if bodyErr != nil {
		logger.Error(errors.Wrap(bodyErr, "while reading request body"))
		http.Error(w, bodyErr.Error(), http.StatusInternalServerError)
		return nil, bodyErr
	}

	defer func() {
		err := r.Body.Close()
		if err != nil {
			logger.Warnf("Unable to close request body. Cause: %v", err)
		}
	}()

	return buf, nil
}

func warnOnEmptyGJsonProperty(logger *logrus.Entry, prop gjson.Result, propName string) {
	if len(prop.String()) <= 0 {
		logger.Warnf("Property %q is missing", propName)
	}
}
