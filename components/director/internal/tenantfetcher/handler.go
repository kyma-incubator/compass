package tenantfetcher

import (
	"context"
	"database/sql"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/kyma-incubator/compass/components/director/pkg/apperrors"
	"github.com/pkg/errors"

	"github.com/kyma-incubator/compass/components/director/pkg/log"
	tenantEntity "github.com/kyma-incubator/compass/components/director/pkg/tenant"
	"github.com/tidwall/gjson"

	"github.com/kyma-incubator/compass/components/director/internal/model"
	"github.com/kyma-incubator/compass/components/director/pkg/persistence"
)

const (
	compassURL                  = "https://github.com/kyma-incubator/compass"
	tenantCreationFailureMsgFmt = "Failed to create tenant with ID %s"

	autogeneratedTenantProvider = "autogenerated"
)

//go:generate mockery --name=UIDService --output=automock --outpkg=automock --case=underscore
type UIDService interface {
	Generate() string
}

type HandlerConfig struct {
	HandlerEndpoint string `envconfig:"APP_HANDLER_ENDPOINT,default=/v1/callback/{tenantId}"`
	TenantPathParam string `envconfig:"APP_TENANT_PATH_PARAM,default=tenantId"`

	TenantProviderTenantIdProperty   string `envconfig:"APP_TENANT_PROVIDER_TENANT_ID_PROPERTY"`
	TenantProviderCustomerIdProperty string `envconfig:"APP_TENANT_PROVIDER_CUSTOMER_ID_PROPERTY"`
	TenantProviderSubdomainProperty  string `envconfig:"APP_TENANT_PROVIDER_SUBDOMAIN_PROPERTY"`
	TenantProvider                   string `envconfig:"APP_TENANT_PROVIDER"`

	JWKSSyncPeriod            time.Duration `envconfig:"default=5m"`
	AllowJWTSigningNone       bool          `envconfig:"APP_ALLOW_JWT_SIGNING_NONE,default=true"`
	JwksEndpoint              string        `envconfig:"APP_JWKS_ENDPOINT"`
	SubscriptionCallbackScope string        `envconfig:"APP_SUBSCRIPTION_CALLBACK_SCOPE"`
}

type handler struct {
	tenantSvc TenantService
	transact  persistence.Transactioner
	config    HandlerConfig
}

func NewTenantsHTTPHandler(tenantSvc TenantService, transact persistence.Transactioner, config HandlerConfig) *handler {
	return &handler{
		tenantSvc: tenantSvc,
		transact:  transact,
		config:    config,
	}
}

func (h *handler) Create(writer http.ResponseWriter, request *http.Request) {
	ctx := request.Context()

	body, err := readBody(request)
	if err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to read tenant information from request body: %v", err)
		http.Error(writer, "Failed to read tenant information from request body", http.StatusInternalServerError)
		return
	}
	accountTenant, err := h.tenantInfoFromBody(body)
	if err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to extract tenant information from request body: %v", err)
		http.Error(writer, fmt.Sprintf("Failed to extract tenant information from request body: %s", err.Error()), http.StatusBadRequest)
		return
	}

	externalTenantID := accountTenant.ExternalTenant
	tx, err := h.transact.Begin()
	if err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to start DB transaction: %v", err)
		http.Error(writer, fmt.Sprintf(tenantCreationFailureMsgFmt, externalTenantID), http.StatusInternalServerError)
		return
	}
	defer h.transact.RollbackUnlessCommitted(ctx, tx)

	ctx = persistence.SaveToContext(ctx, tx)

	parentExternalID := accountTenant.Parent
	var parentInternalID string
	if len(parentExternalID) > 0 {
		parentInternalID, err = h.ensureParentExists(ctx, parentExternalID, accountTenant.ExternalTenant)
		if err != nil {
			log.C(ctx).WithError(err).Errorf("Failed to ensure parent tenant with external ID %s exists: %v", parentExternalID, err)
			http.Error(writer, fmt.Sprintf("Failed to ensure parent tenant with ID %s exists", parentExternalID), http.StatusInternalServerError)
			return
		}
		accountTenant.Parent = parentInternalID
	}

	if err := h.tenantSvc.CreateManyIfNotExists(ctx, *accountTenant); err != nil {
		if !apperrors.IsNotUniqueError(err) {
			log.C(ctx).WithError(err).Errorf("Failed to create tenant with external ID %s: %v", externalTenantID, err)
			http.Error(writer, fmt.Sprintf(tenantCreationFailureMsgFmt, externalTenantID), http.StatusInternalServerError)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to commit transaction while storing tenant with external ID %s: %v", externalTenantID, err)
		http.Error(writer, fmt.Sprintf(tenantCreationFailureMsgFmt, externalTenantID), http.StatusInternalServerError)
		return
	}

	writer.Header().Set("Content-Type", "text/plain")
	writer.WriteHeader(http.StatusOK)
	if _, err := writer.Write([]byte(compassURL)); err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to write response body for tenant request creation for tenant %s: %v", externalTenantID, err)
	}
}

func (h *handler) DeleteByExternalID(writer http.ResponseWriter, _ *http.Request) {
	writer.WriteHeader(http.StatusOK)
}

func (h *handler) tenantInfoFromBody(body []byte) (*model.BusinessTenantMappingInput, error) {
	tenantId := gjson.GetBytes(body, h.config.TenantProviderTenantIdProperty).String()
	if len(tenantId) <= 0 {
		return nil, fmt.Errorf("mandatory tenant ID property %q is missing from request body", h.config.TenantProviderTenantIdProperty)
	}
	subdomain := gjson.GetBytes(body, h.config.TenantProviderSubdomainProperty).String()
	if len(subdomain) <= 0 {
		return nil, fmt.Errorf("mandatory subdomain property %q is missing from request body", h.config.TenantProviderSubdomainProperty)
	}
	customerId := gjson.GetBytes(body, h.config.TenantProviderCustomerIdProperty).String()

	return &model.BusinessTenantMappingInput{
		Name:           tenantId,
		ExternalTenant: tenantId,
		Parent:         customerId,
		Type:           tenantEntity.TypeToStr(tenantEntity.Account),
		Provider:       h.config.TenantProvider,
		Subdomain:      subdomain,
	}, nil
}

func readBody(r *http.Request) ([]byte, error) {
	ctx := r.Context()

	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, err
	}

	defer func() {
		if err := r.Body.Close(); err != nil {
			log.C(ctx).WithError(err).Errorf("Unable to close request body: %v", err)
		}
	}()

	return buf, nil
}

func (h *handler) ensureParentExists(ctx context.Context, parentTenantID, childTenantID string) (string, error) {
	log.C(ctx).Infof("Ensuring parent tenant with external ID %s for tenant with external ID %s exists", parentTenantID, childTenantID)
	id, err := h.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	if err != nil && !apperrors.IsNotFoundError(err) && err != sql.ErrNoRows {
		return "", err
	}
	if id != "" {
		log.C(ctx).Infof("Parent tenant with external ID %s already exists", parentTenantID)
		return id, nil
	}

	log.C(ctx).Infof("Creating parent tenant with external ID %s", parentTenantID)
	tenant := h.customerTenant(parentTenantID)
	err = h.tenantSvc.CreateManyIfNotExists(ctx, tenant)
	if err != nil && apperrors.IsNotUniqueError(err) {
		log.C(ctx).Infof("Parent tenant with external ID %s already exists", parentTenantID)
		return h.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	} else if err != nil {
		return "", errors.Wrapf(err, "failed to create parent tenant with ID %s", parentTenantID)
	}

	internalID, err := h.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	if err != nil {
		return "", errors.Wrapf(err, "failed to retrieve internal ID of parent with external ID %s", parentTenantID)
	}

	log.C(ctx).Infof("Successfully created parent tenant with external ID %s and internal ID %s", parentTenantID, internalID)
	return internalID, nil
}

func (h *handler) customerTenant(tenantID string) model.BusinessTenantMappingInput {
	return model.BusinessTenantMappingInput{
		Name:           tenantID,
		ExternalTenant: tenantID,
		Parent:         "",
		Subdomain:      "",
		Type:           tenantEntity.TypeToStr(tenantEntity.Customer),
		Provider:       autogeneratedTenantProvider,
	}
}
