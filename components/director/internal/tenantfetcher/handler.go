package tenantfetcher

import (
	"context"
	"database/sql"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/kyma-incubator/compass/components/director/pkg/apperrors"
	"github.com/pkg/errors"

	"github.com/kyma-incubator/compass/components/director/pkg/log"
	tenantEntity "github.com/kyma-incubator/compass/components/director/pkg/tenant"
	"github.com/tidwall/gjson"

	"github.com/kyma-incubator/compass/components/director/internal/model"
	"github.com/kyma-incubator/compass/components/director/pkg/persistence"
)

const (
	compassURL                  = "https://github.com/kyma-incubator/compass"
	tenantCreationFailureMsgFmt = "Failed to create tenant with ID %s"

	autogeneratedTenantProvider = "autogenerated"
	subdomainLabelKey           = "subdomain"
)

//go:generate mockery --name=UIDService --output=automock --outpkg=automock --case=underscore
type UIDService interface {
	Generate() string
}

type HandlerConfig struct {
	HandlerEndpoint string `envconfig:"APP_HANDLER_ENDPOINT,default=/v1/callback/{tenantId}"`
	TenantPathParam string `envconfig:"APP_TENANT_PATH_PARAM,default=tenantId"`

	TenantProviderTenantIdProperty   string `envconfig:"APP_TENANT_PROVIDER_TENANT_ID_PROPERTY"`
	TenantProviderCustomerIdProperty string `envconfig:"APP_TENANT_PROVIDER_CUSTOMER_ID_PROPERTY"`
	TenantProviderSubdomainProperty  string `envconfig:"APP_TENANT_PROVIDER_SUBDOMAIN_PROPERTY"`
	TenantProvider                   string `envconfig:"APP_TENANT_PROVIDER"`

	JWKSSyncPeriod            time.Duration `envconfig:"default=5m"`
	AllowJWTSigningNone       bool          `envconfig:"APP_ALLOW_JWT_SIGNING_NONE,default=true"`
	JwksEndpoints             string        `envconfig:"APP_JWKS_ENDPOINTS"`
	IdentityZone              string        `envconfig:"APP_TENANT_IDENTITY_ZONE"`
	SubscriptionCallbackScope string        `envconfig:"APP_SUBSCRIPTION_CALLBACK_SCOPE"`
}

type handler struct {
	tenantSvc  TenantService
	labelRepo  LabelRepository
	transact   persistence.Transactioner
	uidService UIDService
	config     HandlerConfig
}

func NewTenantsHTTPHandler(tenantSvc TenantService, labelRepository LabelRepository, transact persistence.Transactioner, uidService UIDService, config HandlerConfig) *handler {
	return &handler{
		tenantSvc:  tenantSvc,
		transact:   transact,
		labelRepo:  labelRepository,
		uidService: uidService,
		config:     config,
	}
}

func (h *handler) Create(writer http.ResponseWriter, request *http.Request) {
	ctx := request.Context()

	accountTenant, subdomain, err := h.tenantInfoFromBody(request)
	if err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to extract tenant information from request body: %v", err)
		http.Error(writer, "Failed to extract tenant information from request body", http.StatusBadRequest)
		return
	}

	externalTenantID := accountTenant.ExternalTenant
	tx, err := h.transact.Begin()
	if err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to start DB transaction: %v", err)
		http.Error(writer, fmt.Sprintf(tenantCreationFailureMsgFmt, externalTenantID), http.StatusInternalServerError)
		return
	}
	defer h.transact.RollbackUnlessCommitted(ctx, tx)

	ctx = persistence.SaveToContext(ctx, tx)

	parentExternalID := accountTenant.Parent
	var parentInternalID string
	if len(parentExternalID) > 0 {
		parentInternalID, err = h.ensureParentExists(ctx, parentExternalID, accountTenant.ID)
		if err != nil {
			log.C(ctx).WithError(err).Errorf("Failed to ensure parent tenant with external ID %s exists: %v", parentExternalID, err)
			http.Error(writer, fmt.Sprintf("Failed to ensure parent tenant with ID %s exists", parentExternalID), http.StatusInternalServerError)
			return
		}
		accountTenant.Parent = parentInternalID
	}

	if err := h.tenantSvc.CreateManyIfNotExists(ctx, []model.BusinessTenantMapping{*accountTenant}); err != nil {
		if !apperrors.IsNotUniqueError(err) {
			log.C(ctx).WithError(err).Errorf("Failed to create tenant with external ID %s: %v", externalTenantID, err)
			http.Error(writer, fmt.Sprintf(tenantCreationFailureMsgFmt, externalTenantID), http.StatusInternalServerError)
			return
		}
	}

	subdomainLabel := model.NewLabelForTenant(*accountTenant, subdomainLabelKey, subdomain)
	if err := h.labelRepo.Upsert(ctx, subdomainLabel); err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to add subdomain label to tenant with external ID %s: %v", externalTenantID, err)
		http.Error(writer, fmt.Sprintf("Failed to add subdomain label to tenant with external ID %s", externalTenantID), http.StatusInternalServerError)
		return
	}

	if err := tx.Commit(); err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to commit transaction while storing tenant with external ID %s: %v", externalTenantID, err)
		http.Error(writer, fmt.Sprintf(tenantCreationFailureMsgFmt, externalTenantID), http.StatusInternalServerError)
		return
	}

	writer.Header().Set("Content-Type", "text/plain")
	writer.WriteHeader(http.StatusOK)
	if _, err := writer.Write([]byte(compassURL)); err != nil {
		log.C(ctx).WithError(err).Errorf("Failed to write response body for tenant request creation for tenant %s: %v", externalTenantID, err)
		return
	}
}

func (h *handler) DeleteByExternalID(writer http.ResponseWriter, _ *http.Request) {
	writer.WriteHeader(http.StatusOK)
}

func (h *handler) tenantInfoFromBody(r *http.Request) (*model.BusinessTenantMapping, string, error) {
	body, err := readBody(r)
	if err != nil {
		return nil, "", errors.Wrap(err, "failed to read request body")
	}

	tenantId := gjson.GetBytes(body, h.config.TenantProviderTenantIdProperty)
	if !tenantId.Exists() {
		return nil, "", fmt.Errorf("mandatory tenant ID property %q is missing from request body", h.config.TenantProviderTenantIdProperty)
	}
	subdomain := gjson.GetBytes(body, h.config.TenantProviderSubdomainProperty)
	if !subdomain.Exists() {
		return nil, "", fmt.Errorf("mandatory subdomain property %q is missing from request body", h.config.TenantProviderSubdomainProperty)
	}
	customerId := gjson.GetBytes(body, h.config.TenantProviderCustomerIdProperty)

	return &model.BusinessTenantMapping{
		ID:             h.uidService.Generate(),
		Name:           tenantId.String(),
		ExternalTenant: tenantId.String(),
		Parent:         customerId.String(),
		Type:           tenantEntity.Account,
		Provider:       h.config.TenantProvider,
		Status:         tenantEntity.Active,
	}, subdomain.String(), nil
}

func readBody(r *http.Request) ([]byte, error) {
	ctx := r.Context()

	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, err
	}

	defer func() {
		if err := r.Body.Close(); err != nil {
			log.C(ctx).WithError(err).Errorf("Unable to close request body: %v", err)
		}
	}()

	return buf, nil
}

func (h *handler) ensureParentExists(ctx context.Context, parentTenantID, childTenantID string) (string, error) {
	log.C(ctx).Infof("Ensuring parent tenant with external ID %s for tenant with ID %s exists", parentTenantID, childTenantID)
	id, err := h.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	if err != nil && !apperrors.IsNotFoundError(err) && err != sql.ErrNoRows {
		return "", err
	}
	if id != "" {
		log.C(ctx).Infof("Parent tenant with external ID %s already exists", parentTenantID)
		return id, nil
	}

	log.C(ctx).Infof("Creating parent tenant with external ID %s", parentTenantID)
	tenant := customerTenant(parentTenantID)
	err = h.tenantSvc.CreateManyIfNotExists(ctx, []model.BusinessTenantMapping{tenant})
	if err != nil && apperrors.IsNotUniqueError(err) {
		log.C(ctx).Infof("Parent tenant with external ID %s already exists", parentTenantID)
		return h.tenantSvc.GetInternalTenant(ctx, parentTenantID)
	} else if err != nil {
		return "", errors.Wrapf(err, "failed to create parent tenant with ID %s", parentTenantID)
	}

	return tenant.ID, nil
}

func customerTenant(tenantID string) model.BusinessTenantMapping {
	return model.BusinessTenantMapping{
		Name:           tenantID,
		ExternalTenant: tenantID,
		Type:           tenantEntity.Customer,
		Provider:       autogeneratedTenantProvider,
		Status:         tenantEntity.Active,
	}
}
