# Scalars

scalar Timestamp

scalar Tenant # -> String

scalar Labels # -> map[string]string

scalar Annotations # -> map[string]interface{}

scalar HttpHeaders # -> map[string][]string

scalar JSON # -> map[string]interface{}

# Runtime

type Runtime {
    id: ID!
    name: String!
    description: String
    tenant: Tenant!
    labels(key: String): Labels!
    annotations: Annotations!
    agentCredential: Credential!
    status: RuntimeStatus!
}

type RuntimeStatus {
    condition: RuntimeStatusCondition!
    timestamp: Timestamp!
}

enum RuntimeStatusCondition {
    INITIAL
    READY
    FAILED
}

# Application

type Application {
    id: ID!
    name: String!
    tenant: Tenant!
    description: String
    labels(key: String): Labels!
    annotations: Annotations!
    status: ApplicationStatus!
    webhooks: [ApplicationWebhook!]!
    apis: [API!]!
    events: [Event!]!
    docs: [Documentation!]!
}

type ApplicationStatus {
    condition: ApplicationStatusCondition!
    timestamp: Timestamp!
}

enum ApplicationStatusCondition {
    INITIAL 
    UNKNOWN
    READY
    FAILED
}

type ApplicationWebhook {
    type: ApplicationWebhookType!
    url: String!
    credential: Credential
}

enum ApplicationWebhookType {
    HEALTH_CHECK
    CONFIGURATION
}

# API #TODO: Make sure it's compatible with Kyma CMS

type API {
    id: ID!
    spec: APISpec!
    targetURL: String!
    credential: Credential
    headers: HttpHeaders
}

type APISpec {
    type: APISpecType!
    data: JSON!
    fetchRequest: FetchRequest
}

enum APISpecType {
    O_DATA
    OPEN_API
}

# Event #TODO: Make sure it's compatible with Kyma CMS

type Event {
    id: ID!
    spec: EventSpec!
}

type EventSpec {
    type: EventSpecType!
    data: JSON!
    fetchRequest: FetchRequest
}

enum EventSpecType {
    ASYNC_API
}

# Documentation #TODO: Make sure it's compatible with Kyma CMS

type Documentation {
    id: ID!
    displayName: String!
    description: String!
    type: DocumentationType!
    data: [Document!]!
    fetchRequest: FetchRequest
}

enum DocumentationType {
    MARKDOWN
}

type Document {
    title: String!
    type: String! #TODO: what are these fields, should they stay as String?
    source: String! #TODO: what are these fields, should they stay as String?
}

# FetchRequest

type FetchRequest { #TODO: Who fetches data? Management plane or runtime?
    url: String!
    credential: Credential
    status: FetchRequestStatus!
}

type FetchRequestStatus {
    condition: FetchRequestStatusCondition!
    timestamp: Timestamp!
}

enum FetchRequestStatusCondition {
    INITIAL
    SUCCEEDED
    FAILED
}

# Credential

type Credential {
    data: CredentialData!
    requestAuth: CredentialRequestAuth
}

type CredentialData {
    type: CredentialDataType!
    basic: BasicCredentialData
    oauth: OAuthCredentialData
}

enum CredentialDataType {
    BASIC
    OAUTH
}

type OAuthCredentialData {
    clientId: ID!
    clientSecret: String!
    url: String!
}

type BasicCredentialData {
    username: String!
    password: String!
}

type CredentialRequestAuth {
    type: CredentialRequestAuthType!
    csrf: CSRFTokenCredentialRequestAuth
}

enum CredentialRequestAuthType {
    CSRF_TOKEN
}

type CSRFTokenCredentialRequestAuth {
    token: String!
}

# HealthCheck

#TODO: Rethink
union HealthCheckStatus = RuntimeHealthCheck | ManagementPlaneHealthCheck

enum HealthCheckStatusCondition {
    SUCCEEDED # TODO: doesn't look good... maybe we should unify all 'Success' values
    FAILED
}

enum ManagementPlaneHealthCheckType {
    MANAGEMENT_PLANE_HEALTHCHECK
    MANAGEMENT_PLANE_APPLICATION_HEALTHCHECK
}

enum RuntimeHealthCheckType {
    RUNTIME_HEALTHCHECK
    RUNTIME_APPLICATION_HEALTHCHECK
    RUNTIME_APPLICATION_EVENTS
    RUNTIME_APPLICATION_GATEWAY
}

type ManagementPlaneHealthCheck {
    type: ManagementPlaneHealthCheckType!
    condition: HealthCheckStatusCondition!
    message: String
    timestamp: Timestamp!
}

type RuntimeHealthCheck {
    origin: ID!
    type: RuntimeHealthCheckType!
    condition: HealthCheckStatusCondition!
    message: String
    timestamp: Timestamp!
}

# Label & Annotation

type Label {
    key: String!
    value: String!
}

type Annotation {
    key: String!
    value: JSON! #TODO: maybe we should use serialized string instead? Further discussion needed
}

# INPUTS

# Application Input

input ApplicationInput {
    name: String!
    description: String
    labels: Labels
    annotations: Annotations
    apis: [APIInput!]
    events: [EventInput!]
    documentations: [DocumentationInput!]
}

# Runtime Input

input RuntimeInput {
    name: String!
    labels: Labels
    annotations: Annotations
    agentCredential: CredentialInput!
}

# FetchRequest Input

input FetchRequestInput {
    url: String
    credential: CredentialInput
}

# Webhook Input

input ApplicationWebhookInput {
    type: ApplicationWebhookType!
    url: String!
    credential: CredentialInput
}

# API Input

input APIInput {
    type: APISpecType!
    targetURL: String!
    data: JSON
    fetchRequest: FetchRequestInput
    credential: CredentialInput
    headers: HttpHeaders
}

# Event Input

input EventInput {
    type: EventSpecType!
    data: JSON
    fetchRequest: FetchRequestInput
}

# Documentation Input

input DocumentationInput {
    type: DocumentationType!
    data: [DocumentInput!]
    fetchRequest: FetchRequestInput
}

input DocumentInput {
    title: String!
    type: String! #TODO: what are these fields, should they stay as String?
    source: String! #TODO: what are these fields, should they stay as String?
}

# Credential Input

input CredentialInput {
    data: CredentialDataInput!
    requestAuth: CredentialRequestAuthInput
}

input CredentialRequestAuthInput {
    type: CredentialRequestAuthType!
    csrf: CSRFTokenCredentialRequestAuthInput
}

input CSRFTokenCredentialRequestAuthInput {
    token: String!
}

input CredentialDataInput {
    type: CredentialDataType!
    basic: BasicCredentialDataInput
    oauth: OAuthCredentialDataInput
}

input OAuthCredentialDataInput {
    clientId: ID!
    clientSecret: String!
    url: String!
}

input BasicCredentialDataInput {
    username: String!
    password: String!
}

# Healthcheck Input

input RuntimeHealthCheckInput {
    type: RuntimeHealthCheckType!
    condition: HealthCheckStatusCondition!
    message: String
}

#

type Query {
    applications: [Application!]!
    application(id: ID!): Application

    runtimes: [Runtime!]!
    runtime(id: ID!): Runtime

    healthchecks(labels: [String!]): [HealthCheckStatus!]!
    runtimeHealthchecks(origin: ID, type: [RuntimeHealthCheckType!], labels: [String!]): [HealthCheckStatus!]! # Has to be validated at runtime
    managementPlaneHealthchecks(type: [ManagementPlaneHealthCheckType!], labels: [String!]): [HealthCheckStatus!]!

    labels(key: String): [Labels!]!
}

type Mutation {
    # Application
    createApplication(in: ApplicationInput!): Application
    updateApplication(id: ID!, in: ApplicationInput!): Application
    deleteApplication(id: ID!): Application

    createApplicationLabel(applicationID: ID!, label: String!, value: String!): Label
    deleteApplicationLabel(id: ID!, label: String!): Label

    createApplicationAnnotation(applicationID: ID!, annotation: String!, value: JSON!): Annotation
    deleteApplicationAnnotation(id: ID!, label: String!): Annotation

    createApplicationWebhook(applicationID: ID!, in: ApplicationWebhookInput!): ApplicationWebhook
    updateApplicationWebhook(applicationID: ID!, type: ApplicationWebhookType, in: ApplicationWebhookInput): ApplicationWebhook
    deleteApplicationWebhook(applicationID: ID!, type: ApplicationWebhookType): ApplicationWebhook

    createAPI(applicationID: ID!, in: APIInput!): API
    updateAPI(id: ID!, in: APIInput!): API
    deleteAPI(id: ID!): API

    createAPICredential(apiID: ID!, in: CredentialInput!): Credential
    deleteAPICredential(apiID: ID!): Credential

    createEvent(applicationID: ID!, in: EventInput!): Event
    updateEvent(id: ID!, in: EventInput!): Event
    deleteEvent(id: ID!): Event

    createDocumentation(applicationID: ID!, in: DocumentationInput!): Documentation
    updateDocumentation(id: ID!, in: DocumentationInput!): Documentation
    deleteDocumentation(id: ID!): Documentation

    # Runtime
    createRuntime(in: RuntimeInput!): Runtime
    updateRuntime(id: ID!, in: RuntimeInput!): Runtime
    deleteRuntime(id: ID!): Runtime

    createRuntimeLabel(runtimeID: ID!, label: String!, value: String!): Label
    deleteRuntimeLabel(id: ID!, label: String!): Label

    createRuntimeAnnotation(runtimeID: ID!, annotation: String!, value: JSON!): Annotation
    deleteRuntimeAnnotation(id: ID!, annotation: String!): Annotation

    # Healthcheck
    createRuntimeHealthCheck(in: RuntimeHealthCheckInput!): HealthCheckStatus
}
