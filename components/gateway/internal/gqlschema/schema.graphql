# Scalars

scalar Timestamp

scalar Tenant # -> String

scalar Labels # -> map[string][]string

scalar Annotations # -> map[string]interface{}

scalar HttpHeaders # -> map[string][]string

scalar QueryParams # -> map[string][]string

scalar Clob # TBD

# Runtime

type Runtime {
    id: ID!
    name: String!
    description: String
    tenant: Tenant!
    labels(key: String): Labels!
    annotations: Annotations!
    status: RuntimeStatus!
    # directive for checking auth
    agentCredential: Credential!

}

type RuntimeStatus {
    condition: RuntimeStatusCondition!
    timestamp: Timestamp!
}

enum RuntimeStatusCondition {
    INITIAL
    READY
    FAILED
}

# Application

type Application {
    id: ID!
    name: String!
    tenant: Tenant!
    description: String
    labels(key: String): Labels!
    annotations: Annotations!
    status: ApplicationStatus!
    webhooks: [ApplicationWebhook!]!
    healthCheckURL: String
    apis: [API!]!
    events: [Event!]!
    # TODO docu: high-level
}

type ApplicationStatus {
    condition: ApplicationStatusCondition!
    timestamp: Timestamp!
}

enum ApplicationStatusCondition {
    INITIAL
    UNKNOWN
    READY
    FAILED
}

type ApplicationWebhook {
    id: ID!
    type: ApplicationWebhookType!
    url: String!
    credential: Credential
}

enum ApplicationWebhookType {
    CONFIGURATION_CHANGED
}

# API

type Version {
    value: String! # for example 4.6
    deprecated: Boolean
    since: String! # for example 4.5 #TODO
    forRemoval: Boolean # if true, will be removed in the next version

}

type API {
    id: ID!
    spec: APISpec!
    targetURL: String!
    credential: Credential
    injectHeaders: HttpHeaders # TODO additionalHeaders
    injectQueryParams: QueryParams
    version: Version
    documentations: [Documentation!]! # TODO documantations is incorrect

}

type APISpec {
    # when fetch request specified, data will be automatically populated
    data: Clob
    # format:  TODO yaml, json
    type: APISpecType!
    fetchRequest: FetchRequest
}

enum APISpecType {
    ODATA,
    OPEN_API
}

enum EventSpecType {
    ASYNC_API
}

# Event

type Event {
    id: ID!
    spec: EventSpec!
    version: Version
    documentations: [Documentation!]!
}

type EventSpec {
    data: Clob
    type: EventSpecType!
    fetchRequest: FetchRequest
}

# Documentation

type Documentation {
    id: ID!
    title: String!
    displayName: String!
    description: String!
    format: DocumentationFormat!
    kind: String   # for example Service Class, API etc
    data: Clob
    fetchRequest: FetchRequest # TODO how fetching is performed: CR in mgmt plane?
}

enum DocumentationFormat {
    MARKDOWN
}


# FetchRequest

type FetchRequest {
    url: String!
    credential: Credential
    mode: FetchMode
    filter: String
    status: FetchRequestStatus!
}

type FetchRequestStatus {
    condition: FetchRequestStatusCondition!
    timestamp: Timestamp!
}

enum FetchRequestStatusCondition {
    INITIAL
    SUCCEEDED
    FAILED
}

enum FetchMode {
    SINGLE
    PACKAGE
    INDEX
}

# Credential
# TODO: input the same as now, output returns union
type Credential {
    data: CredentialData!
    requestAuth: CredentialRequestAuth
}

type CredentialData {
    type: CredentialDataType! #TODO consider removing type
    basic: BasicCredentialData
    oauth: OAuthCredentialData
}

enum CredentialDataType {
    BASIC
    OAUTH
}

type OAuthCredentialData {
    clientId: ID!
    clientSecret: String!
    url: String!
}

type BasicCredentialData {
    username: String!
    password: String!
}

type CredentialRequestAuth {
    type: CredentialRequestAuthType!
    csrf: CSRFTokenCredentialRequestAuth
}

enum CredentialRequestAuthType {
    CSRF_TOKEN
}

type CSRFTokenCredentialRequestAuth {
    token: String!
}

# HealthCheck



enum HealthCheckStatusCondition {
    SUCCEEDED
    FAILED
}

enum HealthCheckType {
    MANAGEMENT_PLANE_APPLICATION_HEALTHCHECK
}

type HealthCheck {
    type: HealthCheckType!
    condition: HealthCheckStatusCondition!
    origin: ID
    message: String
    timestamp: Timestamp!
}


# INPUTS

# Application Input

input ApplicationInput {
    name: String!
    description: String
    labels: Labels
    annotations: Annotations
    webhooks: [ApplicationWebhookInput]
    healthCheckURL: String
    apis: [APIInput!]
    events: [EventInput!]
}

# Runtime Input

input RuntimeInput {
    name: String!
    description: String
    labels: Labels
    annotations: Annotations
}

# FetchRequest Input

input FetchRequestInput {
    url: String
    credential: CredentialInput
    mode: FetchMode
    filter: String
}

# Webhook Input

input ApplicationWebhookInput {
    type: ApplicationWebhookType!
    url: String!
    credential: CredentialInput
}

# API Input

input APIInput {
    targetURL: String!
    credential: CredentialInput
    spec: APISpecInput
    injectHeaders: HttpHeaders
    injectQueryParams: QueryParams
    documentations: [DocumentationInput!]
}

input APISpecInput {
    data: Clob
    apiSpecType: APISpecType!
    fetchRequest: FetchRequestInput
}

# Event Input

input EventInput {
    spec: EventSpecInput
    documentations: [DocumentationInput!]
}

input EventSpecInput {
    data: Clob
    eventSpecType: EventSpecType!
    fetchRequest: FetchRequestInput
}

# Documentation Input

input DocumentationInput {
    title: String!
    displayName: String!
    description: String!
    format: DocumentationFormat!
    kind: String
    data: Clob
    fetchRequest: FetchRequestInput
}


# Credential Input

input CredentialInput {
    data: CredentialDataInput!
    requestAuth: CredentialRequestAuthInput
}

input CredentialRequestAuthInput {
    type: CredentialRequestAuthType!
    csrf: CSRFTokenCredentialRequestAuthInput
}

input CSRFTokenCredentialRequestAuthInput {
    token: String!
}

input CredentialDataInput {
    type: CredentialDataType!
    basic: BasicCredentialDataInput
    oauth: OAuthCredentialDataInput
}

input OAuthCredentialDataInput {
    clientId: ID!
    clientSecret: String!
    url: String!
}

input BasicCredentialDataInput {
    username: String!
    password: String!
}

# HealthCheck Input


enum FilterOperator {
    ALL, ANY #TODO default
}

input LabelFilter {
    label: String!
    values: [String!]!
    operator: FilterOperator
}

type Query {
    applications(filer: [LabelFilter!]): [Application!]!
    application(id: ID!): Application

    runtimes(filter: [LabelFilter!]): [Runtime!]!
    runtime(id: ID!): Runtime

    healthChecks(types: [HealthCheckType], originID: ID): [HealthCheck!]!
    labels(key: String): [String!]!

}

type Mutation {
    # Application
    createApplication(in: ApplicationInput!): Application!
    updateApplication(id: ID!, in: ApplicationInput!): Application!
    deleteApplication(id: ID!): Application

    addApplicationLabel(applicationID: ID!, label: String!, values: [String!]!): [String!]!
    # if application does not exist, return error
    deleteApplicationLabel(applicationID: ID!, label: String!, values: [String!]!): [String!]

    addApplicationAnnotation(applicationID: ID!, annotation: String!, value: String!): String!
    deleteApplicationAnnotation(applicationID: ID!, annotation: String!): String

    addApplicationWebhook(applicationID: ID!, in: ApplicationWebhookInput!): ApplicationWebhook!
    updateApplicationWebhook(webhookID: ID!, in: ApplicationWebhookInput!): ApplicationWebhook!
    deleteApplicationWebhook(webhookID: ID!): ApplicationWebhook

    addAPI(applicationID: ID!, in: APIInput!): API!
    updateAPI(id: ID!, in: APIInput!): API!
    deleteAPI(id: ID!): API
    refetchAPISpec(apiID: ID!): APISpec

    setAPICredential(apiID: ID!, in: CredentialInput!): Credential!
    deleteAPICredential(apiID: ID!): Credential

    addEvent(applicationID: ID!, in: EventInput!): Event!
    updateEvent(id: ID!, in: EventInput!): Event!
    deleteEvent(id: ID!): Event
    refetchEventSpec(eventID: ID!): EventSpec

    # Runtime
    createRuntime(in: RuntimeInput!): Runtime!
    updateRuntime(id: ID!, in: RuntimeInput!): Runtime!
    deleteRuntime(id: ID!): Runtime

    addRuntimeLabel(runtimeID: ID!, label: String!, values: [String!]!): [String!]!
    deleteRuntimeLabel(id: ID!, label: String! ,values: [String!]!): [String!]!

    addRuntimeAnnotation(runtimeID: ID!, annotation: String!, value: String!): String!
    deleteRuntimeAnnotation(id: ID!, annotation: String!): String!

}

