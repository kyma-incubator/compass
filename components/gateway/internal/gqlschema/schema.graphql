# Scalars

scalar Timestamp

scalar Tenant

scalar Labels
scalar Annotations

scalar HttpHeaders

scalar JSON

# Runtime

type Runtime {
    id: ID!
    name: String!
    tenant: Tenant!
    labels: Labels!
    annotations: Annotations!
    agentCredentials: Credentials
    status: RuntimeStatus!
}

type RuntimeStatus {
    condition: RuntimeStatusCondition!
    timestamp: Timestamp!
}

enum RuntimeStatusCondition {
    INITIAL
    READY
    FAILED
}

# Application

type Application {
    id: ID!
    name: String!
    tenant: Tenant!
    description: String
    labels: Labels
    annotations: Annotations
    status: ApplicationStatus!
    webhooks: [ApplicationWebhook!]
    apis: [Api!]
    events: [Event!]
    docs: [Document!]
}

type ApplicationStatus {
    condition: ApplicationStatusCondition!
    timestamp: Timestamp!
}

enum ApplicationStatusCondition {
    INITIAL 
    UNKNOWN
    READY
    FAILED
}

type ApplicationWebhook {
    type: ApplicationWebhookType!
    url: String!
    credentials: Credentials
}

enum ApplicationWebhookType {
    HEALTH_CHECK
    CONFIGURATION
}

# API

type Api {
    spec: ApiSpec!
    targetURL: String!
    credentials: Credentials
    headers: HttpHeaders
}

type ApiSpec {
    type: ApiSpecType!
    data: JSON!
    fetchRequest: FetchRequest
}

enum ApiSpecType {
    O_DATA
    OPEN_API
}

# Event
type Event {
    spec: EventSpec!
    fetchRequest: FetchRequest
}

type EventSpec {
    type: EventSpecType!
    data: JSON!
}

enum EventSpecType {
    ASYNC_API
}

# Document

type Document {
    data: JSON! # TODO: Or String? Ask Lukasz Gornicki
    fetchRequest: FetchRequest
}

# FetchRequest

type FetchRequest {
    url: String
    credentials: Credentials
    status: FetchRequestStatus!
}

type FetchRequestStatus {
    condition: FetchRequestStatusCondition!
    timestamp: Timestamp!
}

enum FetchRequestStatusCondition {
    INITIAL
    SUCCEEDED
    FAILED
}

# Credential

type Credential {
    id: ID!
    type: CredentialType!
    data: CredentialData!
    requestAuth: CredentialRequestAuth
}

type CredentialRequestAuth {
    type: CredentialRequestAuthType!
    data: JSON! #TODO: interfaces?
}

enum CredentialRequestAuthType {
    CSRF_TOKEN
}

enum CredentialType {
    O_AUTH
    BASIC
}

# in queries we can use __typename
union ConcreteCredential = OauthCredential | BasicCredential

type OAuthCredential {
    clientId: string!
    clientSecret: string!
    url: string!
}

type BasicCredential {
    username: String!
    password: String!
}















# TODO: ???
type Label {
    key: String
    value: String
}


input ApplicationInput {
    name: String!
    description: String
    labels: Labels
#    annotations: Annotations
    apis: [ApiInput!]
    events: [EventInput!]
    documentations: [DocumentationInput!]
}







input ApiInput {
    tbd: String
}


union ConcreateAPiSpec = OdataApiSpec | OpenApiSpec

type OdataApiSpec {
    tbd: String
}

type OpenApiSpec {
    tbd: String
}

input EventInput {
    tbd: String
}


input DocumentationInput {
    tbd: String
}




union ConcreteEventSpec = AsyncApiSpec

type AsyncApiSpec {
    tbd: String
}

#

type Query {
    applications: [Application!]!
    application(id: ID!): Application

    runtimes: [Runtime!]!
    runtime(id: ID!): Runtime
}

type Mutation {
    createApplication(in: ApplicationInput!): Application
    deleteApplication(id: String!): Application
    createApplicationLabel(id: ID!, label: String!, value: String!): Label
    deleteApplicationLabel(id: ID!, label: String!): Label
    createApiDef: String
    deleteApiDef: String
    createEventDef: String
    deleteEventDef: String
    createDocsDef: String
    deleteDocsDef: String

    createRuntime:String
    deleteRuntime: String
    createRuntimeLabel(id: ID!, label: String!, value: String!): String
    deleteRuntimeLabel(id: ID!, label: String!): String

}