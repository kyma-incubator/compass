# Scalars

scalar Timestamp

scalar Tenant # -> String

scalar Labels # -> map[string]string #TODO: Maybe it should be just an array of Label? [Label!]

scalar Annotations # -> map[string]interface{}

scalar HttpHeaders # -> map[string][]string

scalar JSON # -> map[string]interface{}

# Runtime

type Runtime { #TODO: description? @TG
    id: ID!
    name: String!
    tenant: Tenant!
    labels: Labels!
    annotations: Annotations!
    agentCredentials: Credential
    status: RuntimeStatus!
}

type RuntimeStatus {
    condition: RuntimeStatusCondition!
    timestamp: Timestamp!
}

enum RuntimeStatusCondition {
    INITIAL
    READY
    FAILED
}

# Application

type Application {
    id: ID!
    name: String!
    tenant: Tenant!
    description: String
    labels: Labels #TODO: not required but required in Runtime? @TG
#    labels(key: String): Labels #TODO: optional key to query only specific labels? @TG
    annotations: Annotations #TODO: not required but required in Runtime? @TG
    status: ApplicationStatus!
    webhooks: [ApplicationWebhook!]
    apis: [API!]
    events: [Event!]
    docs: [Document!]
}

type ApplicationStatus {
    condition: ApplicationStatusCondition!
    timestamp: Timestamp!
}

enum ApplicationStatusCondition {
    INITIAL 
    UNKNOWN
    READY
    FAILED
}

type ApplicationWebhook {
    type: ApplicationWebhookType! # TODO: enum or union? Do we want to extend a specific type? It would be good to be consistent...
    url: String!
    credential: Credential
}

enum ApplicationWebhookType {
    HEALTH_CHECK
    CONFIGURATION
}

# API

type API {
    id: ID!
    spec: APISpec!
    targetURL: String!
    credential: Credential
    headers: HttpHeaders
}

type APISpec {
    type: APISpecType! # TODO: enum or union? Do we want to extend a specific type? We cannot drop `data` and define some fields. But it would be good to be consistent...
    data: JSON!
    fetchRequest: FetchRequest
}

enum APISpecType {
    O_DATA
    OPEN_API
}

# Event

type Event {
    id: ID!
    spec: EventSpec!
    fetchRequest: FetchRequest
}

type EventSpec {
    type: EventSpecType! # TODO: enum or union? Do we want to extend a specific type? We cannot drop `data` and define some fields. But it would be good to be consistent...
    data: JSON!
}

enum EventSpecType {
    ASYNC_API
}

# Document #TODO: naming: Document vs Documentation? @TG

type Document {
    id: ID!
    type: DocumentType!
    data: String!
    fetchRequest: FetchRequest
}

enum DocumentType {
    MARKDOWN
}

# FetchRequest

type FetchRequest {
    url: String
    credential: Credential
    status: FetchRequestStatus!
}

type FetchRequestStatus {
    condition: FetchRequestStatusCondition!
    timestamp: Timestamp!
}

enum FetchRequestStatusCondition {
    INITIAL
    SUCCEEDED
    FAILED
}

# Credential

type Credential {
    id: ID!
    data: CredentialData!
    requestAuth: CredentialRequestAuth
}

union CredentialRequestAuth = CsrfTokenCredentialRequestAuth

type CsrfTokenCredentialRequestAuth {
    token: String!
}

# in queries we can use __typename
union CredentialData = OAuthCredentialData | BasicCredentialData

type OAuthCredentialData {
    clientId: ID!
    clientSecret: String!
    url: String!
}

type BasicCredentialData {
    username: String!
    password: String!
}

# HealthCheck

union HealthCheckStatus = ManagementPlaneHealthCheck | RuntimeHealthCheck  #TODO: union vs interface base (same behaviour?) @TG

interface HealthCheckStatusBase {
    origin: HealthCheckStatusOrigin! #TODO: enum or id? @TG
}

enum HealthCheckStatusCondition {
    SUCCEEDED # TODO: doesn't look good... maybe we should unify all 'Success' values
    FAILED
}

enum HealthCheckStatusOrigin { #TODO: Application? @TG
    MANAGEMENT_PLANE
    RUNTIME
}

type ManagementPlaneHealthCheck implements HealthCheckStatusBase {
    origin: HealthCheckStatusOrigin!
    condition: HealthCheckStatusCondition!
    message: String
    timestamp: Timestamp!
}

# You cannot extend interfaces in GraphQL, so I figured out that maybe we can consolidate different types.
# TODO: Discuss it
type RuntimeHealthCheck implements HealthCheckStatusBase {
    origin: HealthCheckStatusOrigin!
    runtimeId: ID!
    agent: RuntimeHealthCheckPartialStatus!
    events: RuntimeHealthCheckPartialStatus
    gateway: RuntimeHealthCheckPartialStatus
}

type RuntimeHealthCheckPartialStatus {
    condition: HealthCheckStatusCondition!
    message: String
    timestamp: Timestamp!
}


# ------------------------------------------


type Label {
    key: String #TODO: required? @TG
    value: String #TODO: required? @TG
}

type Annotation {
    key: String!
    value: String! #TODO: interface{} ? should we create scalar for Annotation type? @TG
}

# Application Input

input ApplicationInput {
    name: String!
    description: String
    labels: Labels
#    annotations: Annotations #TODO: why is it commented out? @TG
    apis: [APIInput!]
    events: [EventInput!]
    documentations: [DocumentationInput!]
}

# Runtime Input

input RuntimeInput {
    name: String!
    labels: Labels
#    annotations: Annotations #TODO: why is it commented out? @TG
#    agentCredentials: Credential #TODO: Union is not an input type, what can we do? (we could create nested input objects and check at runtime for example) @TG
}

# FetchRequest Input

input FetchRequestInput {
    url: String
#    credential: Credential #TODO: union as input problem again @TG
}

# API Input

input APIInput {
    spec: APISpecInput
    targetURL: String!
#    credential: Credential #TODO: union as input problem again @TG
    headers: HttpHeaders
}

input APISpecInput { #TODO: type&data can passed on creation or have to fetched? if both, runtime validation required @TG
    type: APISpecType
    data: JSON
    fetchRequest: FetchRequestInput
}

# Event Input

input EventInput {
    spec: EventSpecInput!
    fetchRequest: FetchRequestInput
}

input EventSpecInput {
    type: EventSpecType!
    data: JSON!
}

# Documentation Input

input DocumentationInput { #TODO: type&data can be passed? @TG
    type: DocumentType
    data: String
    fetchRequest: FetchRequestInput
}

#

type Query {
    applications: [Application!]!
    application(id: ID!): Application

    runtimes: [Runtime!]!
    runtime(id: ID!): Runtime

    healthchecks(origin: HealthCheckStatusOrigin, labels: [String!]): [HealthCheckStatus!]! #TODO: type -> origin? @TG

    labels(key: String): [Labels!]!
}

#TODO: Updates @TG
type Mutation {
    createApplication(in: ApplicationInput!): Application
    deleteApplication(id: ID!): Application
    createApplicationLabel(applicationID: ID!, label: String!, value: String!): Label
    deleteApplicationLabel(id: ID!, label: String!): Label
    createApplicationAnnotation(applicationID: ID!, annotation: String!, value: String!): Annotation #TODO: value is string? @TG
    deleteApplicationAnnotation(id: ID!, label: String!): Annotation
    createAPI(applicationID: ID!, in: APIInput!): API
    deleteAPI(id: ID!): API #TODO: ids unique across applications, do we have to specify application id as well? @TG
    createEvent(applicationID: ID!, in: EventInput!): Event
    deleteEvent(id: ID!): Event
    createDoc(applicationID: ID!, in: DocumentationInput!): Document
    deleteDoc(id: ID!): Document

    createRuntime(in: RuntimeInput!): Runtime
    deleteRuntime(id: ID!): Runtime
    createRuntimeLabel(runtimeID: ID!, label: String!, value: String!): Label
    deleteRuntimeLabel(id: ID!, label: String!): Label
    createRuntimeAnnotation(runtimeID: ID!, annotation: String!, value: String!): Annotation #TODO: value string? @TG
    deleteRuntimeAnnotation(id: ID!, annotation: String!): Annotation
}