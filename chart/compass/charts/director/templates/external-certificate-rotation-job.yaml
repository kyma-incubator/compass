apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: "{{ $.Chart.Name }}-external-certificate-rotation-job"
  namespace: "compass-system" # TD: use chart variable
spec:
  schedule: "{{ .Values.global.externalCertJob.schedule }}"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 5
  failedJobsHistoryLimit: 5
  startingDeadlineSeconds: 60
  jobTemplate:
    metadata:
      labels:
        cronjob: {{ .Values.global.externalCertJob.name }}
    spec:
      template:
        metadata:
          labels:
            cronjob: {{ .Values.global.externalCertJob.name }}
        spec:
          {{ if .Values.global.isLocalEnv }}
          hostAliases:
            - ip: {{ .Values.global.minikubeIP }}
              hostnames:
                - "{{ .Values.global.externalServicesMock.certSecuredHost }}.{{ .Values.global.ingress.domainName }}" # TD: host?
          {{ end }}
          restartPolicy: Never
          containers:
          - name: certificate-rotation
            image: bitnami/kubectl:latest
            imagePullPolicy: IfNotPresent
            command:
              - bash
              - -c
              - |
                set -e

                echo "Issuing token..."
                TOKEN=$(curl -s -m 30 -X POST \
                  "$CERT_SVC_TOKEN_URL/oauth/token" \
                  -H 'Content-Type: application/x-www-form-urlencoded' \
                  -H 'Accept: application/json' \
                  -d "grant_type=client_credentials&token_format=bearer&client_id=$CERT_SVC_CLIENT_ID&client_secret=$CERT_SVC_CLIENT_SECRET" \
                  | jq -r .access_token)

                echo "Generating an encrypted private key..."
                PASS_PHRASE=$(openssl rand -base64 32)
                openssl genpkey -pass pass:"$PASS_PHRASE" -aes-256-cbc -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out /tmp/encrypted-private-key.pem

                echo "Saving an unencrypted copy of the private key..."
                openssl rsa -in /tmp/encrypted-private-key.pem -out /tmp/client-private-key.pem -passin pass:"$PASS_PHRASE"
                #chmod 644 /tmp/client-private-key.pem TD: Proly not needed?

                echo "Creating a CSR in json..."
                openssl req -new -sha256 -key /tmp/client-private-key.pem -passin pass:"$PASS_PHRASE" -out /tmp/my-csr.pem \
                   -subj '$CERT_SUBJECT_PATTERN'
                JSON_CSR=$(jq -sR '.' /tmp/my-csr.pem)

                CERT_VALIDITY=7

                echo "Getting the certificate chain..."
                CERT_CHAIN_PKCS7_RESP=$(curl -s -m 30 -X POST \
                  "$CERT_SVC_URL" \
                  -H "Authorization: Bearer $TOKEN" \
                  -H 'Content-Type: application/json' \
                  -H 'Accept: application/json' \
                  -d "{
                        \"certificate-signing-request\": {
                            \"value\": $JSON_CSR,
                            \"type\": \"pkcs10-pem\",
                            \"validity\": {
                              \"value\": $CERT_VALIDITY,
                              \"type\": \"DAYS\"
                            }
                        }
                    }")

                echo "JSON-decoding client certificate chain..."
                CERT_CHAIN_PKCS7=$(jq -r '.["certificate-response"]["value"]' <<< "$CERT_CHAIN_PKCS7_RESP")
                jq -r '.["certificate-response"]["value"]' my-client-certificate-chain-response.json > my-client-certificate_pkcs7.pem

                if [ "$CERT_CHAIN_PKCS7" == "null" ]
                then
                  echo "Could not get certificate response. Reason:"
                  echo "$CERT_CHAIN_PKCS7_RESP"
                  exit 1
                fi

                echo "Extracting client certificate..."
                openssl pkcs7 -print_certs -out client-certificate_pkcs7.pem <<< "$CERT_CHAIN_PKCS7"
                openssl x509 -in client-certificate_pkcs7.pem -out /tmp/client-certificate.pem

                echo "Client certificate secret creating..."
                kubectl create secret tls external-client-certificate --namespace=compass-system --cert=/tmp/client-certificate.pem --key=/tmp/client-private-key.pem --save-config --dry-run=client -o yaml | kubectl apply -f -

                set +e
            env:
              - name: CERT_SVC_URL
                valueFrom:
                  secretKeyRef:
                    name: {{ .Values.global.director.secrets.externalCertSvcSecret.name }}
                    key: {{ .Values.global.director.secrets.externalCertSvcSecret.certSvcUrlKey }}
              - name: CERT_SUBJECT_PATTERN
                value: {{ quote (printf .Values.global.mtlsClient.subjectPattern .Values.global.mtlsClient.locality .Values.global.mtlsClient.commonName) }}
              - name: CERT_ISSUER_LOCALITY
                value: {{ .Values.global.ordAggregator.accessStrategies.cmpMtls.issuerLocality }}
              - name: CERT_SVC_CLIENT_ID
                valueFrom:
                  secretKeyRef:
                    name: {{ .Values.global.director.secrets.externalCertSvcSecret.name }}
                    key: {{ .Values.global.director.secrets.externalCertSvcSecret.clientIdKey }}
              - name: CERT_SVC_CLIENT_SECRET
                valueFrom:
                  secretKeyRef:
                    name: {{ .Values.global.director.secrets.externalCertSvcSecret.name }}
                    key: {{ .Values.global.director.secrets.externalCertSvcSecret.clientSecretKey }}
              - name: CERT_SVC_TOKEN_URL
                valueFrom:
                  secretKeyRef:
                    name: {{ .Values.global.director.secrets.externalCertSvcSecret.name }}
                    key: {{ .Values.global.director.secrets.externalCertSvcSecret.oauthUrlKey }}
